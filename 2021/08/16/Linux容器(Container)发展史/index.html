<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Linux容器（Container）发展史">
<meta property="og:url" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/index.html">
<meta property="og:site_name" content="Lucifer">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/5460EC51825E46C0BE8059FAA9E676D9">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/FFB7E088B246455D914EE9CA1FFA2B8C">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/DAAE3B5719C74AC082F59E02370867CB">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/19B0AC02D1FD40F2A970D566E4AAC044">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/52EB4ADF496F4B25B049BB3864CCD9A9">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/41A1C4F35B914459A3CA9553F7963BF1">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/724E98446FE142399ECC746F000399A0">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/8612FE371E8E4095BAD4891027AFBCD9">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/D4C678E2013948C6ADF8653042E5F162">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/CA81AB020972443A8B9C492CB28783A6">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/D4650DCC5B7F45929D163F18DE88498D">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/2E4759DCA4A144A4A307115113C633D2">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/551FA84F4E074D1B8DD63780D89360EF">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/DBAA973F58584CE691A19000F3178114">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/67B91A6715A94E24A5E936B0FCAED97B">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/E224146AF87A45F8841A40708B23B2B1">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/D467971654AB406093C01D555654D41F">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/715783B7E3584337B5A4CF0A2AC4D7A9">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/CDBF782AD81F4AB9AC010A2BDB74F7BF">
<meta property="og:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/D871C9EE3C7948C8BEBF81A30E53DCD8">
<meta property="article:published_time" content="2021-08-16T15:36:52.408Z">
<meta property="article:modified_time" content="2021-08-16T15:36:52.407Z">
<meta property="article:author" content="MING">
<meta property="article:tag" content="Docker -">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/%E6%A8%A1%E6%9D%BF.assets/5460EC51825E46C0BE8059FAA9E676D9">

<link rel="canonical" href="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux容器（Container）发展史 | Lucifer</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lucifer</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">且将新火试新茶，诗酒趁年华。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">14</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="MING">
      <meta itemprop="description" content="Son of the morning star">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lucifer">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux容器（Container）发展史
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-16 23:36:52" itemprop="dateCreated datePublished" datetime="2021-08-16T23:36:52+08:00">2021-08-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker -</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<span id="more"></span>

<p>[TOC]</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原文连接:</span><br><span class="line">	https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14013388</span>.html</span><br></pre></td></tr></table></figure>



<h1 id="一-容器-Container-技术概述"><a href="#一-容器-Container-技术概述" class="headerlink" title="一.容器(Container)技术概述"></a>一.容器(Container)技术概述</h1><h2 id="1-什么是容器-Container"><a href="#1-什么是容器-Container" class="headerlink" title="1.什么是容器(Container)"></a>1.<strong>什么是容器(Container)</strong></h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">容器是一种基础工具；泛指任何可以用于容纳其它物品的工具，可以部分或完全封闭，被用于容纳，存储，运输物品；物体可以被放置在容器中，而容器则可以保护内容物。</span><br><span class="line"></span><br><span class="line">　　人类使用容器的历史至少有十万年，甚至可能有数百万的历史。以下是我们生活中常见到的容器的类型:</span><br><span class="line">       瓶:</span><br><span class="line">           指口部比腹部窄小，颈长的容器。</span><br><span class="line">       罐:</span><br><span class="line">           指那些开口较大，一般为近圆筒形的器皿。</span><br><span class="line">       箱:</span><br><span class="line">           通常是立方体或圆柱体。形状固定。</span><br><span class="line">       篮:</span><br><span class="line">           以条形物编织而成。</span><br><span class="line">       桶:</span><br><span class="line">           一种圆柱形的容器。</span><br><span class="line">       袋:</span><br><span class="line">           柔性材料制成的容器，形状会受内容物而变化。</span><br><span class="line">       翁:</span><br><span class="line">           通常是指陶制，口小肚大的容器。</span><br><span class="line">       碗:</span><br><span class="line">           用来盛载食物的容器。</span><br><span class="line">       柜:</span><br><span class="line">           指由一个盒组成的家俱。</span><br><span class="line">       鞘:</span><br><span class="line">           用于装载刀刃的容器。</span><br><span class="line"></span><br><span class="line">   综上所述，想必大家对容器这个概念应该有所了解，说了这么多，我想表达的是: <span class="string">&quot;计算机中的技术来源于现实生活&quot;</span>。</span><br><span class="line"></span><br><span class="line">   那计算机所指的容器(Container)到底是什么呢？可能你会说它是能装<span class="string">&quot;东西&quot;</span>的一个技术，那这个<span class="string">&quot;东西&quot;</span>到底是啥呢？自然是就是我们熟悉的所有应用程序(Application Program)啦。</span><br><span class="line"></span><br><span class="line">   我们以Linux容器为例，它是运行在操作系统上的一系列进程。运行这些进程所需的所有文件都由另一个只读镜像文件提供，这意味着从<span class="string">&quot;开发 -&gt; 测试 --&gt; 生产&quot;</span>的整个过程中，Linux容器都具有可移植性和一致性。</span><br><span class="line"></span><br><span class="line">   换句话说，Linux容器技术能够让您对应用及其整个运行时环境(包括全部所需文件)一起进行打包或隔离。从而让您可以在不同环境(如开发、测试和生产等环境)之间轻松迁移应用，同时还可保留应用的全部功能。</span><br><span class="line"></span><br><span class="line">   因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。容器比较普遍也易于使用，因此也成了IT安全方面的重要组成部分。将安全性内置于容器管道，可以为您的基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</span><br><span class="line">   </span><br><span class="line">   推荐阅读: </span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics<span class="regexp">/containers/</span>whats-a-linux-container。</span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics<span class="regexp">/security/</span>container-security</span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics/security</span><br><span class="line">       https:<span class="regexp">//</span>www.docker.com<span class="regexp">/resources/</span>what-container</span><br><span class="line">       https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/get-started/</span><span class="comment">#what-is-a-container</span></span><br></pre></td></tr></table></figure>



<h2 id="2-为什么要用容器"><a href="#2-为什么要用容器" class="headerlink" title="2.为什么要用容器"></a>2.为什么要用容器</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">场景:</span><br><span class="line">　　　　假设您在使用一台笔记本电脑开发一个应用，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用不止依赖于您当前的配置，还需要某些特定的库、依赖项和文件。</span><br><span class="line">　　　　与此同时，您的企业还拥有标准化的开发和生产环境，有着自己的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。</span><br><span class="line"></span><br><span class="line">　　根据以上场景分析，您要考虑如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的各种依赖问题，也无需重新编写代码和进行故障修复呢？答案就是使用容器。</span><br><span class="line">　　　　(<span class="number">1</span>)容器可以确保您的应用拥有必需的库、依赖项和文件，让您可以在生产中自如地迁移这些应用，无需担心会出现任何负面影响。</span><br><span class="line">　　　　(<span class="number">2</span>)实际上，您可以将容器镜像中的内容，视为<span class="selector-tag">Linux</span>发行版的一个安装实例，因为其中完整包含<span class="selector-tag">RPM</span>软件包、配置文件等内容。但是，安装容器镜像发行版，要比安装新的操作系统副本容易得多。这样可以避免不必要的麻烦，做到皆大欢喜。</span><br><span class="line"></span><br><span class="line">　　虽然这只是一个常见情况的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用<span class="selector-tag">Linux</span>容器通过很多方式解决难题。 <span class="selector-tag">Linux</span>容器的价值在于，它能加速开发并满足新出现的业务需求。</span><br><span class="line"></span><br><span class="line">　　在某些情形中(如通过Apache Kafka进行实时数据流处理)，容器是不可或缺的，因为它们是提供应用所需的可扩展性的唯一途径。 无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。当然，选择正确的容器平台也同样重要。</span><br><span class="line"></span><br><span class="line">　　在云服务范畴内，<span class="selector-tag">CaaS</span>被认为是基础架构即服务(IaaS)的一种子集，介于<span class="selector-tag">IaaS</span>和平台即服务(PaaS)之间。  <span class="selector-tag">CaaS</span>的基本资源为容器，它是云原生应用和微服务的常见部署机制。此外，<span class="selector-tag">CaaS</span>还可以提高环境之间的可移植性，无论是混合环境还是多云环境。</span><br><span class="line"></span><br><span class="line">　　使用容器有很多好处，以下是比较容器可圈可点的特性:</span><br><span class="line">       (<span class="number">1</span>)可移植性：</span><br><span class="line">           用容器开发的应用拥有运行所需的一切，并可以部署在包括私有云和公共云在内的多种环境中。</span><br><span class="line">           可移植性也意味着灵活性，因为您可以更轻松地在环境和提供商之间移动工作负载。 </span><br><span class="line">       (<span class="number">2</span>)可扩展性：</span><br><span class="line">           容器具有水平扩展的功能，这意味着用户可以在同一集群中成倍增加相同容器的数量，从而根据需要进行扩展。</span><br><span class="line">           通过仅在需要时使用和运行所需的内容，可以大大降低成本。 </span><br><span class="line">       (<span class="number">3</span>)高效性：</span><br><span class="line">           容器所需的资源要少于虚拟机(VM)，因为它们不需要虚拟单独的操作系统。</span><br><span class="line">           您可以在单个服务器上运行多个容器，而且它们需要较少的裸机硬件，这意味着成本更低。</span><br><span class="line">       (<span class="number">4</span>)更高的安全性：</span><br><span class="line">           容器之间彼此隔离，这意味着在一个容器遭到破坏的情况下，其他容器并不会受到影响。 </span><br><span class="line">       (<span class="number">5</span>)速度：</span><br><span class="line">           由于容器相对于操作系统具有自主性，因此其启动和停止仅需几秒钟的时间。这也加快了开发和运维工作，同时带来了更快、更流畅的用户体验。</span><br></pre></td></tr></table></figure>



<h1 id="二-常见的容器管理技术概述"><a href="#二-常见的容器管理技术概述" class="headerlink" title="二.常见的容器管理技术概述"></a>二.常见的容器管理技术概述</h1><h2 id="1-Unix-chroot"><a href="#1-Unix-chroot" class="headerlink" title="1.Unix chroot"></a>1.Unix chroot</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　容器的概念始于<span class="number">1979</span>年前后的UNIX chroot，它是一个UNIX操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。</span><br><span class="line"></span><br><span class="line">　　这个功能的想法是为每个进程提供独立的磁盘空间。其后在<span class="number">1982</span>年前后，它被加入到了<span class="keyword">BSD系统中。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　<span class="keyword">BSD是Unix的扩展版本，FreeBSD是BSD发行版最流行的系统。</span></span><br></pre></td></tr></table></figure>



<h2 id="2-Unix-FreeBSD-jail"><a href="#2-Unix-FreeBSD-jail" class="headerlink" title="2.Unix FreeBSD jail"></a>2.Unix FreeBSD jail</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在<span class="number">2000</span>年前后，FreeBSD jail这种技术可将FreeBSD系统分区为多个子系统(也称为Jail)。Jail是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些Jail。</span><br><span class="line">   </span><br><span class="line">　　Jail的目的是让进程在经过修改的chroot环境中创建，而不会脱离和影响整个系统。在chroot环境中，对文件系统、网络和用户的访问都实现了虚拟化。　　</span><br><span class="line">　　</span><br><span class="line">　　尽管Jail在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。但这个概念非常有吸引力。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">       https:<span class="regexp">//</span>www.freebsd.org<span class="regexp">/doc/</span>handbook/jails.html</span><br><span class="line">       https:<span class="regexp">//</span>www.freebsd.org/</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/5460EC51825E46C0BE8059FAA9E676D9" alt="img"></p>
<h2 id="3-Linux-VServer"><a href="#3-Linux-VServer" class="headerlink" title="3.Linux-VServer"></a>3.Linux-VServer</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2001</span>年前后，通过Jacques Gélinas的VServer项目，隔离环境的实施进入了Linux领域。正如Gélinas所说:<span class="string">&quot;这项工作的目的是高度独立且安全的单一环境中运行多个通用Linux服务器&quot;</span>。 </span><br><span class="line"></span><br><span class="line">　　Linux-VServer也是一个操作系统级虚拟化解决方案。Linux-VServer对Linux内核进行虚拟化，这样多个用户空间环境又称为<span class="string">&quot;Virtual Private Server&quot;</span>(简称<span class="string">&quot;VPS&quot;</span>)就可以单独运行，而不需要互相了解。</span><br><span class="line"></span><br><span class="line">　　Linux-VServer通过修改Linux内核实现用户空间的隔离。Linux VServer也使用了chroot来为每个VPS隔<span class="built_in">离root</span>目录。虽然chroot允许指定<span class="built_in">新root</span>目录，但还是需要其他一些功能(称为Chroot-Barrier)来限制VPS脱离其隔离<span class="built_in">的root</span>目录回到上级目录。</span><br><span class="line"></span><br><span class="line">　　给定一个隔离<span class="built_in">的root</span>目录之后，每个VPS就可以拥有自己的用户列表<span class="built_in">和root</span>密码。在完成了这项针对Linux中多个受控制用户空间的基础性工作后，Linux容器开始逐渐成形并最终发展成了现在的模样。</span><br><span class="line">　　</span><br><span class="line">　　如下图所示，<span class="number">2.4</span>和<span class="number">2.6</span>版本的Linux内核支持Linux-VServer，它可以运行于很多平台之上，包括 x86、x86-<span class="number">64</span>、SPARC、MIPS、ARM 和 PowerPC。</span><br><span class="line">　　</span><br><span class="line">　　温馨提示:　　　　</span><br><span class="line">		同年时间(即<span class="number">2001</span>年)，Parallels公司发布了Virtuozzo Container产品，只不过该版本是商用版本。直到<span class="number">2005</span>年才基于Virtuozzo Containers研发了OpenVZ进行开源。</span><br><span class="line">	</span><br><span class="line">	推荐阅读:</span><br><span class="line">        http://linux-vserver.org/Welcome_to_Linux-VServer.org</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/FFB7E088B246455D914EE9CA1FFA2B8C" alt="img"></p>
<h2 id="4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版"><a href="#4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版" class="headerlink" title="4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)"></a>4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2004</span>年前后，作为Solaris <span class="number">10</span>中具有突破性意义的关键技术之一，由Sun公司虚拟化专家Joost Pronk van Hoogeveen、Jeff Victor和Chien-Hua Yen等研发的Solaris Containers能够促进服务器整合，并提高应用程序可用性和易管理性。</span><br><span class="line"></span><br><span class="line">　　Solaris网格容器由两个主要组件构成：Solaris区域(Zone)和Solaris资源管理器(SRM)。SRM 管理每个容器接收到的物理系统资源，而Solaris区域则控制名称空间隔离。<span class="string">&quot;区域&quot;</span>和SRM一起构成Solaris容器的基础。</span><br><span class="line"></span><br><span class="line">　　在<span class="number">2008</span>年前后Sun以<span class="number">10</span>亿美元收购开源数据库公司MySQL，做为一个开源的关系型数据库管理系统，MySQL在市场上受到了广泛的欢迎，并成为流行的网站架构方式LAMP(Linux+Apache+MySQL+PHP)的一部分。</span><br><span class="line">　　　　</span><br><span class="line">　　<span class="number">2009</span>年<span class="number">4</span>月<span class="number">20</span>日，加利福尼亚州圣克拉拉市Sun Microsystems（NASDAQ：JAVA）和Oracle Corporation（NASDAQ：ORCL）今天宣布，他们已达成最终协议，根据该协议，Oracle将以每股<span class="number">9.50</span>美元的现金价格收购Sun普通股。</span><br><span class="line">　　　　交易总价值约为<span class="number">74</span>亿美元，扣除Sun的现金和债务后为<span class="number">56</span>亿美元。曾经的工作站之王、Unix之王和缔造了Solaris、Java传奇的巨人Sun倒下了</span><br><span class="line"></span><br><span class="line">　　Java和JavaScript啥关系?　　　　</span><br><span class="line">　　	Java由SUN公司研发，SUN公司和网景(Netscape)公司的是合作关系。JavaScript在<span class="number">1995</span>年由Netscape公司(该公司成立于<span class="number">1994</span>年)的Brendan Eich，在网景导航者浏览器上首次设计实现而成。</span><br><span class="line">　　　　因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。JavaScript的标准是ECMAScript 。</span><br><span class="line">　　　　<span class="number">1998</span>年<span class="number">11</span>月，网景被美国在线（American OnLine，AOL）收购，而后来美国在线和时代华纳合并，之后再独立。美国在线依然使用网景这品牌。</span><br><span class="line">　　　　<span class="number">2007</span>年<span class="number">12</span>月<span class="number">28</span>日，美国在线在博客表示将停止网景浏览器的开发，并于<span class="number">2008</span>年<span class="number">3</span>月<span class="number">1</span>日停止安全更新和所有的技术支持，并建议用户转移使用Mozilla Firefox浏览器。</span><br><span class="line">　　　　这就意味着于<span class="number">1994</span>年问世的Netscape将正式退出历史舞台。于<span class="number">2008</span>年<span class="number">3</span>月<span class="number">1</span>日停止支持的网景浏览器后，保留了门户网站Netscape。此外也有经营着一个以网景为名的廉价互联网服务。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.lampchina.net<span class="regexp">/ask/</span>MTM3MTkwMg.html</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.fujitsu.com<span class="regexp">/global/</span>products<span class="regexp">/computing/</span>servers<span class="regexp">/unix/</span>sparc-enterprise<span class="regexp">/software/</span>solaris10<span class="regexp">/container/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>baike.baidu.com<span class="regexp">/item/</span>%E7%BD%<span class="number">91</span>%E6%<span class="number">99</span>%AF/<span class="number">70176</span>?fromtitle=netscape&amp;fromid=<span class="number">2778944</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/DAAE3B5719C74AC082F59E02370867CB" alt="img"></p>
<h2 id="5-Parallels-Virtuozzo-OpenVZ"><a href="#5-Parallels-Virtuozzo-OpenVZ" class="headerlink" title="5.Parallels Virtuozzo/OpenVZ"></a>5.Parallels Virtuozzo/OpenVZ</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2005</span>年前后，前面我们提到过，Virtuozzo(<span class="number">2001</span>年发布)是SWsoft公司（目前SWsoft已经改名为Parallels）的操作系统虚拟化软件的命名，Virtuozzo是商业解决方案，而OpenVZ是以Virtuozzo为基础的开源项目，它们采用的也是操作系统级虚拟化技术。</span><br><span class="line"></span><br><span class="line">　　OpenVZ类似于Linux-VServer，它通过对Linux内核进行补丁来提供虚拟化、隔离、资源管理和状态检查。每个OpenVZ容器都有一套隔离的文件系统、用户及用户组等。</span><br><span class="line"></span><br><span class="line">　　OpenVZ是Linux的基于容器的虚拟化。OpenVZ在单个物理服务器上创建多个安全的，隔离的Linux容器(也称为VE或VPS)，以提高服务器利用率并确保应用程序不冲突。</span><br><span class="line"></span><br><span class="line">　　每个容器的执行和执行都完全像独立服务器一样。容器可以独立地重新引导，并且具有root用户访问权限，用户，IP地址，内存，进程，文件，应用程序，系统库和配置文件。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Main_Page</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Quick_installation</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Download</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/19B0AC02D1FD40F2A970D566E4AAC044" alt="img"></p>
<h2 id="6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术"><a href="#6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术" class="headerlink" title="6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术"></a>6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">早期，<span class="selector-tag">Jail</span>和<span class="selector-tag">VServer</span>基本上都是在<span class="selector-tag">chroot</span>概念之上稍作改进和其他一些标准工具的组合来实现此特定的虚拟服务器模型。很快，更多技术结合进来，让这种隔离方法从构想变为现实。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">2007</span>年前后，<span class="selector-tag">Linux</span>内核支持<span class="selector-tag">Cgroup</span>和<span class="selector-tag">NameSpace</span>技术，这两种技术在增加对<span class="selector-tag">Linux</span>的整体控制的同时，也成为了保持环境隔离的重要框架。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">NameSpace</span>(命名空间)主要包含以下六种技术:</span><br><span class="line">　　　　<span class="selector-tag">MNT</span> <span class="selector-tag">Namespace</span>(提供磁盘挂载点和文件系统的隔离能力):</span><br><span class="line">　　　　　　每个容器都要有独立的根文件系统用户空间，以实现在容器里面启动服务并且使用容器的运行环境。换句话说，就是在容器里面不能访问宿主机的资源，宿主机是使用了<span class="selector-tag">chroot</span>技术把容器锁定到一个指的运行目录里面。</span><br><span class="line">　　　　　　举个例子:</span><br><span class="line">　　　　        一个宿主机是<span class="selector-tag">ubuntu</span>的服务器，可以在里面启动一个<span class="selector-tag">centos</span>运行环境的容器并且在里面启动一个<span class="selector-tag">Nginx</span>服务，此<span class="selector-tag">Nginx</span>运行时使用的运行环境就是<span class="selector-tag">centos</span>系统目录的运行环境。</span><br><span class="line">　　　　<span class="selector-tag">IPC</span> <span class="selector-tag">Namespace</span>(提供进程间通信的隔离能力):</span><br><span class="line">　　　　　　一个容器内的进程间通信，允许一个容器内的不同进程的(内存,缓存等)数据访问，但是不能跨容器访问其他容器的数据 。</span><br><span class="line">　　　　<span class="selector-tag">UTS</span> <span class="selector-tag">Namespace</span>(提供主机名隔离能力):</span><br><span class="line">　　　　　　用于系统标识,其中包含了<span class="selector-tag">hostname</span>和域名<span class="selector-tag">domainname</span>,它使得一个容器拥有属于自己<span class="selector-tag">hostname</span>标识,这个主机名标识独立于宿主机系统和其上的他容器 。</span><br><span class="line">　　　　<span class="selector-tag">PID</span> <span class="selector-tag">Namespace</span>(提供进程隔离能力):</span><br><span class="line">　　　　　　<span class="selector-tag">CentOS</span> <span class="selector-tag">Linux</span>系统中，有一个<span class="selector-tag">PID</span>为<span class="selector-tag">1</span>的进程(init/systemd)是其他所有进程的父。</span><br><span class="line">　　　　　　在每个容器内也要有一个父进程来管理其下属的子进程，多个容器进程的<span class="selector-tag">PID</span> <span class="selector-tag">namespace</span>进程隔离(比如PID编号重复、容器内的主进程与回收子进程等)。</span><br><span class="line">　　　　<span class="selector-tag">Net</span> <span class="selector-tag">Namespace</span>(提供网络隔离能力):</span><br><span class="line">　　　　　　每一个容器都类似于虚拟机一样有自己的网卡，监听端口，<span class="selector-tag">TCP</span>/<span class="selector-tag">IP</span>协议栈等。</span><br><span class="line">　　　　　　以<span class="selector-tag">Docker</span>为例，使用<span class="selector-tag">network</span> <span class="selector-tag">namespace</span>启动一个<span class="selector-tag">vethX</span>接口，这样你的容器将拥有它自己的桥接<span class="selector-tag">ip</span>地址，通常是<span class="selector-tag">docker0</span>。</span><br><span class="line">　　　　　　上面提到的<span class="selector-tag">docker0</span>本质上是<span class="selector-tag">Linux</span>的虚拟网桥(Virtual Bridge)，网桥是在<span class="selector-tag">OSI</span>七层模型的数据链路网络设备，通过<span class="selector-tag">mac</span>地址对网络进行划分，并且在不同网络直接传递数据。</span><br><span class="line">　　　　<span class="selector-tag">User</span> <span class="selector-tag">Namespace</span>(提供用户隔离能力):</span><br><span class="line">　　　　　　各个容器内可能会出现重名的用户和用户组名称,或重复的用户<span class="selector-tag">UID</span>或者<span class="selector-tag">GID</span>,那么怎隔离各个容器内的用户空间呢？</span><br><span class="line">　　　　　　<span class="selector-tag">User</span> <span class="selector-tag">Namespace</span>允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户<span class="selector-tag">UID</span>和<span class="selector-tag">GID</span>，只是会用户的作用范围限制在每个容器内。</span><br><span class="line">　　　　　　即<span class="selector-tag">A</span>容器和<span class="selector-tag">B</span>容器可以有相同的用户名称和<span class="selector-tag">ID</span>的账户，但是此用户的有效范围仅是当前容器内，不能访问另外一个容器内的文件系统，即相互隔离，互不影响，永不相见。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">Cgroups</span>:</span><br><span class="line">　　　　一个容器如果不对其做任何资源限制，则宿主机(也称为物理机，英文名称为:<span class="string">&quot;Physical machine&quot;</span>)会允许其占用无限大的内存空间，有时候会因为代码<span class="selector-tag">bug</span>程序会一直申请内存，直到把宿主机内存占完。</span><br><span class="line">　　　　综上所述，为了避免此类的问题出现，宿主机有必要对容器进行资源分配限制，比如<span class="selector-tag">CPU</span>，内存，磁盘等。</span><br><span class="line">　　　　<span class="selector-tag">Linux</span> <span class="selector-tag">Cgroups</span>的全称是<span class="selector-tag">Linux</span> <span class="selector-tag">Control</span> <span class="selector-tag">Groups</span>，它最主要的作用就是限制一个进程组能够使用的资源上限，包括<span class="selector-tag">CPU</span>，内存，磁盘，网络带宽等等。</span><br><span class="line">　　　　此外，<span class="selector-tag">Linux</span> <span class="selector-tag">Cgroups</span>还能够对进程优先级设置，以及将进程挂起和恢复等操作。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　如下图所示，有关的<span class="selector-tag">NameSpace</span>(命名空间)各种核心技术所支持的<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span>的发行版本。因此推荐大家使用<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span> <span class="selector-tag">3</span><span class="selector-class">.8</span>+的版本哟~</span><br><span class="line">　　　　如果您使用的是<span class="selector-tag">Ubuntu</span>就不用担心<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span>版本啦，因为它使用的<span class="selector-tag">Kernel</span>版本要比<span class="selector-tag">CentOS</span>的新，但如果您要是想使用<span class="selector-tag">CentOS</span>发行，推荐使用<span class="selector-tag">CentOS</span> <span class="selector-tag">7</span><span class="selector-class">.6</span>+版本。</span><br><span class="line"></span><br><span class="line">   参考连接:</span><br><span class="line">       <span class="selector-tag">https</span>:<span class="comment">//www.cnblogs.com/yinzhengjie/p/12183066.html</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/52EB4ADF496F4B25B049BB3864CCD9A9" alt="img"></p>
<h2 id="7-LXC-LXD"><a href="#7-LXC-LXD" class="headerlink" title="7.LXC/LXD"></a>7.LXC/LXD</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">由于inux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术，这意味着一切都可在Linux内核中实现虚拟化，因此推动了容器的进一步发展。</span><br><span class="line"></span><br><span class="line">　　LXC:</span><br><span class="line">　　　　<span class="number">2008</span>年前后，作为一个开源容器平台，Linux容器项目LXC是众所周知的工具，模板，库和语言绑定集。它的级别很低，非常灵活，几乎涵盖了上游内核支持的每个遏制功能。同年，RedHat公司发布了用于管理虚拟化平台的Libvirt工具。</span><br><span class="line">　　　　LXC是Linux内核包含功能的用户空间接口。通过功能强大的API和简单的工具，它使Linux用户可以轻松地创建和管理系统或应用程序容器。LXC采用简单的命令行界面，可改善容器启动时的用户体验。</span><br><span class="line">　　　　LXC提供了一个操作系统级的虚拟化环境，可在许多基于Linux的系统上安装。在Linux发行版中，可能会通过其软件包存储库来提供LXC。</span><br><span class="line">　　　　当前的LXC使用以下内核功能来包含进程：</span><br><span class="line">　　　　　　(<span class="number">1</span>)Kernel namespaces (ipc, uts, mount, pid, network and user);</span><br><span class="line">　　　　　　(<span class="number">2</span>)Apparmor and SELinux profiles;</span><br><span class="line">　　　　　　(<span class="number">3</span>)Seccomp policies;</span><br><span class="line">　　　　　　(<span class="number">4</span>)Chroots (using pivot_root);</span><br><span class="line">　　　　　　(<span class="number">5</span>)Kernel capabilities;</span><br><span class="line">　　　　　　(<span class="number">6</span>)CGroups (control groups);</span><br><span class="line">　　　　LXC容器通常被认为是chroot和成熟的虚拟机之间的中间对象。LXC的目标是创建一个与标准Linux安装尽可能接近的环境，而不需要单独的内核。</span><br><span class="line">　　　　LXC的意思是LinuX Containers，它是第一个最完善的Linux容器管理器的实现方案，是通过cgroups和Linux名字空间namespace实现的。</span><br><span class="line">　　　　LXC存在于liblxc库中，提供了各种编程语言的API实现，包括Python3、Python2、Lua、Go、Ruby和Haskell等。</span><br><span class="line">　　　　与其它容器技术不同的是，LXC可以工作在普通的Linux内核上，而不需要增加补丁。现在LXC project是由Canonical Ltd.赞助的项目，目前由Canonical公司赞助并托管的。</span><br><span class="line"></span><br><span class="line">　　LXD: </span><br><span class="line">　　　　虽然LXC使得用户能够通过简单的命令行界面轻松地启动使用容器，但是和我们过去使用的虚拟机来讲，它的复杂程度并没有多大降低，而且其隔离性依旧没有虚拟机好。　　</span><br><span class="line">　　　　LXC最大的好处就是在性能和资源上有所节约，但是在大规模容器使用上LXC依然没有找到很好的突破口，于是后来就出现了LXD，Docker等技术。</span><br><span class="line">　　　　LXD是新的LXC体验。它使用一个命令行工具来管理容器，从而提供了全新的直观用户体验。可以通过REST API以透明方式通过网络管理容器。通过与OpenNebula和OpenStack等云平台集成，它还可以用于大规模部署。 </span><br><span class="line">　　　　LXD是下一代系统容器管理器。它提供类似于虚拟机的用户体验，但是使用Linux容器。它基于映像，并带有可用于各种Linux发行版的预制映像，并且基于非常强大但非常简单的REST API构建。 </span><br><span class="line"></span><br><span class="line">　　推荐阅读: </span><br><span class="line">　　　　https:<span class="regexp">//</span>www.freedesktop.org<span class="regexp">/wiki/</span>Software<span class="regexp">/systemd/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org/</span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org<span class="regexp">/lxc/i</span>ntroduction/</span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org<span class="regexp">/lxd/i</span>ntroduction/</span><br><span class="line">　　　　http:<span class="regexp">//</span>www.canonical.com/</span><br><span class="line">　　　　https:<span class="regexp">//</span>libvirt.org/</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/41A1C4F35B914459A3CA9553F7963BF1" alt="img"></p>
<h2 id="8-Docker"><a href="#8-Docker" class="headerlink" title="8.Docker"></a>8.Docker</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2013</span>年dotCloud公司首次在pycon官网首次公布了Docker开源版本。Docker带来了一种先进的软件交付方式，即通过容器进行进行软件的交付。并对外宣传的是Build(本地编译)，Ship(传输到其他服务器节点)，Run(可以移植到指定的服务器运行)。</span><br><span class="line"></span><br><span class="line">　　实际上我们可以使用docker build将代码的运行环境制作成镜像，通过dock push将镜像发布至私有或共有的docker仓库。其他人可以通过dock pull下载你提交的镜像，而后使用docker run将指定在镜像启动。此过程可以排除环境依赖等问题。</span><br><span class="line"></span><br><span class="line">　　docker这款开源软件可以有效的解决(程序员开发的)程序在运行时环境差异而带来的一系列问题，达到<span class="string">&quot;Build once, Run anywhere&quot;</span>的目标。</span><br><span class="line"></span><br><span class="line">　　此后docker也称为了容器的代名词(就想Hadoop成了大数据的代名词一样)，并成为容器时代的引领者。关于Docker容器的历史，架构，应用场景等我这里不做赘述，感兴趣的小伙伴可参考我另外一篇笔记。 　　</span><br><span class="line">   Docker容器的应用场景:</span><br><span class="line">　　　　(<span class="number">1</span>)应用程序打包和发布;</span><br><span class="line">　　　　(<span class="number">2</span>)应用程序隔离；</span><br><span class="line">　　　　(<span class="number">3</span>)持续集成;</span><br><span class="line">　　　　(<span class="number">4</span>)部署微服务;</span><br><span class="line">　　　　(<span class="number">5</span>)快速搭建测试环境;</span><br><span class="line">　　　　(<span class="number">6</span>)提供CAAS产品;</span><br><span class="line">　　　　</span><br><span class="line">　　推荐阅读: 　　　　 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14017860</span>.html 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14022268</span>.html 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//u</span>s.pycon.org<span class="regexp">/2013/</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/724E98446FE142399ECC746F000399A0" alt="img"></p>
<h2 id="9-RedHat-已被IBM收购-的CoreOS-rkt容器技术"><a href="#9-RedHat-已被IBM收购-的CoreOS-rkt容器技术" class="headerlink" title="9.RedHat(已被IBM收购)的CoreOS rkt容器技术"></a>9.RedHat(已被IBM收购)的CoreOS rkt容器技术</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Rkt诞生于<span class="number">2014</span>年<span class="number">11</span>月末，我在GitHub上发现他在<span class="number">2014</span>年<span class="number">11</span>月<span class="number">27</span>日就发布了<span class="string">&quot;v0.0.0&quot;</span>版本，<span class="string">&quot;v0.1.0&quot;</span>版本是在同年的<span class="number">12</span>月<span class="number">1</span>日发布的。</span><br><span class="line"></span><br><span class="line">   Rkt是一种与Docker类似的容器引擎，由CoreOS公司主导，得到了Redhat、Google、Vmware等公司的支持，更加专注于解决安全、兼容、执行效率等方面的问题。</span><br><span class="line"></span><br><span class="line">   CoreOS公司最早是Docker的支持者，其产品CoreOS操作系统是适用于企业的轻量级容器化的Linux发行版，是Docker生态圈的重要一员。</span><br><span class="line">   </span><br><span class="line">   随着Docker在容器行业变得逐渐强大，Docker也越来越臃肿，CoreOS公司希望有一个更加开放和中立的容器标准，因此推出了自己的容器计划，很明显CoreOS公司也想在容器方面有一席之地。</span><br><span class="line"></span><br><span class="line">   就这样，CoreOS公司成为了Docker公司的容器引擎竞争对手。由于Docker已经深入人心，尽管Rkt也很优秀，但很少有人愿意将Docker技术栈迁移到Rkt技术栈。最终容器之战Docker占领了大部分市场。</span><br><span class="line"></span><br><span class="line">   <span class="number">2018</span>年<span class="number">4</span>月<span class="number">16</span>日是发布的最新rkt容器工具，目前该项目已经停止维护，因此生产环境中不推荐大家使用该容器技术。推荐使用主流的容器工具，如Docker，Pouch，podman。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   参考链接:</span><br><span class="line">       https:<span class="regexp">//gi</span>thub.com<span class="regexp">/rkt/</span>rkt/releases</span><br><span class="line">       https:<span class="regexp">//</span>www.sohu.com<span class="regexp">/a/</span><span class="number">216850450</span>_468741</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/8612FE371E8E4095BAD4891027AFBCD9" alt="img"></p>
<h2 id="10-阿里开源的Pouch容器技术"><a href="#10-阿里开源的Pouch容器技术" class="headerlink" title="10.阿里开源的Pouch容器技术"></a>10.阿里开源的Pouch容器技术</h2><p><img src="%E6%A8%A1%E6%9D%BF.assets/D4C678E2013948C6ADF8653042E5F162" alt="img"></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>年<span class="number">11</span>月<span class="number">19</span>日上午，在中国开源年会现场，阿里巴巴正式开源了基于Apache <span class="number">2.0</span>协议的容器技术Pouch。</span><br><span class="line"></span><br><span class="line">　　Pouch Container是阿里巴巴集团创建的一个开源项目，旨在促进集装箱技术的发展。</span><br><span class="line"></span><br><span class="line">　　Pouch Container的愿景是改善容器生态系统并促进容器标准OCI（开放容器计划），从而使容器技术成为云时代应用程序开发的基础。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以打包，交付和运行任何应用程序。它为应用程序提供了轻量级的运行时环境，具有强大的隔离性和最小的开销。Pouch Container将应用程序与变化的运行时环境隔离开来，并最大程度地减少了操作工作量。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以最大程度地减少应用程序开发人员编写本机应用程序或将旧版应用程序迁移到Cloud平台的工作。</span><br><span class="line"></span><br><span class="line">　　Pouch是一款轻量级的容器技术，拥有快速高效、可移植性高、资源占用少等特性，主要帮助阿里更快的做到内部业务的交付，同时提高超大规模下数据中心的物理资源利用率。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　上图是Pouch容器的内部实现架构图，下图是Pouch容器的生态系统图。</span><br><span class="line">　　　　在Pouch Container的路线图中，我们将拥抱生态系统作为主要目标。对于上层业务流程层，Pouch Container支持Kubernetes和Swarm。</span><br><span class="line">　　　　对于底层运行时层，Pouch Container支持runC，runV(该容器引擎由音速神童公司<span class="number">2015</span>年<span class="number">5</span>月左右发起的，同年发布的还有Intel公司发起的Clear Container)，runlxc等。为了使存储和网络大为补充，CNI和CSI就在其中。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/alibaba/</span>pouch</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com/opencontainers</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.infoq.cn<span class="regexp">/article/</span>alibaba-pouch</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/alibaba/</span>pouch<span class="regexp">/blob/m</span>aster<span class="regexp">/docs/</span>architecture.md</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencontainers/</span>runc</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/hyperhq/</span>runv</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/containernetworking/</span>cni</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com/container-storage-interface</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/CA81AB020972443A8B9C492CB28783A6" alt="img"></p>
<h2 id="11-音速神童kata-containers"><a href="#11-音速神童kata-containers" class="headerlink" title="11.音速神童kata-containers"></a>11.音速神童kata-containers</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">技术创业公司音速神童成立于<span class="number">2015</span>年，由两位中国开发者赵鹏和王旭创建。经过两年的发展，成长为全球容器行业的的重要技术和力量，</span><br><span class="line"></span><br><span class="line">　　<span class="number">2017</span>年<span class="number">12</span>月，音速神童在KubeCon上对外发布了Kata Containers安全容器项目，这个项目的两个前身是:音速神童的自研容器产品runV和Inter公司的容器产品Clear Container，而这两个项目均发布于<span class="number">2015</span>年<span class="number">5</span>月。</span><br><span class="line"></span><br><span class="line">　　kata COntainers其支持者包括<span class="number">99</span>cloud、AWcloud、Canonical、中国移动、City Network、CoreOS、Dell/EMS、EasyStack、Fiberhome、谷歌、华为、京东、Mirantis、NetApp、Red Hat、SUSE、腾讯、Ucloud、UnitedStack 和中兴。</span><br><span class="line"></span><br><span class="line">　　自<span class="number">2017</span>年<span class="number">12</span>月启动以来，kata COntainers该社区成功地将Intel Clear Containers的最佳部分与Hyper.sh RunV合并，并进行了扩展，以包括对主要架构的支持，包括x86_64之外的AMD64，ARM，IBM p系列和IBM z系列。</span><br><span class="line"></span><br><span class="line">　　Kata Containers是一个开放源代码社区，致力于通过轻量级虚拟机来构建安全的容器运行时，这些虚拟机的感觉和性能类似于容器，但是使用硬件虚拟化技术作为第二防御层，可以提供更强的工作负载隔离。</span><br><span class="line">　　</span><br><span class="line">　　Kata Containers还支持多个虚拟机管理程序，包括QEMU，NEMU和Firecracker，并与其他容器化项目集成。</span><br><span class="line"></span><br><span class="line">　　Kata Containers社区由开放基础设施基金会管理，该基金会支持全球开放基础设施的开发和采用。该代码在Apache <span class="number">2</span>许可下托管在GitHub上。</span><br><span class="line"></span><br><span class="line">　　综上所述，Kata容器与容器一样轻便，快速，并与容器管理层集成在一起，包括流行的编排工具，如Docker和Kubernetes（k8s），同时还具有VM的安全优势。Kata Container具有以下几个优势：</span><br><span class="line">　　　　(<span class="number">1</span>)安全:</span><br><span class="line">　　　　　　在专用内核中运行，提供网络，I/O和内存的隔离，并可以通过虚拟化VT扩展利用硬件强制隔离。</span><br><span class="line">　　　　(<span class="number">2</span>)兼容性:</span><br><span class="line">　　　　　　支持行业标准，包括OCI容器格式，Kubernetes CRI接口以及旧版虚拟化技术。</span><br><span class="line">　　　　(<span class="number">3</span>)性能:</span><br><span class="line">　　　　　　提供与标准Linux容器一致的性能；提高隔离度，而无需增加标准虚拟机的性能。</span><br><span class="line">　　　　(<span class="number">4</span>)简单:</span><br><span class="line">　　　　　　消除了在完整的虚拟机内部嵌套容器的要求；标准接口使插入和入门变得容易。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　这一容器引擎其中一个特殊之处在于，它试图解决传统运维体验的问题，让容器可以像传统虚拟机一样操作。这其实就是VM与容器的结合，也正是Kata的用武之地。</span><br><span class="line">　　　　在之前，蚂蚁金服自研了一套技术来做到这点，而现在它们可以结合Kata的长处做到更好，同时又能保持和国内外主流技术保持同步。</span><br><span class="line">　　　　据InfoQ独家消息，技术创业公司音速神童创始人赵鹏王旭加入蚂蚁金服，打造虚拟机级别的安全容器技术。这也是为什么你所看到的pouch container是支持runV容器引擎的一个原因吧，因为runV研发团队核心成员已经入职阿里的蚂蚁金服!</span><br><span class="line">　　　　音速神童加入蚂蚁金服这件事在容器和云原生领域掀起新的波澜，它意味着云计算基础技术仍有可挖掘的的地方，而随着互联网大公司和云计算厂商的介入，未来的技术演进的竞争将更加激烈。</span><br><span class="line">　　</span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/kata-containers/</span>kata-containers</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/hyperhq/</span>runv</span><br><span class="line">　　　　https:<span class="regexp">//</span>katacontainers.io/</span><br><span class="line">　　　　https:<span class="regexp">//</span>katacontainers.io<span class="regexp">/learn/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>www.infoq.cn<span class="regexp">/article/</span>OI-CCUqPe82xKUwtVoA2</span><br><span class="line">　　　　https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/weixin_44326589/</span>article<span class="regexp">/details/</span><span class="number">103726445</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>www.kubernetes.org.cn<span class="regexp">/tags/</span>kubecon</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/D4650DCC5B7F45929D163F18DE88498D" alt="img"></p>
<h2 id="12-podman"><a href="#12-podman" class="headerlink" title="12.podman"></a>12.<strong>podman</strong></h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Podman是一个无守护进程的容器引擎，用于在Linux系统上开发，管理和运行OCI容器。容器可以以root用户或无根模式运行。简而言之：alias docker = podman。</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>年<span class="number">2</span>月，PodMan的v0.<span class="number">2</span>版本发布。Podman（POD管理器）是一种基于Apache-<span class="number">2.0</span> License开源工具，用于管理容器和镜像，安装在这些容器中的体积以及由容器组制成的容器。</span><br><span class="line"></span><br><span class="line">　　Podman基于libpod，libpod是一个用于容器生命周期管理的库，该库也包含在其中。libpod库提供用于管理容器，pod，容器映像和卷的API。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>podman.io/</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/containers/</span>podman</span><br></pre></td></tr></table></figure>



<h1 id="三-容器技术改变了传统部署应用程序的方式"><a href="#三-容器技术改变了传统部署应用程序的方式" class="headerlink" title="三.容器技术改变了传统部署应用程序的方式"></a>三.容器技术改变了传统部署应用程序的方式</h1><h2 id="1-容器和虚拟机之间的架构差异"><a href="#1-容器和虚拟机之间的架构差异" class="headerlink" title="1.容器和虚拟机之间的架构差异"></a>1.容器和虚拟机之间的架构差异</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">我们通常会说容器和虚拟化技术实现了一个互补，接下来我们来简单列举一下容器(Container)和虚拟机(<span class="keyword">virtual</span> machine)直接的差别。</span><br><span class="line">　　　　启动速度:</span><br><span class="line">　　　　　　Docker Container只需加载镜像文件，通常情况下是秒级(除非你的镜像不在本地，而是在公网上，这需要一个下载镜像的过程)。</span><br><span class="line">　　　　　　而<span class="keyword">virtual</span> machine需要启动宿主机,速度较慢。</span><br><span class="line">　　　　运行性能:</span><br><span class="line">　　　　　　接近原生物理系统，因为Docker Container和原生操作系统使用的是同一个kernel。</span><br><span class="line">　　　　　　而<span class="keyword">virtual</span> machine使用的宿主机的虚拟kernel，这意味着需要将虚拟kernel的指令经过编译，翻译成机器码交由物理kernel取执行。因此会多占用一些资源。</span><br><span class="line">　　　　镜像体积:</span><br><span class="line">　　　　　　Docker Container镜像基本上都是MB级别。</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine就需要ISO镜像来安装，官方有<span class="number">900</span>MB+(Minimal的ISO镜像),<span class="number">4</span>GB+(DVD的ISO镜像)，<span class="number">10</span>GB+(Everything的ISO镜像)等等。</span><br><span class="line">　　　　可管理性:</span><br><span class="line">　　　　　　Docker Container单进程(即进程级隔离)</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine是虚拟完整的系统管理(即系统级隔离，相对来隔离更彻底)</span><br><span class="line">　　　　资源利用率:</span><br><span class="line">　　　　　　一台物理机可以运行数百个容器Docker Container，但是一般只能运行数十多个<span class="keyword">virtual</span> machine。</span><br><span class="line">　　　　封装程度:</span><br><span class="line">　　　　　　Docker Container只打包项目代码及其运行环境所依赖的关系</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine虚拟完整的操作系统。</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/2E4759DCA4A144A4A307115113C633D2" alt="img"></p>
<h2 id="2-容器改变了部署方式"><a href="#2-容器改变了部署方式" class="headerlink" title="2.容器改变了部署方式"></a>2.容器改变了部署方式</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">传统部署时代： </span><br><span class="line">　　　　早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。</span><br><span class="line">　　　　例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果，另一个应用程序的性能将下降。</span><br><span class="line">　　　　解决方案是在不同的物理服务器上运行每个应用程序。但是，这并没有随着资源利用不足而扩展，并且组织维护许多物理服务器的成本很高。</span><br><span class="line"></span><br><span class="line">　　虚拟化部署时代：</span><br><span class="line">　　　　作为解决方案，引入了虚拟化。</span><br><span class="line">　　　　它允许您在单个物理服务器的CPU上运行多个虚拟机（VM）。虚拟化允许在VM之间隔离应用程序，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由访问。</span><br><span class="line">　　　　虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性，因为可以轻松地添加或更新应用程序，降低硬件成本等等。借助虚拟化，您可以将一组物理资源呈现为一组一次性虚拟机。</span><br><span class="line">　　　　每个VM都是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</span><br><span class="line"></span><br><span class="line">　　容器部署时代：</span><br><span class="line">　　　　容器类似于VM，但是它们具有轻松的隔离属性，可以在应用程序之间共享操作系统（OS）。因此，容器被认为是轻质的。</span><br><span class="line">　　　　与VM相似，容器具有自己的文件系统，CPU，内存，进程空间等的共享。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</span><br><span class="line"></span><br><span class="line">　　参考连接:</span><br><span class="line">　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/docs/</span>concepts<span class="regexp">/overview/</span>what-is-kubernetes/</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/551FA84F4E074D1B8DD63780D89360EF" alt="img"></p>
<h1 id="四-chroot工具使用（了解即可）"><a href="#四-chroot工具使用（了解即可）" class="headerlink" title="四.chroot工具使用（了解即可）"></a>四.chroot工具使用（了解即可）</h1><h2 id="1-chroot概述"><a href="#1-chroot概述" class="headerlink" title="1.chroot概述"></a>1.chroot概述</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chroot</span>(全称为:<span class="string">&quot;change root directory&quot;</span>)命令用来在指定的根目录下运行指令。在linux系统中，系统默认的目录结构都是以/，即是以根(root)开始的。而在使用<span class="keyword">chroot</span>之后，系统的目录结构将以指定的位置作为/位置。</span><br><span class="line"></span><br><span class="line">其实<span class="keyword">chroot</span>的概念我们并不是第一次接触了，还记得我们讲解的kafka在zookeeper的元数据znode位置吗？我们也为其指定了根znode哟~</span><br><span class="line"></span><br><span class="line">在经过<span class="keyword">chroot</span>之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下<span class="number">3</span>个：</span><br><span class="line">	(<span class="number">1</span>)增加了系统的安全性，限制了用户的权力；</span><br><span class="line">		在经过<span class="keyword">chroot</span>之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。</span><br><span class="line">		这个一般是在登录(login)前使用<span class="keyword">chroot</span>，以此达到用户不能访问一些特定的文件。</span><br><span class="line"></span><br><span class="line">	(<span class="number">2</span>)建立一个与原系统隔离的系统目录结构，方便用户的开发；</span><br><span class="line">		使用<span class="keyword">chroot</span>后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。</span><br><span class="line">		在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</span><br><span class="line"></span><br><span class="line">	(<span class="number">3</span>)切换系统的根目录位置，引导Linux系统启动以及急救系统等。</span><br><span class="line">		<span class="keyword">chroot</span>的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始RAM磁盘 (initrd) 切换系统的根位置并执行真正的init。</span><br><span class="line">		另外，当系统出现一些问题时，我们也可以使用<span class="keyword">chroot</span>来切换到一个临时的系统。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-centos测试"><a href="#2-centos测试" class="headerlink" title="2.centos测试"></a>2.centos测试</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># mkdir -pv oldboyedu/linux </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta">#</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># scp -r /usr/&#123;bin,lib64&#125; oldboyedu/linux/</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/DBAA973F58584CE691A19000F3178114" alt="img"></p>
<h2 id="3-ubuntu测试"><a href="#3-ubuntu测试" class="headerlink" title="3.ubuntu测试"></a>3.ubuntu测试</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv oldboyedu<span class="regexp">/linux/</span>&#123;bin,lib,lib64&#125;</span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/bin/</span>bash oldboyedu<span class="regexp">/linux/</span>bin/</span><br><span class="line"> </span><br><span class="line">cp <span class="regexp">/lib/</span>x86_64-linux-gnu<span class="regexp">/&#123;libtinfo.so.5,libdl.so.2,libc.so.6&#125; oldboyedu/</span>linux/lib</span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/lib/</span>x86_64-linux-gnu<span class="regexp">/ld-linux-x86-64.so.2 oldboyedu/</span>linux<span class="regexp">/lib64/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/67B91A6715A94E24A5E936B0FCAED97B" alt="image-20210629232129052"></p>
<h2 id="4-创建文件"><a href="#4-创建文件" class="headerlink" title="4.创建文件"></a>4.创建文件</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">bash</span>-<span class="number">4</span>.<span class="number">2</span># echo <span class="string">&quot;oldboyedu linux 2021&quot;</span> &gt; /oldboyedu.log </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/E224146AF87A45F8841A40708B23B2B1" alt="image-20210629232454393"></p>
<h2 id="5-chroot的局限性"><a href="#5-chroot的局限性" class="headerlink" title="5.chroot的局限性"></a>5.chroot的局限性</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从<span class="keyword">chroot</span>的用法可以看出它的使用场景有一定的局限性，首先它依赖于一台现成的unix系统（根目录必须存在于某台现有系统上）。</span><br><span class="line"></span><br><span class="line">其次<span class="keyword">chroot</span>仅仅是在系统目录上进行了隔离，并没有对进程、环境变量，网络等层面进行隔离。因此我们说<span class="keyword">chroot</span>并不能完全保证系统安全。</span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">	(<span class="number">1</span>)如下图所示，演示了进程和环境变量并没有实现隔离；</span><br><span class="line">	(<span class="number">2</span>)此处的<span class="keyword">chroot</span>中无法使用ping命令或者ifconfig相关的命令，否则就可以进一步验证网络也没有隔离哟~</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/D467971654AB406093C01D555654D41F" alt="image-20210629232909485"></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/715783B7E3584337B5A4CF0A2AC4D7A9" alt="image-20210629233508001"></p>
<h1 id="五-LXC容器管理工具使用（了解即可）"><a href="#五-LXC容器管理工具使用（了解即可）" class="headerlink" title="五.LXC容器管理工具使用（了解即可）"></a>五.LXC容器管理工具使用（了解即可）</h1><h2 id="1-centos按照lxc，lxd-比较麻烦"><a href="#1-centos按照lxc，lxd-比较麻烦" class="headerlink" title="1.centos按照lxc，lxd(比较麻烦)"></a>1.centos按照lxc，lxd(比较麻烦)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># yum -y install lxc lxd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>bbs.huaweicloud.com<span class="regexp">/blogs/</span><span class="number">150538</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	lxc:</span><br><span class="line">		客户端。</span><br><span class="line">	lxd:</span><br><span class="line">		服务端。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="2-ubuntu安装lxc，lxd"><a href="#2-ubuntu安装lxc，lxd" class="headerlink" title="2.ubuntu安装lxc，lxd"></a>2.ubuntu安装lxc，lxd</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> -y install lxc lxd</span><br><span class="line"></span><br><span class="line"><span class="symbol">lxd:</span></span><br><span class="line">	服务端。</span><br><span class="line">	</span><br><span class="line"><span class="symbol">lxc:</span></span><br><span class="line">	客户端</span><br></pre></td></tr></table></figure>





<h2 id="3-检查内核对lxc的支持情况"><a href="#3-检查内核对lxc的支持情况" class="headerlink" title="3.检查内核对lxc的支持情况"></a>3.检查内核对lxc的支持情况</h2><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># lxc-checkconfig </span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/CDBF782AD81F4AB9AC010A2BDB74F7BF" alt="image-20210629234317680"></p>
<h2 id="4-下载镜像"><a href="#4-下载镜像" class="headerlink" title="4.下载镜像"></a>4.下载镜像</h2><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">lxc</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="comment">t</span> <span class="comment">download</span> --<span class="comment">name</span> <span class="comment">my_alpine2021</span> -- --<span class="comment">dist</span> <span class="comment">alpine</span> --<span class="comment">release</span> <span class="comment">lates</span></span><br><span class="line"><span class="comment">t</span> --<span class="comment">arch</span> <span class="comment">adm64</span> --<span class="comment">keyserver</span> <span class="comment">hkp://keyserver</span><span class="string">.</span><span class="comment">ubuntu</span><span class="string">.</span><span class="comment">com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">相关参数说明:</span></span><br><span class="line"><span class="comment">	</span><span class="literal">-</span><span class="comment">t:</span></span><br><span class="line"><span class="comment">　　　　指定模板名称，我们这里指定download模板，就会调用&quot;/usr/share/lxc/templates/lxc</span><span class="literal">-</span><span class="comment">download&quot;脚本，该脚本说明我们目前没有自己的模板，需要下载官方的模板。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">name:</span></span><br><span class="line"><span class="comment">　　　　指定容器名称，即为创建的容器命名。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">:</span></span><br><span class="line"><span class="comment">　　　　用来说明后面的参数是传递给download脚本的，告诉脚本需要下载什么养的模板。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">dist:</span></span><br><span class="line"><span class="comment">　　　　操作系统名称，即指定操作系统。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">release:</span></span><br><span class="line"><span class="comment">　　　　指定操作系统的发行版本。可以是各种Linux的变种。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">arch:</span></span><br><span class="line"><span class="comment">　　　　指定CPU架构，是x86还是arm，是32位还是64位。　</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-管理lxc容器命令"><a href="#5-管理lxc容器命令" class="headerlink" title="5.管理lxc容器命令"></a>5.管理lxc容器命令</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lxc-start my_alpi<span class="symbol">ne2021</span>:</span><br><span class="line"> 	启动lxc容器。</span><br><span class="line"> 	</span><br><span class="line">lxc-attach my_alpi<span class="symbol">ne2021</span>:</span><br><span class="line">	进入lxc容器。</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-lxc启动容器依赖于模板"><a href="#6-lxc启动容器依赖于模板" class="headerlink" title="6.lxc启动容器依赖于模板"></a>6.lxc启动容器依赖于模板</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　lxc启动容器依赖于模板，清华模板源：</span><br><span class="line">　　　　https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/help/</span>lxc-images/</span><br><span class="line"></span><br><span class="line">　　但是做模板相对较难，需要手动一步步构建文件系统，准备基础目录及可执行程序等，而且在大规模使用容器的场景很难横向扩展，另外后期代码升级也需要重新从头构建模板，基于以上种种原因便有了docker容器管理工具。</span><br></pre></td></tr></table></figure>





<h1 id="六-可能会遇到的报错"><a href="#六-可能会遇到的报错" class="headerlink" title="六.可能会遇到的报错"></a>六.可能会遇到的报错</h1><h2 id="1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory"><a href="#1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory" class="headerlink" title="1.chroot: failed to run command ‘/bin/bash’: No such file or directory"></a>1.chroot: failed to run command ‘/bin/bash’: No such file or directory</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">报错原因:</span><br><span class="line">	指定的chroot目录中没有‘<span class="regexp">/bin/</span>bash’文件。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">	如下图所示，拷贝‘<span class="regexp">/bin/</span>bash’文件到指定的目录结构并将其依赖的库文件也要拷贝过去。此处我为了偷懒，就没进行拷贝。</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/D871C9EE3C7948C8BEBF81A30E53DCD8" alt="image-20210629230138235"></p>
<h2 id="2-ERROR-Unable-to-fetch-GPG-key-from-keyserver"><a href="#2-ERROR-Unable-to-fetch-GPG-key-from-keyserver" class="headerlink" title="2.ERROR: Unable to fetch GPG key from keyserver"></a>2.ERROR: Unable to fetch GPG key from keyserver</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">故障原因:</span><br><span class="line">	无法从密钥服务器获取GPG密钥。</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	方案一:</span><br><span class="line">		vim ~<span class="string">/.bashrc</span></span><br><span class="line">		export DOWNLOAD_KEYSERVER=<span class="string">&quot;keyserver.ubuntu.com&quot;</span></span><br><span class="line">		</span><br><span class="line">	方案二:</span><br><span class="line">		DOWNLOAD_KEYSERVER=<span class="string">&quot;keyserver.ubuntu.com&quot;</span> lxc-create -t download <span class="string">...</span></span><br><span class="line">	</span><br><span class="line">	方案三:</span><br><span class="line">		lxc-create -t download <span class="string">...</span> <span class="params">--keyserver</span> hkp:<span class="string">//keyserver.ubuntu.com</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>MING
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2021/08/16/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/" title="Linux容器（Container）发展史">http://example.com/2021/08/16/Linux容器(Container)发展史/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker -</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/16/docker%E9%95%9C%E5%83%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/" rel="prev" title="docker镜像常用命令">
      <i class="fa fa-chevron-left"></i> docker镜像常用命令
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E5%AE%B9%E5%99%A8-Container-%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">一.容器(Container)技术概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8-Container"><span class="nav-number">1.1.</span> <span class="nav-text">1.什么是容器(Container)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">2.为什么要用容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">二.常见的容器管理技术概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Unix-chroot"><span class="nav-number">2.1.</span> <span class="nav-text">1.Unix chroot</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Unix-FreeBSD-jail"><span class="nav-number">2.2.</span> <span class="nav-text">2.Unix FreeBSD jail</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Linux-VServer"><span class="nav-number">2.3.</span> <span class="nav-text">3.Linux-VServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Oracle-Solaris-Container-Sun%E5%85%AC%E5%8F%B8%E7%9A%84Solaris%E4%B8%8EFreeBSD%EF%BC%8CMac%E7%B3%BB%E7%BB%9F%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%9D%87%E6%98%AFUnix%E6%89%A9%E5%B1%95%E7%89%88-%E5%8D%B3BSD-%E7%9A%84%E5%8F%91%E8%A1%8C%E7%89%88"><span class="nav-number">2.4.</span> <span class="nav-text">4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Parallels-Virtuozzo-OpenVZ"><span class="nav-number">2.5.</span> <span class="nav-text">5.Parallels Virtuozzo&#x2F;OpenVZ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Linux-Kernel%E6%94%AF%E6%8C%81Cgroup-%E6%8E%A7%E5%88%B6%E7%BB%84-%E5%92%8CNameSpace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-%E6%8A%80%E6%9C%AF"><span class="nav-number">2.6.</span> <span class="nav-text">6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-LXC-LXD"><span class="nav-number">2.7.</span> <span class="nav-text">7.LXC&#x2F;LXD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-Docker"><span class="nav-number">2.8.</span> <span class="nav-text">8.Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-RedHat-%E5%B7%B2%E8%A2%ABIBM%E6%94%B6%E8%B4%AD-%E7%9A%84CoreOS-rkt%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">2.9.</span> <span class="nav-text">9.RedHat(已被IBM收购)的CoreOS rkt容器技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E7%9A%84Pouch%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">2.10.</span> <span class="nav-text">10.阿里开源的Pouch容器技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E9%9F%B3%E9%80%9F%E7%A5%9E%E7%AB%A5kata-containers"><span class="nav-number">2.11.</span> <span class="nav-text">11.音速神童kata-containers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-podman"><span class="nav-number">2.12.</span> <span class="nav-text">12.podman</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%94%B9%E5%8F%98%E4%BA%86%E4%BC%A0%E7%BB%9F%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">三.容器技术改变了传统部署应用程序的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9E%B6%E6%9E%84%E5%B7%AE%E5%BC%82"><span class="nav-number">3.1.</span> <span class="nav-text">1.容器和虚拟机之间的架构差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%B9%E5%99%A8%E6%94%B9%E5%8F%98%E4%BA%86%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">2.容器改变了部署方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-chroot%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">四.chroot工具使用（了解即可）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-chroot%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">1.chroot概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-centos%E6%B5%8B%E8%AF%95"><span class="nav-number">4.2.</span> <span class="nav-text">2.centos测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-ubuntu%E6%B5%8B%E8%AF%95"><span class="nav-number">4.3.</span> <span class="nav-text">3.ubuntu测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="nav-number">4.4.</span> <span class="nav-text">4.创建文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-chroot%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">4.5.</span> <span class="nav-text">5.chroot的局限性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-LXC%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">五.LXC容器管理工具使用（了解即可）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-centos%E6%8C%89%E7%85%A7lxc%EF%BC%8Clxd-%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6"><span class="nav-number">5.1.</span> <span class="nav-text">1.centos按照lxc，lxd(比较麻烦)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ubuntu%E5%AE%89%E8%A3%85lxc%EF%BC%8Clxd"><span class="nav-number">5.2.</span> <span class="nav-text">2.ubuntu安装lxc，lxd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%A3%80%E6%9F%A5%E5%86%85%E6%A0%B8%E5%AF%B9lxc%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5"><span class="nav-number">5.3.</span> <span class="nav-text">3.检查内核对lxc的支持情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="nav-number">5.4.</span> <span class="nav-text">4.下载镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%AE%A1%E7%90%86lxc%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">5.5.</span> <span class="nav-text">5.管理lxc容器命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-lxc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%A8%A1%E6%9D%BF"><span class="nav-number">5.6.</span> <span class="nav-text">6.lxc启动容器依赖于模板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E6%8A%A5%E9%94%99"><span class="nav-number">6.</span> <span class="nav-text">六.可能会遇到的报错</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-chroot-failed-to-run-command-%E2%80%98-bin-bash%E2%80%99-No-such-file-or-directory"><span class="nav-number">6.1.</span> <span class="nav-text">1.chroot: failed to run command ‘&#x2F;bin&#x2F;bash’: No such file or directory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ERROR-Unable-to-fetch-GPG-key-from-keyserver"><span class="nav-number">6.2.</span> <span class="nav-text">2.ERROR: Unable to fetch GPG key from keyserver</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MING"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">MING</p>
  <div class="site-description" itemprop="description">Son of the morning star</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=491294233&auto=1&height=66"></iframe>
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1844449888&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MING</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
