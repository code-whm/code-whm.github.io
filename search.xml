<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash概述</title>
    <url>/2021/07/28/Bash%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.Bash Shell初步认识 2.Bash Shell基本特性 3.Bash Shell获取帮助 4.Bash Shell命令流程</p>
<span id="more"></span>
<h1 id="1-Bash-Shell初步认识"><a href="#1-Bash-Shell初步认识" class="headerlink" title="1.Bash Shell初步认识"></a>1.Bash Shell初步认识</h1><h2 id="1-什么是Bash-shell-壳"><a href="#1-什么是Bash-shell-壳" class="headerlink" title="1.什么是Bash shell(壳)"></a>1.什么是Bash shell(壳)</h2><p><em>Bash Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。</em></p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210727093855.png" alt="imageTitle"></p>
<p><em>当我们使用远程连接工具连接linux服务，系统则会给打开一个默认的shell，我们可在这个界面执行命令、比如：获取系统当前时间，创建一个用户等等….</em></p>
<h2 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么"></a>2.Bash Shell能干什么</h2><p><em>使用Shell实现对Linux系统的大部分管理，例如:<br> 1.文件管理<br> 2.权限管理<br> 3.用户管理<br> 4.磁盘管理<br> 5.网络管理<br> 6.软件管理<br> .等等.</em></p>
<h2 id="3-平时我们如何使用Shell？"><a href="#3-平时我们如何使用Shell？" class="headerlink" title="3.平时我们如何使用Shell？"></a>3.平时我们如何使用Shell？</h2><p><em>输入命令 –&gt; 效率低 –&gt; 适合少量的工作</em></p>
<p><em>Shell Script(脚本) –&gt; 效率高 –&gt; 适合复杂的重复性高的工作</em></p>
<p><em>例如:创建100个用户，单纯输入命令需要执行100次，而Shell脚本只需要几行命令即可完成100个用户的创建</em></p>
<h2 id="4-Shell提示符"><a href="#4-Shell提示符" class="headerlink" title="4.Shell提示符"></a>4.Shell提示符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ = 普通用户, # = root用户(超级管理员)</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">[root@web01 ~]<span class="comment"># useradd jack</span></span><br><span class="line">[root@web01 ~]<span class="comment"># passwd jack</span></span><br><span class="line">Changing password <span class="keyword">for</span> user jack.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is a palindrome</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-Shell基础语法"><a href="#5-Shell基础语法" class="headerlink" title="5.Shell基础语法"></a>5.Shell基础语法</h2><p><em>命令行bash shell，为用户提供输入，执行命令的界面</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令  选项  参数</span></span><br><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令: 整条shell命令的主体</span></span><br><span class="line"><span class="comment">#选项: 用于调节命令的具体功能</span></span><br><span class="line">    <span class="comment">#以 “-”引导短格式选项（单个字符），例如“-l”</span></span><br><span class="line">    <span class="comment">#以“--”引导长格式选项（多个字符），例如“--color”</span></span><br><span class="line">    <span class="comment">#多个短格式选项可以写在一起，只用一个“-”引导，例如“-al”</span></span><br><span class="line"><span class="comment">#参数: 命令操作的对象，如文件、目录名等</span></span><br><span class="line"><span class="comment"># 命令必须开头， 选项和参数位置可以发生变化</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Bash-Shell基本特性"><a href="#2-Bash-Shell基本特性" class="headerlink" title="2.Bash Shell基本特性"></a>2.Bash Shell基本特性</h1><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a><em>1.命令补全</em></h3><p><em>当时用windows查找一个目录层级特别多的文件时，打开的效率会非常慢，但如果使用linux查找一个目录层级特别多的文件时，可以通过tab键快速的补全</em></p>
<p><em>PS:tab键可以实现命令补全，路径补全，在实际生产中tab补全往往是我们使用的最多的, 因为可以减少执行命令以及路径出错率.</em></p>
<h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a><em>2.命令快捷键</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+a <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">ctrl+e <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">ctrl+c <span class="comment">#终止前台运行的程序</span></span><br><span class="line">ctrl+d <span class="comment">#在shell中，ctrl+d表示退出当前shell</span></span><br><span class="line">ctrl+z <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">ctrl+l <span class="comment">#清屏，和clear命令等效</span></span><br><span class="line">ctrl+k <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">ctrl+u <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">ctrl+r <span class="comment">#搜索历史命令，利用关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在命令行前加面加 &quot;#&quot; 则该命令不会被执行，一般用作注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-历史命令history"><a href="#3-历史命令history" class="headerlink" title="3.历史命令history"></a><em>3.历史命令history</em></h3><p><em>-w 保存命令历史到历史文件<br> -c 清空命令历史记录, 不会情况文件<br> -d 删除命令历史的第 N 条行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用双 !! 可执行上一条执行过的命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls</span></span><br><span class="line">lucifer.com</span><br><span class="line">[root@lucifer ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.输入!6, 执行history命令历史中第 6 行命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !6</span></span><br><span class="line">touch lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用!cat, 调用history命令历史最近一次执行过的cat命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line"><span class="comment">#调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 &quot;.&quot;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"><span class="comment">#第二种方式, 输入!$</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="4-历史别名"><a href="#4-历史别名" class="headerlink" title="4.历史别名"></a><em>4.历史别名</em></h3><p><em>命令别名将用户经常使用的复杂命令简单化, 可以用<code>&quot;alias 别名名称=命令&quot;</code>命令创建属于自己的命令别名, 若要取消一个命令别名，则是用<code>unalias 别名名称</code>命令。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.定义临时别名, wk为查看eth0网卡别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias wk=&#x27;ifconfig&#x27;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># wk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.如果定义命令本身, 会执行什么?</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias ifconfig=&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">    <span class="comment">#绝对路径执行, 调用命令本身</span></span><br><span class="line">    [root@lucifer ~]<span class="comment"># /sbin/ifconfig</span></span><br><span class="line">    <span class="comment">#通过\转义字符, 调用命令本身</span></span><br><span class="line">    [root@WebServer ~]<span class="comment"># \ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.取消别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># unalias ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.永久生效，/etc/bashrc</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;alias ifconfig=&#x27;ifconfig eth0&#x27;&quot; &gt;&gt; /etc/bashrc</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Bash-Shell获取帮助"><a href="#3-Bash-Shell获取帮助" class="headerlink" title="3.Bash Shell获取帮助"></a>3.Bash Shell获取帮助</h1><h3 id="1-命令-–help帮助"><a href="#1-命令-–help帮助" class="headerlink" title="1.命令 –help帮助"></a><em>1.命令 –help帮助</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@lucifer ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@lucifer ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@web01 ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@web01 ~]<span class="comment"># ls</span></span><br><span class="line">2019-03-28_file.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-命令man手册"><a href="#2-命令man手册" class="headerlink" title="2.命令man手册"></a><em>2.命令man手册</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#man ls #查看ls命令手册</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Linux命令大全传送门"><a href="#3-Linux命令大全传送门" class="headerlink" title="3.Linux命令大全传送门"></a><em>3.Linux命令大全传送门</em></h3><p><em>linux命令大全： <a href="https://man.linuxde.net/">https://man.linuxde.net/</a></em></p>
<p><em>linux命令手册：<a href="http://linux.51yip.com/">http://linux.51yip.com/</a></em></p>
<h1 id="4-Bash-Shell命令流程"><a href="#4-Bash-Shell命令流程" class="headerlink" title="4.Bash Shell命令流程"></a>4.Bash Shell命令流程</h1><h3 id="1-当我们执行一个命令-整个命令执行流程如下"><a href="#1-当我们执行一个命令-整个命令执行流程如下" class="headerlink" title="*1.当我们执行一个命令, 整个命令执行流程如下:"></a>*1.当我们执行一个命令, 整个命令执行流程如下:</h3><ol>
<li>判断命令是否通过绝对路径执行</li>
<li>判断命令是否存在alias别名</li>
<li>判断用户输入的是内部命令还是外部命令</li>
<li>Bash内部命令直接执行，外部命令检测是否存在缓存</li>
<li>通过PATH路径查找命令，有执行，无报错*</li>
</ol>
<h3 id="2-什么是内部命令，什么是外部命令"><a href="#2-什么是内部命令，什么是外部命令" class="headerlink" title="2.什么是内部命令，什么是外部命令"></a><em>2.什么是内部命令，什么是外部命令</em></h3><p> <em>内部命令: shell程序自带的命令。<br> 外部命令: 在系统PATH变量的某个路径下的可执行程序。</em></p>
<h3 id="3-如何检查用户输入的命令是内部命令还是外部命令"><a href="#3-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="3.如何检查用户输入的命令是内部命令还是外部命令"></a><em>3.如何检查用户输入的命令是内部命令还是外部命令</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line">[root@linux-node1 ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br></pre></td></tr></table></figure>

<p><em>4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p><em>PS: PATH由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找</em></p>
<p><em>5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意: 命令缓存hash需要注意如下情况:</span></span><br><span class="line">1.只要执行外部命令1次就会对该命令进行缓存</span><br><span class="line">2.如果将命令移动了位置，该如何执行</span><br><span class="line">    a.使用绝对路径执行</span><br><span class="line">    b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<h3 id="命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下"><a href="#命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下" class="headerlink" title="命令执行流程总结: 当我们执行了一个ping命令之后, 整个命令执行的流程步骤如下:"></a><em>命令执行流程总结: 当我们执行了一个<code>ping</code>命令之后, 整个命令执行的流程步骤如下:</em></h3><p><em>1) 检查执行的命令是否使用的是绝对路径执行的。<br> 2) 检查ping命令是否存在alias别名<br> 3) 检查ping命令是内部命令还是外部命令<br> 4) 如果是内部命令Bash直接执行，如果是外部命令，首先检查Hash缓存，存在则直接调取<br> 5) 如果该命令不存在Hash缓存，则通过PATH路径进行逐行查找该命令所在的位置<br> 6) 如果PATH路径没有查找到该命令所在的路径，则返回错误码。command not found</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>Bash -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/2021/07/28/Linuxuser/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.用户基本概述 2.用户相关命令 3.用户扩展知识 3.用户组的管理 4.用户如何提权</p>
<span id="more"></span>
<h1 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h1><p><em><strong>1.什么是用户?</strong></em></p>
<p><em>用户指的是能够正常登录Linux或Windows系统(可以理解为你租了房子，能够正常入驻)<br>F:那Linux与Windows系统的用户有什么区别? Q:本质都是登陆系统，只不过Linux支持多个用户同时登陆。<br>F:难道Windows就不算多用户操作系统吗? Q:其实不是，在Windows系统中可以创建多个用户，但不允许同一时刻多个用户登陆系统，但Linux系统则允许同一时刻多个用户同时登陆，登陆后相互之间操作并不影响。</em></p>
<p><em><strong>2.Linux下的用户有什么用，或者说我们为什么要创建用户？</strong></em></p>
<p><em>1.系统上的每一个进程(运行的程序)，都需要一个特定的用户运行<br>2.通常在公司是使用普通用户管理服务器，因为root权限过大，容易造成故障。</em></p>
<p><em><strong>3.如何查看系统中所存在的用户</strong></em></p>
<p><em>1.查看当前登录的用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@bgx ~]<span class="comment"># id oldboy #查看其它用户的信息</span></span><br><span class="line">uid=1000(oldboy) gid=1000(oldboy) groups=1000(oldboy)</span><br></pre></td></tr></table></figure>

<p><em>2.每一个进程都会由一个用户身份运行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ps aux|less #简单使用一下，不用理解</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure>

<p><em><strong>4.那我们的用户存在哪呢?</strong></em></p>
<p><em>Linux系统会将用户的信息存放在/etc/passwd，记录了用户的信息，但没有密码信息，密码被存放在/etc/shadow中。也就是说这两个文件非常的重要，不要轻易删除与修改。</em></p>
<p><em>1./etc/passwd 配置文件解释如下图，或者man 5 passwd</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/shadow 配置文件解释如下图，或者man 5 shadow</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728213756.png" alt="imageTitle"></p>
<p><em><strong>4.最后我们需要了解下系统对用户的一个约定？(约定娶你，就真的会娶吗？)</strong></em></p>
<table>
<thead>
<tr>
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>超级管理员，最高权限，有着极强的破坏能力</td>
</tr>
<tr>
<td>1~200</td>
<td>系统用户，用来运行系统自带的进程，默认已创建</td>
</tr>
<tr>
<td>201~999</td>
<td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td>
</tr>
<tr>
<td>1000+</td>
<td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td>
</tr>
</tbody></table>
<p><em>PS:在CentOS7系统之前, UID1-499用于系统用户, 而UID 500+则用于普通用户</em></p>
<h1 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h1><p><em>下面我们就围绕着用户的创建、变更、删除等来讲讲涉及到的命令: useradd、usermod、userdel</em></p>
<p><em>1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要创建用户的UID,不允许冲突</span></span><br><span class="line"><span class="comment"># -g 指定要创建用户默认组</span></span><br><span class="line"><span class="comment"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span></span><br><span class="line"><span class="comment"># -d 指定要创建用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要创建用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要创建用户注释信息</span></span><br><span class="line"><span class="comment"># -M 给创建的用户不创建家目录</span></span><br><span class="line"><span class="comment"># -r 创建系统账户，默认无家目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建bgx用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure>

<p><em>2.如何使用usermod命令修改用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要修改用户的UID</span></span><br><span class="line"><span class="comment"># -g 指定要修改用户基本组</span></span><br><span class="line"><span class="comment"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></span><br><span class="line"><span class="comment"># -d 指定要修改用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要修改用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要修改用户注释信息</span></span><br><span class="line"><span class="comment"># -l 指定要修改用户的登陆名</span></span><br><span class="line"><span class="comment"># -L 指定要锁定的用户</span></span><br><span class="line"><span class="comment"># -U 指定要解锁的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.检查此前创建的用户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx:x:5001:503:2019 new student:/home/bgx:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.修改bgx用户uid、gid，附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改bgx用户的注释信息, 用户家目录, 登录shell, 登录名</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /bgx -s /bin/sh -l change_bgx bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否修改成功</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx_xuliangwei:x:6001:5008:2019 new student:/bgx:/bin/sh</span><br><span class="line">[root@bgx ~]<span class="comment"># id change_bgx</span></span><br><span class="line">uid=6001(change_bgx) gid=5008(network_sa) groups=5008(network_sa),503(sa),5009(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /bgx</span></span><br><span class="line">drwx------. 2 bgx_xuliangwei network_sa 4096 2014-09-23 00:13 /bgx</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.锁定用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin change_bgx</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -L change_bgx  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解锁用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -U change_bgx</span></span><br></pre></td></tr></table></figure>

<p>*S: 当然还有很多命令可以查看用户的信息，以下简单列举一些，但都是我们常用，所以了解即可</p>
<ol>
<li>使用finger命名查询用户信息以及登录信息，示例: finger UserName</li>
<li>使用chfn命令修改用户信息，示例: chfn UserName</li>
<li>使用chsh命令修改用户登录Bash Shell，示例: chsh UserName</li>
<li>使用who、whoami、w检查用户登陆情况*</li>
</ol>
<p><em>3.使用userdel命令删除账户</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项 -r 删除用户同时删除它的家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.删除user1用户，但不删除用户家目录和 mail spool</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.-r参数可以连同用户家目录一起删除(慎用)</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure>

<h1 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h1><p><em><strong>1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？</strong></em></p>
<p><em>1.useradd创建用户时，系统会以/etc/login.defs、/etc/defaults/useradd两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖/etc/login.defs、/etc/defaults/useradd文件默认配置，如未指定则使用默认。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@bgx ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      <span class="comment">#把用户的家目录建在/home中。</span></span><br><span class="line">INACTIVE=-1     <span class="comment">#是否启用账号过期停权,-1表示不启用。</span></span><br><span class="line">EXPIRE=         <span class="comment">#账号终止日期,不设置表示不启用。</span></span><br><span class="line">SHELL=/bin/bash <span class="comment">#新用户默认所有的shell类型。</span></span><br><span class="line">SKEL=/etc/skel  <span class="comment">#配置新用户家目录的默认文件存放路径。</span></span><br><span class="line">CREATE_MAIL_SPOOL=yes   <span class="comment">#创建mail文件。</span></span><br></pre></td></tr></table></figure>

<p><em>2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<p><em>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用passwd命令。建议密码复杂度高一些、长度大于10、出现各种特殊字符、无任何规律(不要出现名字，电话，生日等)<br> PS: 注意事项<br> 1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须8位字符<br> 2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用passwd命令修改用户密码</span></span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd oldboy #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.验证如下几项指标</span></span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd Lucifer        #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin xuliangwei    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.系统内置变量生成随机字符串</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@bgx ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span></span><br><span class="line">[root@bgx ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure>

<p><em>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件<a href="https://www.lastpass.com/zh">Lastpass官方网站</a></em></p>
<h1 id="3-用户组的管理"><a href="#3-用户组的管理" class="headerlink" title="3.用户组的管理"></a>3.用户组的管理</h1><p><em><strong>1.什么是用户组？</strong></em></p>
<p><em>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</em></p>
<p><em><strong>2.对于用户来说，组有几种类别？</strong></em></p>
<p><em>基本组，用户只能有一个基本组，创建时可通过-g指定，如未指定则创建一个默认的组(与用户同名)</em></p>
<p><em>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组</em></p>
<p><em><strong>3.那组的信息保存在哪呢？</strong></em></p>
<p><em>组账户信息保存在/etc/group和/etc/gshadow两个文件中。重点关注group</em></p>
<p><em>1./etc/group 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/gshadow 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728211204.png" alt="imageTitle"><br><em>1.使用groupadd命令新增组，groupadd [-g GID] groupname</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建基本组, 不指定gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建基本组, 指定gid为5555</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建系统组，gid从201-999</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure>

<p><em>2.使用groupmod命令新增组</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-g 修改组gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line"><span class="comment">#-n 修改组名称</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure>

<p><em>3.groupdel删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除用户附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无法删除用户基本组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line"><span class="comment">#只有删除用户或者用户变更基本后,方可删除该组</span></span><br></pre></td></tr></table></figure>

<p><em>4.使用gpasswd设置组密码[扩展，可以不会]</em></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># groupadd devops</span></span><br><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> <span class="keyword">group</span> devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter <span class="keyword">new</span> password:</span><br></pre></td></tr></table></figure>

<p><em>5.使用newgrp命令切换基本组身份[扩展，可以不会]</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.检查账户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd xuliangwei</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建新文件,查看文件的属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_roots</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用newgrp切换到devops组</span></span><br><span class="line">[xuliangwei@bgx ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.创建文件，检查属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_test</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 xuliangwei devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure>

<h1 id="4-用户如何提权"><a href="#4-用户如何提权" class="headerlink" title="4.用户如何提权"></a>4.用户如何提权</h1><p><em>往往公司的服务器对外都是禁止root用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？<br> 当我们使用普通用户执行/sbin目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用root用户直接登录系统，同时又保证普通用户能完成日常工作？<br> PS: 我们可以使用如下两种方式: su、sudo<br> 1.su切换用户，使用普通用户登录，然后使用su命令切换到root。优点:简单 缺点:需要知道root密码<br> 2.sudo提权，当需要使用root权限时进行提权，而无需切换至root用户，优点:安全、方便 缺点:复杂</em></p>
<p><em><strong>1.su身份切换</strong></em></p>
<p><em>在使用su切换前，我们需要了解一些预备知识，比如shell分类、环境变量配置文件有哪些</em></p>
<p><em>1.Linux Shell主要分为如下几类<br>交互式shell，等待用户输入执行的命令(终端操作,需要不断提示)<br>非交互式shell，执行shell脚本, 脚本执行结束后shell自动退出<br>登陆shell，需要输入用户名和密码才能进入Shell，日常接触的最多的一种<br>非登陆shell，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</em></p>
<p><em>2.bash shell配置文件介绍(文件主要保存用户的工作环境)<br>个人配置文件：~/.bash_profile ~/.bashrc 。全局配置文件：/etc/profile /etc/profile.d/*.sh /etc/bashrc<br>profile类文件, 设定环境变量, 登陆前运行的脚本和命令。bashrc 类文件, 设定本地变量, 定义命令别名<br>PS: 如果全局配置和个人配置产生冲突，以个人配置为准。</em></p>
<p><em>3.登陆系统后，环境变量配置文件的应用顺序是?</em><br> <em>登录式shell配置文件执行顺序: /etc/profile-&gt;/etc/profile.d/*.sh-&gt;<del>/.bash_profile-&gt;</del>/.bashrc-&gt;/etc/bashrc<br> 非登陆式shell配置文件执行顺序: ~/.bashrc-&gt;/etc/bashrc-&gt;/etc/profile.d/*.sh<br> PS: 验证使用echo在每行添加一个输出即可</em></p>
<p><em>4.说了这么多预备知识，那这些和su命令切换用户有什么关系?<br> su - username属于登陆式shell，su username属于非登陆式shell，区别在于加载的环境变量不一样。<br>普通用户<code>su -</code>可以直接切换至root用户，但需要输入root用户的密码。<br>超级管理员root用户使用<code>su - username</code>切换普通用户不需要输入任何密码。</em> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[xuliangwei@node1 ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@node1 xuliangwei]<span class="comment"># pwd</span></span><br><span class="line">/home/xuliangwei</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[xuliangwei@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.sudo提权</strong></em></p>
<p><em>su命令在切换用户身份时，如果每个普通用户都能拿到root用户的密码，当其中某个用户不小心泄漏了root的密码，那系统会变得非常不安全。为了改进这个问题，从而产生了sudo这个命令。</em></p>
<p><em>其实sudo就相当于给某个普通用户埋下了浩克(hulk)的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</em></p>
<p><em>1.如何快速埋下hulk的种子呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式[先睹为快]</span></span><br><span class="line">[root@node1 ~]<span class="comment"># usermod bgx -G wheel</span></span><br><span class="line">[root@node1 ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@www ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名）       4.命令名</span></span><br><span class="line">bgx       ALL=(ALL)         /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">oldboy   ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure>

<p><em>2.埋下了hulk种子后又如何提权使用呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo -l</span><br><span class="line">User xuliangwei may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure>

<p><em>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</em></p>
<p><em>第一种方式:使用sudo中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># visudo  #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个系统group没什么关系</span></span><br><span class="line">User_Alias OPS = oldboy,alex</span><br><span class="line">User_Alias DEV = bgx,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure>

<p><em>第二种方式:使用groupadd添加组,然后给组分配sudo的权限,如果有新用户加入,直接将用户添加到该组.</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure>

<p><em>4.sudo命令的执行流程:</em><br> <em>1) 普通用户执行sudo命令时, 会检查/var/db/sudo是否存在时间戳缓存<br> 2) 如果存在则不需要输入密码, 否则需要输入用户与密码<br> 3) 输入密码会检测是否该用户是否拥有该权限<br> 4) 如果有则执行，否则报错退出</em></p>
<p><em>下图为sudo执行流程</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728212235.png" alt="imageTitle"></p>
<p><a href="https://www.jianshu.com/p/d172a92475f1">sudo不支持系统内置命令</a></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>用户 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本权限</title>
    <url>/2021/08/02/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.权限基本概述  2.权限设置示例  3.权限设置案例  4.属主属组设置</p>
<span id="more"></span>

<h1 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h1><p><em><strong>1.什么是权限？</strong></em></p>
<p><em>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</em></p>
<p><em><strong>2.为什么要有权限</strong></em></p>
<p><em>因为系统中不可能只存在一个root用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。(比如三个租客合租同一个房子，a租客要使用b租客的肥皂，那这个事情？？</em></p>
<p><em><strong>3.权限与用户之间的关系？</strong></em></p>
<p><em>在Linux系统中，针对文件定义了三种身份，分别是属主(owner)、属组(group)、其他人(others)，每一种身份又对应三种权限(rwx)，分别是可读(readable)、可写(writable)、可执行(excutable)。</em></p>
<p>*用户对文件资源，有三种角色ugo，当一个用户访问文件流程如下</p>
<ol>
<li>判断用户是否为文件所有者，如果是则按所有者的权限进行访问</li>
<li>判断用户是否为文件所有组成员，如果是则按组的权限进行访问</li>
<li>如果不是所有者，也不是该文件所属组，则按匿名权限进行访问*</li>
</ol>
<p><em><strong>4.权限中的rwx分别代表什么含义？</strong></em></p>
<p><em>当我们使用ls -l查看一个文件的详细属性时，能看到每个文件都有一个9位基本权限位，比如: <code>rwxr-xr-x</code>其中每三位字符为一组，分别表示属主权限位，属组权限位，匿名权限位。<br>linux中基本权限位则是使用这9位字符来表示，主要控制文件属主(User)、属组(Group)、其他用户(Other)</em></p>
<table>
<thead>
<tr>
<th>字母</th>
<th>含义</th>
<th>对应权限</th>
</tr>
</thead>
<tbody><tr>
<td>r（read）</td>
<td>读取权限</td>
<td>4</td>
</tr>
<tr>
<td>w（write）</td>
<td>写入权限</td>
<td>2</td>
</tr>
<tr>
<td>x（execute）</td>
<td>执行权限</td>
<td>1</td>
</tr>
<tr>
<td>-（没有权限）</td>
<td>没有权限</td>
<td>0</td>
</tr>
</tbody></table>
<p><em>PS: 如果权限位不可读、不可写、不可执行，则全部使用-作为占位符表示。</em></p>
<h1 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h1><p><em>文件示例: rwxrw-r– alice hr file1.txt<br> Q1: alice对file1文件拥有什么权限?<br> Q2: jack 对 file1.txt 文件有什么权限? 前提:jack 属于 hr 组<br> Q3: tom 对 file1.txt 文件有什么权限?</em></p>
<p><em><strong>1.为什么要设定权限，我们又如何修改一个文件的权限?</strong></em></p>
<p><em>Q1: 为什么要设定权限，可以赋于某个用户或组 – 能够以何种方式 – 访问某个文件<br>Q2: Linux下使用chmod命令来变更权限，root用户可以变更所有文件的权限，而普通用户仅能变更属于自己的文件。</em></p>
<p><em><strong>2.使用chmod设定权限示例</strong></em></p>
<p><em>方式一: ugo</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># touch file                    #创建文件</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=rwx file              #给所有人添加读写执行权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=-rwx file             #取消所有的权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod u=rwx,g=rw,o=- file     #属主读写执行，属组读写，其他人无权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod ug=rwx,o=r file         #属主属组读写执行，其他人读权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure>

<p><em>方式二、number</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项:  -R递归修改</span></span><br><span class="line">[root@bgx ~]<span class="comment"># touch file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 644 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 600 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对目录设定权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 777 dir/    #修改目录允许所有人访问</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod -R 755 dir/ #修改目录及子目录权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d dir/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir/</span><br></pre></td></tr></table></figure>

<p><em><strong>3.权限设置案例</strong></em></p>
<p><em>针对 hr 部门的访问目录/home/hr 设置权限，要求如下:<br>1.root 用户和 hr 组的员工可以读、写、执行<br>2.其他用户没有任何权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># groupadd hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr01 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr02 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chgrp hr /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 770 /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /home/hr</span></span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 /home/hr</span><br></pre></td></tr></table></figure>

<h1 id="3-权限设置案例"><a href="#3-权限设置案例" class="headerlink" title="3.权限设置案例"></a>3.权限设置案例</h1><p><em>在Linux中权限对文件和对目录的影响是有不同区别的。</em></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>读取权限（r）</td>
<td>具有读取\阅读文件内容权限</td>
<td>具有浏览目录及子目录</td>
</tr>
<tr>
<td>写入权限（w）</td>
<td>具有新增、修改文件内容的权限</td>
<td>具有增加和删除目录内文件</td>
</tr>
<tr>
<td>执行权限（x）</td>
<td>具有执行文件的权限</td>
<td>具有访问目录的内容(取决于目录中文件权限)</td>
</tr>
</tbody></table>
<p><em>文件权限实验案例:</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.新建文件，并添加内容至文件中，默认文件匿名用户仅有读权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;date&quot; &gt; filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll filename</span></span><br><span class="line">-rw-r--r-- 1 root root 5 Jan 24 08:24 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换bgx普通用户</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># su - bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对文件拥有读取的权限，但bgx用户对文件没有执行和删除的权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat  /root/filename</span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用root增加x执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+x /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--r-x 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.测试x权限是否真的能执行该文件</span></span><br><span class="line">[bgx@lucifer ~]$ /root/filename</span><br><span class="line">Wed Jan 24 08:28:34 EST 2018</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.增加w执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+w /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--rwx 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#7.测试执行权限</span></span><br><span class="line">[bgx@lucifer ~]$ vim /root/filename</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对文件的影响</em><br> <em>读取权限（r）具有读取\阅读文件内容权限<br> 1.只能使用查看类命令cat、head、tail、less、more</em></p>
<p><em>写入权限（w）具有新增、修改文件内容的权限<br>1.使用vim编辑会提示权限拒绝, 但可强制保存,会覆盖文件的所有内容<br>2.使用echo命令重定向的方式可以往文件内写入数据,&gt;&gt;可以进行追加<br>3.不能删除文件,因为删除文件看的不是文件的属性,需要看上级目录是否有w的权限</em></p>
<p><em>执行权限（x）具有执行文件的权限<br>1.执行权限什么用都没有<br>2.如果普通用户需要执行文件,需要配合r权限</em></p>
<p><strong>目录权限实验案例:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1: 创建目录，并在该目录下创建文件，匿名用户对目录没有w权限，对文件有777权限 </span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir /dirname</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;test&quot; &gt;&gt; /dirname/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限，能正常查看，但无法删除[奇怪]</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">rm: cannot remove ‘/dirname/filename’: Permission denied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 设置目录777权限，相当于匿名用户对目录有w权限，对文件没有任何权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 000 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line">cat: /dirname/filename: Permission denied</span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">[bgx@lucifer ~]$ touch /dirname/filename_2</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对目录的影响</em></p>
<p><em>读取权限（r），如果目录只有r权限: 具有浏览目录及子目录权限<br>1.可以使用ls命令浏览目录及子目录， 但同时也会提示权限拒绝<br>2.使用ls -l命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br>总结: 目录只有r权限，仅仅只能浏览内的文件名，无其他操作权限</em></p>
<p><em>写入权限（w），如果目录只有w权限: 具有增加、删除或修改目录内文件名权限(需要x权限配合)<br>PS: 如果目录有w权限, 可以在目录内创建文件, 删除文件(跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</em></p>
<p><em>执行权限（x），如果目录只有x权限<br>1.只能进入目录<br>2.不能浏览、复制、移动、删除</em></p>
<p><em><strong>Linux权限总结与注意事项</strong></em></p>
<p><em>文件r权限,  只给用户查看,无其他操作<br>文件rw权限, 可以查看和编辑文件内容<br>文件rx权限, 允许查看和执行文件、但不能修改文件—–&gt;PASS<br>文件rwx权限, 能读,能写,能执行,但不能删除,因为删除需要看上级目录的权限有没有w—–&gt;PASS<br>目录rx权限, 允许浏览目录内文件以及子目录、并允许在目录内新建文件, 不允许创建、删除文件和目录<br>目录wx权限, 能进入目录,能删除内容,能写入内容,但就是无法使用ls cat这样的命令—–&gt;PASS<br>目录rw权限, 能看,能写,但无法进入目录—–&gt;PASS<br>PS: 文件的 x权限小心给予，目录的 w权限小心给予。<br>PS: 文件通常设定的权限是644,目录设定的权限是755<br>PS: 控制目录权限755, 如果有普通用户需要操作目录里面的文件，在来看文件的权限</em></p>
<h1 id="4-属主属组设置变更文件属主和属组的意义？"><a href="#4-属主属组设置变更文件属主和属组的意义？" class="headerlink" title="4.属主属组设置变更文件属主和属组的意义？"></a>4.属主属组设置<em>变更文件属主和属组的意义？</em></h1><p><em>变更文件属主和属组的意义？</em><br> <em>比如: 我现在手里有多套房，希望出售其中的A房进行变现，那么我会考虑将A房过户给金主，过户成功后A房就属于金主了，那么此时A房的拥有者就属于金主而不再属于我。</em></p>
<p><em>在Linux中如何变更一个文件或者一个资源的属主和属组呢，可以使用chown、chgrp命令实现。<br>chown能设置属主和属组，chgrp仅能设置属组。（所以用哪个你懂的）</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chown 更改属主以及属组 -R：递归修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备环境，创建文件和目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir/test1 &amp;&amp; touch dir/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1: 修改所属主为bin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown bin dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 修改所属组为adm</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown .adm dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 递归修改目录及目录下的所有文件属主和属组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown -R root.root dir/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件管理</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.文件管理概述 2.系统目录结构 3.文件路径定位 4.系统文件管理 5.系统文件属性 6.系统文件类型  7.系统链接文件</p>
<span id="more"></span>
<h1 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h1><p><em><strong>1.Bash Shell对文件进行管理</strong></em></p>
<p><em>谈到Linux文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？<br> 其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等<br> 例如: 当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</em></p>
<h1 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h1><p><em>几乎所有的计算机操作系统都是使用目录结构组织文件。具体来说就是在一个目录中存放子目录和文件, 而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支, 所以该结构又被称为“目录树”。<br> Windows: 以多根的方式组织文件 C:\ D:<br> Linux:以单根的方式组织文件   /</em></p>
<p><em><strong>1.存放命令相关的目录</strong></em></p>
<p><em>/bin， 普通用户使用的命令 /bin/ls, /bin/date</em><br><em>/sbin，管理员使用的命令 /sbin/service</em></p>
<p><em><strong>2.存放用户相关数据的家目录</strong></em></p>
<p><em>/home，普通用户的家目录, 默认为/home/username<br>/root，超级管理员root的家目录, 普通用户无权操作</em></p>
<p><em><strong>3.系统文件目录</strong></em></p>
<p><em>/usr，相当于C:\Windows<br>/usr/local，软件安装的目录，相当于C:\Program<br>/usr/bin/，普通用户使用的应用程序(重要)<br>/usr/sbin，管理员使用的应用程序(重要)<br>/usr/lib，库文件Glibc 32bit<br>/usr/lib64，库文件Glibc 64bit</em></p>
<p><em><strong>4.启动目录</strong></em></p>
<p>/boot 存放的系统启动相关的文件，例如:kernel，grub(引导装载程序)*</p>
<p><em><strong>5.配置文件目录</strong></em></p>
<p><em>/etc，极其重要，后续所有服务的配置都在这个目录中<br>/etc/sysconfig/network-script/ifcfg-，网络配置文件<br>/etc/hostname，系统主机名配置文件<br>/etc/resolv.conf，dns客户端配置文件<br>/etc/hosts，本地域名解析配置文件</em></p>
<p><em><strong>6.可变的目录与临时目录</strong></em></p>
<p><em>/var，存放一些变化文件，比如/var/log/下的日志文件<br>/var/tmp，进程产生的临时文件<br>/tmp，系统临时目录(类似于公共厕所)</em></p>
<p><em><strong>7.设备目录文件</strong></em></p>
<p><em>/dev，存放设备文件，比如硬盘，硬盘分区，光驱，等等<br>/dev/null，黑洞设备，只进不出。类似于垃圾回收站<br>/dev/random，生成随机数的设备<br>/dev/zero，能远远不断的产生数据，类似于取款机，随时随地取钱</em></p>
<p><em><strong>8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)</strong></em></p>
<p><em>/proc，反映系统当前进程的实时状态<br>PS：类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了。</em></p>
<p><em><strong>9.PS: 在Linux7系统中, /bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下</strong></em></p>
<p><em>/bin  –&gt; /usr/bin<br>/sbin –&gt; /usr/sbin<br>lib -&gt; usr/lib<br>lib64 -&gt; usr/lib64</em></p>
<h1 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h1><p><em>在我们开始操作文件前，首先需要对文件进行定位，比如:<br>你要在哪创建什么文件? 你要将文件复制到什么地方? 或者你要删除的文件在什么地方?<br>那什么是定位: 比如/etc/hostname，整个文件中包含文件名称以及文件所在的位置，我们将这个叫做路径，那么路径就是对文件进行定位的一种方式.</em></p>
<p><em><strong>1.每个目录下都有一个.和..的目录是干啥的?</strong></em><br> <em>一个点代表当的是当前目录, 两个点代表的是当前目录的上层目录。<br>假设当前目录在<code>/usr/</code>下, 那么它的上层(/)目录用<code>../</code>表示, 而<code>/usr/</code>的下层(local)目录则用<code>./local</code>表示。</em></p>
<p><em><strong>2.那什么是绝对路径，什么又是相对路径呢?</strong></em><br> <em>绝对路径: 只要从/开始的路径，比如/home/alice/file<br>相对路径: 相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3 [加入: 此时在目录/home/alice]<br>小结: 所谓的(.)和(..)目录实际上属于相对路径的一种表示形式。</em></p>
<p><em><strong>3.绝对路径与相对路径示例</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch file4</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure>

<p><em>cd改变目录，常见的使用方法</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>改变目录，常见的使用方法<span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure>

<h1 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h1><h2 id="1-文件管理之-创建-复制-移动-删除"><a href="#1-文件管理之-创建-复制-移动-删除" class="headerlink" title="1.文件管理之: 创建/复制/移动/删除"></a><em><strong>1.文件管理之: 创建/复制/移动/删除</strong></em></h2><p><em><strong>—————————————-创建—————————————-</strong></em></p>
<p><em>1.文件创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch file                    #无则创建,有则修改时间</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>2.目录创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>3.以树状显示目录结构命令tree</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cp复制—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-mv移动—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rm删除—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)"></a><em><strong>2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)</strong></em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure>

<h2 id="3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)"></a><em><strong>3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)</strong></em></h2><p><em><strong>—————————————-wget、curl联网下载文件—————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rzsz上传下载文件—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rz            #只能上传文件文件上传</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件管理之：文件或命令查找-locate、which、whereis、find"><a href="#4-文件管理之：文件或命令查找-locate、which、whereis、find" class="headerlink" title="4.文件管理之：文件或命令查找(locate、which、whereis、find)"></a><em><strong>4.文件管理之：文件或命令查找(locate、which、whereis、find)</strong></em></h2><p><em><strong>—————————————-文件查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-命令查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       //查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    //仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls        #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、"><a href="#5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、" class="headerlink" title="5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)"></a><em><strong>5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)</strong></em></h2><p><em><strong>—————————————-sort排序—————————————-</strong></em></p>
<p><em>在有些情况下，需要对应一个无序的文本文件进行数据的排序，这时就需要使用sort进行排序了。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例，下载文件http://fj.lucifer.com/public/ip.txt，对该文件进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-uniq去重—————————————</strong></em></p>
<p><em>如果文件中有多行完全相同的内容，当前是希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数, 那么就可以使用<code>uniq</code>命令解决这个问题(但是必须配合<code>sort</code>使用)。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cut截取字段—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-wc统计行号—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure>

<h1 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h1><p><em>当我们使用ls -l列目录下所有文件时，通常会以长格式的方式显示，其实长格式显示就是我们Windows下看到的文件详细信息，我们也将其称为文件属性，那整个文件的属性分为十列。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls -l ks.cfg</span></span><br><span class="line">-rw-------. 1 root root 4434 May 30 13:58 ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">4434        ⑤:文件大小</span><br><span class="line">May30 13:58 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure>

<h1 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h1><p><em>1.通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过ls -l以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure>

<p><em>2.但有些情况下，我们无法通过ls -l文件的类型，比如: 一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@lucifer ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure>

<p><em>PS: Linux文件扩展名不代表任何含义，仅为了我们能更好的识别该文件是什么类型。</em></p>
<h1 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h1><p><em>文件有文件名与数据，在Linux上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。<br>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方，我们将其称为Block<br>元数据，即文件的附加属性，如文件大小、创建时间、所有者等信息。我们称其为Inode<br>在Linux中，inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）<br>文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</em></p>
<h2 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)"></a><em><strong>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)</strong></em></h2><h3 id="1-什么是软链接"><a href="#1-什么是软链接" class="headerlink" title="1.什么是软链接"></a><em><strong>1.什么是软链接</strong></em></h3><p><em>软链接相当于Windows的快捷方式，软链接文件会将inode指向源文件的block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个inode指向同一个block。当我们删除软链接文件时，其实只是删除了一个inode指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。</em></p>
<h3 id="2-什么是硬链接"><a href="#2-什么是硬链接" class="headerlink" title="2.什么是硬链接"></a><em><strong>2.什么是硬链接</strong></em></h3><p><em>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，如下图hard link 就是 file 的一个别名，他们有共同的 inode。</em></p>
<p><em>软链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak</span><br><span class="line">ll /tmp/file_bak  //root下file链接到/tmp下并重命名为file_bak</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx</span><br><span class="line">ll /soft/nginx   //查看链接指向</span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure>

<p><em>硬链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">4.硬链接实践<span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard</span><br><span class="line">ll /tmp/file_hard</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS：目录不能创建硬链接，硬链接文件可以用rm命令删除</span></span><br></pre></td></tr></table></figure>

<h3 id="3-硬链接与软链接区别"><a href="#3-硬链接与软链接区别" class="headerlink" title="3.硬链接与软链接区别"></a><em>3.硬链接与软链接区别</em></h3><p> <em>1)ln命令创建硬链接，ln -s命令创建软链接。<br> 2)目录不能创建硬链接，并且硬链接不可以跨越分区系统。<br> 3)目录软链接特别常用,并且软链接支持跨越分区系统。<br> 4)硬链接文件与源文件的inode相同，软链接文件与源文件inode不同。<br> 5)删除软链接文件，对源文件及硬链接文件无任何影响。<br> 6)删除文件的硬链接文件，对源文件及链接文件无任何影响。<br> 7)删除链接文件的源文件，对硬链接无影响，会导致软链接失效。<br> 8)删除源文件及其硬链接文件，整个文件会被真正的删除。</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件编辑(vim)</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%EF%BC%88vim%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.VIM基本概述 2.VIM模式使用 3.VIM扩展知识 4.VIM练习示例</p>
<span id="more"></span>
<h1 id="1-vim基本概述"><a href="#1-vim基本概述" class="headerlink" title="1.vim基本概述"></a>1.vim基本概述</h1><p><em><strong>1.什么是vim</strong></em></p>
<p><em>vi和vim是Linux下的一个文本编辑工具。(可以理解为windows的记事本，或word文档)</em></p>
<p><em><strong>2.为什么要使用VIM?</strong></em></p>
<p><em>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</em></p>
<p><em><strong>3.VI与VIM有什么区别?</strong></em></p>
<p><em>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于window</em>s<em>系统下的文本编辑软件“记事本”与”notepad++”的区别)</em><br>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y安装*</p>
<p><em><strong>4.如何使用VIM编辑器?</strong></em></p>
<p><em>在使用VIM之前，我们需要先介绍下VIM的三种模式: 普通模式、编辑模式、命令模式，每种模式分别支持多种不同的快捷键，要想高效率地操作文本，那就必须先搞清这三种模式的操作区别以及模式之间的切换方法。</em></p>
<p><em><strong>5.VIM模式三种模式介绍</strong></em></p>
<p><em>1.普通模式: 主要是控制光标移动，可对文本进行复制、粘贴、删除等工作。<br> 使用vim filename 编辑一个文件时，一进入该文件就是普通模式了。<br> 在这个模式下，可以进行光标移动、复制、删除、粘贴操作。</em></p>
<p><em>2.编辑模式: 主要进行文本内容编辑和修改<br> 从普通模式进入编辑模式，只需你按一个键即可（i, I, a, A, o, O）<br> 当进入编辑模式时，会在屏幕的最下一行会出现 “INSERT”标记<br> 从编辑模式回到普通模式只需要按键盘左上方的 ESC 键即可。</em></p>
<p><em>3.末行模式: 主要用于保存或退出文本。<br> 在普通模式下，输入 “:” 或者 “/“ 即可进入命令模式。<br> 在命令该模式下，可进行的操作有，显示行号、搜索、替换、保存、退出。</em></p>
<p><em>小结: vim编辑打开文件整体流程如下:<br> 1.默认打开文件处于普通模式<br> 2.从普通模式切换至编辑模式需要使用a、i、o<br> 3.编辑模式修改完毕后需要先使用ECS返回普通模式<br> 4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br> PS: 在vim中，无法直接从编辑模式切换到命令模式。</em></p>
<h1 id="2-VIM模式使用"><a href="#2-VIM模式使用" class="headerlink" title="2.VIM模式使用"></a>2.VIM模式使用</h1><h2 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1.普通模式"></a><em>1.普通模式</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G       <span class="comment">#光标跳转至末端</span></span><br><span class="line">gg      <span class="comment">#光标跳转至顶端</span></span><br><span class="line">Ngg     <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$       <span class="comment">#光标跳转至当前光标所在行的尾部</span></span><br><span class="line">^|0     <span class="comment">#光标跳转至当前光标所在行的首部</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容较多</span></span><br><span class="line">ctrl+f  <span class="comment">#往下翻页(行比较多)</span></span><br><span class="line">ctrl+b  <span class="comment">#往上翻页</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.复制与粘贴</span></span><br><span class="line">yy      <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">5yy     <span class="comment">#复制当前光标以及光标向下4行</span></span><br><span class="line"> </span><br><span class="line">p(小写)   <span class="comment">#粘贴至当前光标下一行   </span></span><br><span class="line">P(大写)   <span class="comment">#粘贴至当前光标上一行</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.删除、剪贴、撤销  </span></span><br><span class="line">dd      <span class="comment">#删除当前光标所在的行   </span></span><br><span class="line">4dd     <span class="comment">#删除当前光标所在的行以及往下的3行</span></span><br><span class="line">dG      <span class="comment">#删除当前光标以后的所有行</span></span><br><span class="line">D       <span class="comment">#删除当前光标及光标以后的内容  </span></span><br><span class="line">x       <span class="comment">#删除当前光标标记往后的字符</span></span><br><span class="line">X       <span class="comment">#删除当前光标标记往前的字符</span></span><br><span class="line">dd &amp; p  <span class="comment">#剪贴、先删除dd(number dd)，后粘贴p</span></span><br><span class="line">u       <span class="comment">#撤销上一次的操作</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.替换</span></span><br><span class="line">r       <span class="comment">#替换当前光标标记的单个字符</span></span><br><span class="line">R       <span class="comment">#进入REPLACE模式, 连续替换，ESC结束</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编辑模式-从普通模式进入到编辑模式"><a href="#2-编辑模式-从普通模式进入到编辑模式" class="headerlink" title="2.编辑模式(从普通模式进入到编辑模式)"></a><em>2.编辑模式(从普通模式进入到编辑模式)</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i   <span class="comment">#进入编辑模式，光标不做任何操作</span></span><br><span class="line">a   <span class="comment">#进入编辑模式，将当前光标往后一位</span></span><br><span class="line">o   <span class="comment">#进入编辑模式，并在当前光标下添加一行空白内容</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">I   <span class="comment">#进入编辑模式，并且光标会跳转至本行的头部</span></span><br><span class="line">A   <span class="comment">#进入编辑模式，将光标移动至本行的尾部</span></span><br><span class="line">O   <span class="comment">#进入编辑模式，并在当前光标上添加一行空白内容</span></span><br></pre></td></tr></table></figure>

<h2 id="3-命令模式，主要用于搜索-保存-退出文件。"><a href="#3-命令模式，主要用于搜索-保存-退出文件。" class="headerlink" title="3.命令模式，主要用于搜索, 保存, 退出文件。"></a><em>3.命令模式，主要用于搜索, 保存, 退出文件。</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.文件保存与退出</span></span><br><span class="line">:w      保存当前状态</span><br><span class="line">:w!     强制保存当前状态</span><br><span class="line">:q      退出当前文档(文档必须保存才能退出)</span><br><span class="line">:q!     强制退出文档不会修改当前内容</span><br><span class="line">:wq     先保存，在退出</span><br><span class="line">:wq!    强制保存并退出</span><br><span class="line">:x      先保存，在退出</span><br><span class="line">ZZ      保存退出, shfit+zz</span><br><span class="line">:number 跳转至对应的行号</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容查找</span></span><br><span class="line">/string <span class="comment">#需要搜索的内容（查找）</span></span><br><span class="line">n       <span class="comment">#按搜索到的内容依次往下进行查找</span></span><br><span class="line">N       <span class="comment">#按搜索到的内容依次往上进行查找</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.文件内容替换</span></span><br><span class="line">:1,5s<span class="comment">#sbin#test#g   #替换1-5行中包含sbin的内容为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#g     #替换整个文本文件中包含sbin的替换为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#gc    #替换内容时时提示是否需要替换</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.文件内容另存</span></span><br><span class="line">:w /root/test.txt  <span class="comment">#将所有内容另存为/root/test.txt文件中</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.文件内容读入</span></span><br><span class="line">:r  /etc/hosts  <span class="comment">#读入/etc/hosts文件至当前光标下面</span></span><br><span class="line">:5r /etc/hosts  <span class="comment">#指定插入/etc/hosts文件至当前文件的第五行下面</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视图模式-从普通模式进入视图模式-，主要进行批量操作"><a href="#4-视图模式-从普通模式进入视图模式-，主要进行批量操作" class="headerlink" title="4.视图模式(从普通模式进入视图模式)，主要进行批量操作"></a><em>4.视图模式(从普通模式进入视图模式)，主要进行批量操作</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<h1 id="3-VIM扩展知识"><a href="#3-VIM扩展知识" class="headerlink" title="3.VIM扩展知识"></a>3.VIM扩展知识</h1><h2 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1.环境变量临时生效"></a><em>1.环境变量临时生效</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure>

<h2 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量"></a><em>2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3.如何同时编辑多个文件"></a><em>3.如何同时编辑多个文件</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure>

<h2 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4.相同文件之间差异对比，通常用于对比修改前后差异"></a><em>4.相同文件之间差异对比，通常用于对比修改前后差异</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后"><a href="#5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后" class="headerlink" title="5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后"></a><em>5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux特殊权限</title>
    <url>/2021/08/05/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.特殊权限概述  2.特殊权限SUID  3.特殊权限SGID  4.特殊权限SBIT  5.权限属性chattr  6.进程掩码umask</p>
<span id="more"></span>

<h1 id="1-特殊权限概述"><a href="#1-特殊权限概述" class="headerlink" title="1.特殊权限概述"></a>1.特殊权限概述</h1><p><em>前面我们已经学习过 r（读）、w（写）、 x（执行）这三种普通权限，但是我们在査询系统文件权限时会发现出现了一些其他权限字母，比如：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p><em>在属主本来应该是 x（执行）权限的位置出现了一个小写s，这是什么权限？我们把这种权限称作 SetUID 权限，也叫作 SUID 的特殊权限。这种权限有什么作用呢？或者说能干啥？别急，先往下看….</em></p>
<h1 id="2-特殊权限SUID"><a href="#2-特殊权限SUID" class="headerlink" title="2.特殊权限SUID"></a>2.特殊权限SUID</h1><p><em><strong>1.问题抛出</strong></em><br> <em>在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd  文件中，用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow  文件中的加密密码，但是文件权限显示，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的权限呢？……(难道学了个假的权限)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /etc/passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 6209 Apr 13 03:26 /etc/passwd</span><br><span class="line">[root@bgx ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">---------- 1 root root 11409 Apr 13 03:26 /etc/shadow</span><br></pre></td></tr></table></figure>

<p><em><strong>2.解决方案</strong></em></p>
<p><em>其实，普通用户可以修改自己的密码在于 passwd 命令。该命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。</em></p>
<p><em>PS: 当普通用户使用 passwd 命令更改自己的密码时，实际上是在用 passwd 命令所有者 root 的身份在执行  passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow  文件，命令执行完成后，该身份也随之消失。</em></p>
<p><em><strong>3.示例演示</strong></em></p>
<p><em>举个例子，有一个用户 lamp，她可以修改自己的密码，因为 passwd 命令拥有 SetUID 权限；但是她不能査看 /etc/shadow 文件的内容，因为査看文件的命令（如 cat）没有 SetUID 权限。命令如下：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自己可以修改自己的密码，从而改变/etc/shadow中的数据</span></span><br><span class="line">[lamp@bgx ~]$ passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#但无法使用cat命令查看/etc/shadow</span></span><br><span class="line">[lamp@bgx ~]$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure>

<p><em><strong>4.例子解释</strong></em></p>
<p><em>passwd 是系统命令，可以执行，所以可以赋予 SetUID 权限。<br>lamp 用户对 passwd 命令拥有 x（执行）权限。<br>lamp 用户在执行 passwd 命令的过程中，会暂时切换为 root 身份，所以可以修改 /etc/shadow 文件。<br>命令结束，lamp 用户切换回自己的身份。<br>PS: cat命令没有 SetUID权限，所以使用 lamp 用户身份去访问 /etc/shadow 文件，当然没有相应权限了。<br>F: 但如果将passwd命令的suid去掉会发生什么？？？</em></p>
<p><em>2.suid授权方法4000 权限字符s(S),用户位置上的x位上设置</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 4755 passwd</span></span><br><span class="line"><span class="comment"># chmod  u+s  passwd</span></span><br></pre></td></tr></table></figure>

<p><em>3.suid的作用</em><br> <em>1.让普通用户对可执行的二进制文件，临时拥有二进制文件的所属主权限。<br>2.如果设置的二进制文件没有执行权限,那么suid的权限显示就是大S。<br>3.特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效。<br>注意: suid极度危险，不信可以尝试对vim或rm进行设定SetUID。</em></p>
<h1 id="3-特殊权限SGID"><a href="#3-特殊权限SGID" class="headerlink" title="3.特殊权限SGID"></a>3.特殊权限SGID</h1><p><em>将目录设置为sgid后，如果在该目录下创建文件，都将与该目录的所属组保持一致，演示如下</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.建立测试目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># cd /tmp/ &amp;&amp; mkdir dtest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.给测试目录赋予SetGID权限，检查SetGID是否生效</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod g+s dtest/ &amp;&amp; ll -d dtest/</span></span><br><span class="line">drwxr-sr-x 2 root root 6 Apr 13 05:21 dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.给测试目录赋予777权限，让普通用户可以写</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod 777 dtest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.切换成普通用户lamp，并进入该目录</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># su - lamp</span></span><br><span class="line">[lamp@bgx ~]$ <span class="built_in">cd</span> /tmp/dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.普通用户创建测试文件，检查文件的信息</span></span><br><span class="line">[lamp@bgx dtest]$ touch lamp_test</span><br><span class="line">[lamp@bgx dtest]$ ll</span><br><span class="line">-rw-rw-r-- 1 lamp root 0 Apr 13 05:21 lamp_test</span><br></pre></td></tr></table></figure>

<p><em>2.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 2755  directory </span></span><br><span class="line"><span class="comment"># chmod  g+s  directory</span></span><br></pre></td></tr></table></figure>

<p><em>3.sgid作用<br>1.针对用户组权限位修改，用户创建的目录或文件所属组和该目录的所属组一致。<br>2.当某个目录设置了sgid后，在该目录中新建的文件不在是创建该文件的默认所属组<br>3.使用sgid可以使得多个用户之间共享一个目录的所有文件变得简单。</em></p>
<h1 id="4-特殊权限SBIT"><a href="#4-特殊权限SBIT" class="headerlink" title="4.特殊权限SBIT"></a>4.特殊权限SBIT</h1><p><em>Sticky(SI TI KI)粘滞位目前只对目录有效，作用如下：<br>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。如果没有粘滞位，那么普通用户拥有 w  权限，就可以删除此目录下的所有文件，包括其他用户建立的文件。但是一旦被赋予了粘滞位，除了 root 可以删除所有文件，普通用户就算拥有 w  权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx tmp]<span class="comment"># ll -d /tmp/</span></span><br><span class="line">drwxrwxrwt. 12 root root 4096 Apr 13 05:32 /tmp/</span><br></pre></td></tr></table></figure>

<p><em>sticky授权方法，1000 权限字符t(T),其他用户位的x位上设置。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 1755  /tmp</span></span><br><span class="line"><span class="comment"># chmod o+t /tmp</span></span><br></pre></td></tr></table></figure>

<p><em>3.sticky作用</em><br> <em>1.让多个用户都具有写权限的目录，并让每个用户只能删自己的文件。<br> 2.特殊sticky目录表现在others的x位，用小t表示，如果没有执行权限是T<br> 3.一个目录即使它的权限为”777”如果是设置了粘滞位，除了目录的属主和”root”用户有权限删除，除此之外其他用户都不允许删除该目录。</em></p>
<h1 id="5-权限属性chattr"><a href="#5-权限属性chattr" class="headerlink" title="5.权限属性chattr"></a>5.权限属性chattr</h1><p><em>chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。<br>chatrr 命令格式：[root@bgx ~]# chattr [+-=] [选项] 文件或目录名</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: + 增加权限 -减少权限 =等于某个权限</span></span><br><span class="line"><span class="comment"># a：让文件或目录仅可追加内容</span></span><br><span class="line"><span class="comment"># i：不得任意更动文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建文件并设置属性</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file_a file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">---------------- file_a</span><br><span class="line">---------------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用chattr设置属性，lsattr查看权限限制</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +a file_a</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +i file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">-----a---------- file_a</span><br><span class="line">----i----------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.a权限，无法写入和删除文件，但可以追加数据，适合/etc/passwd这样的文件</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt; file_a</span></span><br><span class="line">bash: file_a: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f file_a</span></span><br><span class="line">rm: cannot remove ‘file_a’: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt;&gt; file_a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.i权限, 无法写入，无法删除，适合不需要更改的重要文件加锁</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt;&gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f  file_i</span></span><br><span class="line">rm: cannot remove ‘file_i’: Operation not permitted</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解除限制</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -a file_a	</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -i file_i</span></span><br></pre></td></tr></table></figure>

<h1 id="6-进程掩码umask"><a href="#6-进程掩码umask" class="headerlink" title="6.进程掩码umask"></a>6.进程掩码umask</h1><p><em><strong>1.umask是什么?</strong></em><br> <em>当我们登录系统之后创建一个文件总是有一个默认权限的，比如: 目录755、文件644、那么这个权限是怎么来的呢？这就是umask干的事情。umask设置了用户创建文件的默认权限。</em></p>
<p><em><strong>2.umask是如何改变创建新文件的权限</strong></em><br><em>系统默认umask为022，那么当我们创建一个目录时，正常情况下目录的权限应该是777，但umask表示要减去的值，所以新目录文件的权限应该是777 - 022 =755。至于文件的权限也依次类推666 - 022 =644。</em></p>
<p><em><strong>3.umask涉及哪些配置文件</strong></em><br><em>umask涉及到的相关文件/etc/bashrc /etc/profile ~/.bashrc ~/.bash_profile<br> shell (vim,touch) –umask–&gt; 会影响创建的新文件或目录权限<br> vsftpd服务如果修改–umask–&gt; 会影响ftp服务中新创建文件或创建目录权限<br> useradd如果修改umask–&gt; 会影响用户HOME家目录权限</em></p>
<p><em><strong>4.umask演示示例</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.假设umask值为：022（所有位为偶数）</span></span><br><span class="line"><span class="comment">#文件的起始权限值</span></span><br><span class="line">6 6 6  -  0 2 2  = 6 4 4 </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.假设umask值为：045（其他用户组位为奇数）</span></span><br><span class="line"><span class="comment">#计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。</span></span><br><span class="line">6 6 6  -   0 4 5 = 6 2 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.默认目录权限计算方法</span></span><br><span class="line">7 7 7  -  0 2 2 = 7 5 5</span><br><span class="line"> </span><br><span class="line"><span class="comment">#umask所有位全为偶数时</span></span><br><span class="line"><span class="comment"># umask 044</span></span><br><span class="line"><span class="comment"># mkdir d044   目录权限为733</span></span><br><span class="line"><span class="comment"># touch f044   文件权限为622</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask部分位为奇数时</span></span><br><span class="line"><span class="comment"># umask 023</span></span><br><span class="line"><span class="comment"># mkdir d023   目录权限为754</span></span><br><span class="line"><span class="comment"># touch f023   文件权限为644	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask值的所有位为奇数时</span></span><br><span class="line"><span class="comment"># umask 035</span></span><br><span class="line"><span class="comment"># mkdir d035   目录权限为742</span></span><br><span class="line"><span class="comment"># touch f035   文件权限为642</span></span><br></pre></td></tr></table></figure>

<p><em>示例1: 在 shell 进程中创建文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前用户的umask权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d file0022  dir0022/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Jan 24 09:02 dir0022/</span><br><span class="line">-rw-r--r-- 1 root root 0 Jan 24 09:02 file0022</span><br></pre></td></tr></table></figure>

<p><em>示例2: 修改 shell umask 值(临时生效)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># umask 000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d dir000 file000</span></span><br><span class="line">drwxrwxrwx 2 root root 6 Jan 24 09:04 dir000</span><br><span class="line">-rw-rw-rw- 1 root root 0 Jan 24 09:04 file000</span><br></pre></td></tr></table></figure>

<p><em>示例3: 通过 umask 决定新建用户 HOME 目录的权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 077</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd dba</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/dba/</span></span><br><span class="line">drwx------. 4 dba dba 4096 3 月 11 19:50 /home/dba/</span><br><span class="line"></span><br><span class="line">[root@tianyun ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 000</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd sa</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/sa/</span></span><br><span class="line">drwxrwxrwx. 4 sa sa 4096 3 月 11 19:53 /home/sa/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
</search>
