<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash概述</title>
    <url>/2021/07/28/Bash%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.Bash Shell初步认识 2.Bash Shell基本特性 3.Bash Shell获取帮助 4.Bash Shell命令流程</p>
<span id="more"></span>
<h1 id="1-Bash-Shell初步认识"><a href="#1-Bash-Shell初步认识" class="headerlink" title="1.Bash Shell初步认识"></a>1.Bash Shell初步认识</h1><h2 id="1-什么是Bash-shell-壳"><a href="#1-什么是Bash-shell-壳" class="headerlink" title="1.什么是Bash shell(壳)"></a>1.什么是Bash shell(壳)</h2><p><em>Bash Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。</em></p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210727093855.png" alt="imageTitle"></p>
<p><em>当我们使用远程连接工具连接linux服务，系统则会给打开一个默认的shell，我们可在这个界面执行命令、比如：获取系统当前时间，创建一个用户等等….</em></p>
<h2 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么"></a>2.Bash Shell能干什么</h2><p><em>使用Shell实现对Linux系统的大部分管理，例如:<br> 1.文件管理<br> 2.权限管理<br> 3.用户管理<br> 4.磁盘管理<br> 5.网络管理<br> 6.软件管理<br> .等等.</em></p>
<h2 id="3-平时我们如何使用Shell？"><a href="#3-平时我们如何使用Shell？" class="headerlink" title="3.平时我们如何使用Shell？"></a>3.平时我们如何使用Shell？</h2><p><em>输入命令 –&gt; 效率低 –&gt; 适合少量的工作</em></p>
<p><em>Shell Script(脚本) –&gt; 效率高 –&gt; 适合复杂的重复性高的工作</em></p>
<p><em>例如:创建100个用户，单纯输入命令需要执行100次，而Shell脚本只需要几行命令即可完成100个用户的创建</em></p>
<h2 id="4-Shell提示符"><a href="#4-Shell提示符" class="headerlink" title="4.Shell提示符"></a>4.Shell提示符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ = 普通用户, # = root用户(超级管理员)</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">[root@web01 ~]<span class="comment"># useradd jack</span></span><br><span class="line">[root@web01 ~]<span class="comment"># passwd jack</span></span><br><span class="line">Changing password <span class="keyword">for</span> user jack.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is a palindrome</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-Shell基础语法"><a href="#5-Shell基础语法" class="headerlink" title="5.Shell基础语法"></a>5.Shell基础语法</h2><p><em>命令行bash shell，为用户提供输入，执行命令的界面</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令  选项  参数</span></span><br><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令: 整条shell命令的主体</span></span><br><span class="line"><span class="comment">#选项: 用于调节命令的具体功能</span></span><br><span class="line">    <span class="comment">#以 “-”引导短格式选项（单个字符），例如“-l”</span></span><br><span class="line">    <span class="comment">#以“--”引导长格式选项（多个字符），例如“--color”</span></span><br><span class="line">    <span class="comment">#多个短格式选项可以写在一起，只用一个“-”引导，例如“-al”</span></span><br><span class="line"><span class="comment">#参数: 命令操作的对象，如文件、目录名等</span></span><br><span class="line"><span class="comment"># 命令必须开头， 选项和参数位置可以发生变化</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Bash-Shell基本特性"><a href="#2-Bash-Shell基本特性" class="headerlink" title="2.Bash Shell基本特性"></a>2.Bash Shell基本特性</h1><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a><em>1.命令补全</em></h3><p><em>当时用windows查找一个目录层级特别多的文件时，打开的效率会非常慢，但如果使用linux查找一个目录层级特别多的文件时，可以通过tab键快速的补全</em></p>
<p><em>PS:tab键可以实现命令补全，路径补全，在实际生产中tab补全往往是我们使用的最多的, 因为可以减少执行命令以及路径出错率.</em></p>
<h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a><em>2.命令快捷键</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+a <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">ctrl+e <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">ctrl+c <span class="comment">#终止前台运行的程序</span></span><br><span class="line">ctrl+d <span class="comment">#在shell中，ctrl+d表示退出当前shell</span></span><br><span class="line">ctrl+z <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">ctrl+l <span class="comment">#清屏，和clear命令等效</span></span><br><span class="line">ctrl+k <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">ctrl+u <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">ctrl+r <span class="comment">#搜索历史命令，利用关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在命令行前加面加 &quot;#&quot; 则该命令不会被执行，一般用作注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-历史命令history"><a href="#3-历史命令history" class="headerlink" title="3.历史命令history"></a><em>3.历史命令history</em></h3><p><em>-w 保存命令历史到历史文件<br> -c 清空命令历史记录, 不会情况文件<br> -d 删除命令历史的第 N 条行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用双 !! 可执行上一条执行过的命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls</span></span><br><span class="line">lucifer.com</span><br><span class="line">[root@lucifer ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.输入!6, 执行history命令历史中第 6 行命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !6</span></span><br><span class="line">touch lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用!cat, 调用history命令历史最近一次执行过的cat命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line"><span class="comment">#调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 &quot;.&quot;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"><span class="comment">#第二种方式, 输入!$</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="4-历史别名"><a href="#4-历史别名" class="headerlink" title="4.历史别名"></a><em>4.历史别名</em></h3><p><em>命令别名将用户经常使用的复杂命令简单化, 可以用<code>&quot;alias 别名名称=命令&quot;</code>命令创建属于自己的命令别名, 若要取消一个命令别名，则是用<code>unalias 别名名称</code>命令。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.定义临时别名, wk为查看eth0网卡别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias wk=&#x27;ifconfig&#x27;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># wk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.如果定义命令本身, 会执行什么?</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias ifconfig=&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">    <span class="comment">#绝对路径执行, 调用命令本身</span></span><br><span class="line">    [root@lucifer ~]<span class="comment"># /sbin/ifconfig</span></span><br><span class="line">    <span class="comment">#通过\转义字符, 调用命令本身</span></span><br><span class="line">    [root@WebServer ~]<span class="comment"># \ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.取消别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># unalias ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.永久生效，/etc/bashrc</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;alias ifconfig=&#x27;ifconfig eth0&#x27;&quot; &gt;&gt; /etc/bashrc</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Bash-Shell获取帮助"><a href="#3-Bash-Shell获取帮助" class="headerlink" title="3.Bash Shell获取帮助"></a>3.Bash Shell获取帮助</h1><h3 id="1-命令-–help帮助"><a href="#1-命令-–help帮助" class="headerlink" title="1.命令 –help帮助"></a><em>1.命令 –help帮助</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@lucifer ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@lucifer ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@web01 ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@web01 ~]<span class="comment"># ls</span></span><br><span class="line">2019-03-28_file.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-命令man手册"><a href="#2-命令man手册" class="headerlink" title="2.命令man手册"></a><em>2.命令man手册</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#man ls #查看ls命令手册</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Linux命令大全传送门"><a href="#3-Linux命令大全传送门" class="headerlink" title="3.Linux命令大全传送门"></a><em>3.Linux命令大全传送门</em></h3><p><em>linux命令大全： <a href="https://man.linuxde.net/">https://man.linuxde.net/</a></em></p>
<p><em>linux命令手册：<a href="http://linux.51yip.com/">http://linux.51yip.com/</a></em></p>
<h1 id="4-Bash-Shell命令流程"><a href="#4-Bash-Shell命令流程" class="headerlink" title="4.Bash Shell命令流程"></a>4.Bash Shell命令流程</h1><h3 id="1-当我们执行一个命令-整个命令执行流程如下"><a href="#1-当我们执行一个命令-整个命令执行流程如下" class="headerlink" title="*1.当我们执行一个命令, 整个命令执行流程如下:"></a>*1.当我们执行一个命令, 整个命令执行流程如下:</h3><ol>
<li>判断命令是否通过绝对路径执行</li>
<li>判断命令是否存在alias别名</li>
<li>判断用户输入的是内部命令还是外部命令</li>
<li>Bash内部命令直接执行，外部命令检测是否存在缓存</li>
<li>通过PATH路径查找命令，有执行，无报错*</li>
</ol>
<h3 id="2-什么是内部命令，什么是外部命令"><a href="#2-什么是内部命令，什么是外部命令" class="headerlink" title="2.什么是内部命令，什么是外部命令"></a><em>2.什么是内部命令，什么是外部命令</em></h3><p> <em>内部命令: shell程序自带的命令。<br> 外部命令: 在系统PATH变量的某个路径下的可执行程序。</em></p>
<h3 id="3-如何检查用户输入的命令是内部命令还是外部命令"><a href="#3-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="3.如何检查用户输入的命令是内部命令还是外部命令"></a><em>3.如何检查用户输入的命令是内部命令还是外部命令</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line">[root@linux-node1 ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br></pre></td></tr></table></figure>

<p><em>4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p><em>PS: PATH由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找</em></p>
<p><em>5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意: 命令缓存hash需要注意如下情况:</span></span><br><span class="line">1.只要执行外部命令1次就会对该命令进行缓存</span><br><span class="line">2.如果将命令移动了位置，该如何执行</span><br><span class="line">    a.使用绝对路径执行</span><br><span class="line">    b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<h3 id="命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下"><a href="#命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下" class="headerlink" title="命令执行流程总结: 当我们执行了一个ping命令之后, 整个命令执行的流程步骤如下:"></a><em>命令执行流程总结: 当我们执行了一个<code>ping</code>命令之后, 整个命令执行的流程步骤如下:</em></h3><p><em>1) 检查执行的命令是否使用的是绝对路径执行的。<br> 2) 检查ping命令是否存在alias别名<br> 3) 检查ping命令是内部命令还是外部命令<br> 4) 如果是内部命令Bash直接执行，如果是外部命令，首先检查Hash缓存，存在则直接调取<br> 5) 如果该命令不存在Hash缓存，则通过PATH路径进行逐行查找该命令所在的位置<br> 6) 如果PATH路径没有查找到该命令所在的路径，则返回错误码。command not found</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>Bash -</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker发展史</title>
    <url>/2021/08/16/Docker%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">原文连接:</span><br><span class="line">	https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14017860</span>.html</span><br></pre></td></tr></table></figure>

<h1 id="一-Docker的历史"><a href="#一-Docker的历史" class="headerlink" title="一.Docker的历史"></a>一.Docker的历史</h1><h2 id="1-Docker技术开源，IT界的福音"><a href="#1-Docker技术开源，IT界的福音" class="headerlink" title="1.Docker技术开源，IT界的福音"></a>1.Docker技术开源，IT界的福音</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">2010</span>年，几个大胡子年轻人在旧金山成立了一家做PaaS平台的公司，起名为<span class="string">&quot;dotCloud&quot;</span>，该公司主要是基于PaaS平台为开发者或开发商提供技术服务。他们提供了对多种运行环境支持，如Java，Python，Ruby，Node.js等。</span><br><span class="line"></span><br><span class="line">　　PaaS的概念虽好，但是由于认知、理念和技术的局限性，市场的接受度并不高，市场的规模也不够大。</span><br><span class="line"></span><br><span class="line">　　除此之外，还有巨头不断进场搅局，IBM的蓝云，微软的Azure，Amazon的EC2，Google的GAE，VMware的Cloud Foundry等等，可谓强敌环伺，而且强敌都不差钱，想玩多久就玩多久，想玩多大玩多大。</span><br><span class="line"></span><br><span class="line">　　在这种情况下，虽然dotCloud在<span class="number">2011</span>年初拿到了<span class="number">1000</span>万美元的融资，但依然举步维艰。这可能叫生不逢时吧，在PaaS领域有太多的巨头和大企业了。</span><br><span class="line"></span><br><span class="line">　　有一天dotCloud的创始人Solomon Hykes就召集了公司核心开发人员，商量准备开源Docker技术。因此，在<span class="number">2013</span>年<span class="number">3</span>月，Docker正式以开源软件形式在pycon网站(见下图)首次发布了。正式由于这次开源，让容器领域焕发了第二春。</span><br><span class="line"></span><br><span class="line">　　可以说，Docker是继Linux之后，最让人感到兴奋的系统层面的开源项目，据不完全统计，包括dotCloud公司，RedHat，IBM，Google，Cisco，亚马逊及国内华为等，都在为它贡献代码。</span><br><span class="line"></span><br><span class="line">　　在美国，几乎所有的云计算厂商都在拥抱Docker这个生态圈。你知道的，很快Docker技术风靡全球，于是，dotCloud决定改名为Docker Inc(下面简称<span class="string">&quot;Docker&quot;</span>)，全身心投入到Docker的开发中。</span><br><span class="line"></span><br><span class="line">　　更名后的Docker并于<span class="number">2014</span>年<span class="number">8</span>月，Docker宣布把平台即服务的业务dotCloud出售给位于德国柏林的平台即服务提供商cloudControl，自此dotCloud和Docker分道扬镳。</span><br><span class="line">　　</span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//u</span>s.pycon.org<span class="regexp">/2013/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>www.oschina.net<span class="regexp">/news/</span><span class="number">57838</span>/docker-dotcloud</span><br><span class="line">　　　　《docker容器实战：原理、架构与应用》书籍</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB67988db9dd6ff42c2b860da5a3a98bbf?method=download&shareKey=0c22e289e153a4fd412d0d7b509735be" alt="img"></p>
<h2 id="2-容器编排工具Kubernetes诞生"><a href="#2-容器编排工具Kubernetes诞生" class="headerlink" title="2.容器编排工具Kubernetes诞生"></a>2.<strong>容器编排工具Kubernetes诞生</strong></h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Google多年来一直使用容器作为交付应用程序的一种重要方式，且运行有一款名为Borg(在一定程度上借鉴了Omega)的编排工具。当谷歌于<span class="number">2014</span>年<span class="number">3</span>月开始开发Kubernetes时，原本是希望在大规模场景下，将容器化编排管理能力带到大众手中。</span><br><span class="line"></span><br><span class="line">　　这是一个很大的目标，McLuckie，Beda和队友Brendan Burns相信实现这一目标的唯一途径就是将技术开源并围绕其建立一个社区。事实证明他们的这个决定非常正确，但在当时没人能够<span class="number">100</span>％确定。</span><br><span class="line">　　</span><br><span class="line">　　kubernetes很明智的选择当时最流行的容器，没错，就是Docker。Kubernetes对docker容器运行时的支持，迎来了大量的使用用户。</span><br><span class="line">　　</span><br><span class="line">　　Kubernetes于<span class="number">2014</span>年<span class="number">6</span>月<span class="number">6</span>日首次发布。容器化才刚刚崭露头角，这主要得益于Docker，它是向开发人员推广容器化概念的功臣。但在当时，由于刚刚开始发展，因此尚不存在标准的容器管理方法。</span><br><span class="line">　　</span><br><span class="line">　　Kubernetes在以下几个方面堪称独一无二: 　　　　</span><br><span class="line">　　　　(<span class="number">1</span>)它基于谷歌多年来开发的现有技术，Kohn说:<span class="string">&quot;尽管Kubernetes的代码是新的，但它背后的概念、工程和技术都是基于谷歌15年来建立Borg的经验(据说其前身是:&quot;</span>Omega<span class="string">&quot;调度系统，两者各有优势!)&quot;</span>; 　　　　</span><br><span class="line">　　　　(<span class="number">2</span>)Kubernetes从一开始就是为开源而设计的。 </span><br><span class="line"></span><br><span class="line">　　参考链接: 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/snail_ren/</span>article<span class="regexp">/details/</span><span class="number">72636868</span> 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/M2l0ZgSsVc7r69eFdTj/</span>article<span class="regexp">/details/</span><span class="number">80681470</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Docker是一家有野心的公司-陆续推出Docker编排工具三剑客"><a href="#3-Docker是一家有野心的公司-陆续推出Docker编排工具三剑客" class="headerlink" title="3.Docker是一家有野心的公司-陆续推出Docker编排工具三剑客"></a>3.Docker是一家有野心的公司-陆续推出Docker编排工具三剑客</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Swarm:　　　　</span><br><span class="line">	早在<span class="number">2014</span>年底，Docker公司就设计了容器集群的方案组合（也称之为docker编排工具三剑客）：Machine(可快速创建Docker运行环境) + Swarm(是Docker社区原生提供的容器集群管理工具) + Compose(自定义文件格式以运行多容器应用程序的工具)。当然此时的Swarm局限性较大，比如：</span><br><span class="line">　　　　　　(<span class="number">1</span>)没有副本和负载均衡的概念，这导致服务无法高可用；</span><br><span class="line">　　　　　　(<span class="number">2</span>)当然也更不存在什么服务网络管理和跨节点数据存储这些东西；</span><br><span class="line">　　　　　　(<span class="number">3</span>)没有服务模型：集群中服务间关系和启动顺序编排也很复杂，于是就有了下面的SwarmKit的诞生；</span><br><span class="line">　　</span><br><span class="line">　　SwarmKit:</span><br><span class="line">　　　　在<span class="number">2016</span>年<span class="number">2</span>月，Docker公司开始了一个名叫SwarmKit的项目。而恰在Docker <span class="number">1.12</span> RC之前的一段时间，Docker发布了Swarmkit，这是一个独立的、开源的容器编排项目。</span><br><span class="line">　　　　SwarmKit不同于一开始的经典Swarm，它从一开始就重新设计了一套独立的API和模型体系，并且采用独立的客户端命令行工具<span class="string">&quot;swarmctl&quot;</span>。和上面的经典Swarm模型相比，它加入了如下特性：</span><br><span class="line">　　　　　　(<span class="number">1</span>)重新设计的一套独立的API和模型体系;</span><br><span class="line">　　　　　　(<span class="number">2</span>)使用了自己的CLI(swarmd命令负责管理，swarmctl命令用于控制);</span><br><span class="line">　　　　　　(<span class="number">3</span>)节点管理、服务模型更加自然，提供编排和调度服务;</span><br><span class="line">　　　　　　(<span class="number">4</span>)将过去Swarm依赖的外部集群一致性存储组件Etcd的核心部分内置化;</span><br><span class="line">　　　　　　(<span class="number">5</span>)然而此时的SwarmKit并没有提供诸如服务发现、负载均衡和路由等功能。尽管如此，SwarmKit其实已经是我们今天广泛使用的Docker Swarm集群技术的基石。</span><br><span class="line">　　</span><br><span class="line">　　Swarm Mode:</span><br><span class="line">　　　　Swarm Mode则更进一步，它在Docker <span class="number">1.12</span>版本开始为大家所周知，一个docker swarm命令红遍大江南北，这个所谓的Swarm Mode其实就是我们今天所广泛使用的Docker Swarm集群技术。</span><br><span class="line">　　　　然而Swarm Mode并不是一个全新的东西，也并不是一个全新的模式，而是站在SwarmKit的巨人肩膀上发展起来的，是Docker中的一组与集群相关功能的统称而已。</span><br><span class="line">　　　　Docker将SwarmKit的核心模块内嵌于Docker的后台服务之中，通过不同的命令允许使用者同时以<span class="string">&quot;本节点&quot;</span>和<span class="string">&quot;本集群&quot;</span>这两种视角来操作整个集群，增加了集群的管理、节点的管理、服务的管理和编排等等一系列高级特性。</span><br><span class="line">　　　　因此总结一下Swarm Mode就是：</span><br><span class="line">　　　　　　(<span class="number">1</span>)基于Swarmkit编写;</span><br><span class="line">　　　　　　(<span class="number">2</span>)支持服务模型以及服务发现、路由和负载均衡等新功能;</span><br><span class="line">　　　　　　(<span class="number">3</span>)使用Docker原生态的CLI命令;</span><br><span class="line">　　　　　　(<span class="number">4</span>)集成到了Docker engine中(强大的 docker swarm 命令);</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">	https:<span class="regexp">//gi</span>thub.com<span class="regexp">/docker/m</span>achine/</span><br><span class="line">	https:<span class="regexp">//gi</span>thub.com<span class="regexp">/docker/</span>compose</span><br><span class="line">	https:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span><span class="number">7</span>eb93f1e9ed4</span><br><span class="line">	https:<span class="regexp">//</span>www.jianshu.com<span class="regexp">/p/</span><span class="number">3</span>f3c9e0e3db5</span><br></pre></td></tr></table></figure>



<h2 id="4-CoreOS-Rkt-轻量级容器"><a href="#4-CoreOS-Rkt-轻量级容器" class="headerlink" title="4.CoreOS Rkt 轻量级容器"></a>4.CoreOS Rkt 轻量级容器</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">创立于<span class="number">2013</span>年的CoreOS公司旨在为各种规模的企业构建并交付基础设施，帮助其获得与大型软件企业对等的运营环境、实现自动更新与服务器修复，并协助解决停机时间控制、安全性保障以及恢复能力实现等实际难题。</span><br><span class="line"></span><br><span class="line">　　CoreOS公司最早是Docker的支持者，其产品CoreOS操作系统是适用于企业的轻量级容器化的Linux发行版，是Docker生态圈的重要一员。</span><br><span class="line">   </span><br><span class="line">　　随着Docker在容器行业变得逐渐强大，Docker也越来越臃肿，CoreOS公司希望有一个更加开放和中立的容器标准，因此推出了自己的容器计划，很明显CoreOS公司也想在容器方面有一席之地。当然，这样不得不说后面有谷歌和红帽公司在背后做支持。</span><br><span class="line"></span><br><span class="line">　　Rkt诞生于<span class="number">2014</span>年<span class="number">11</span>月末，我在GitHub上发现他在<span class="number">2014</span>年<span class="number">11</span>月<span class="number">27</span>日就发布了<span class="string">&quot;v0.0.0&quot;</span>版本，<span class="string">&quot;v0.1.0&quot;</span>版本是在同年的<span class="number">12</span>月<span class="number">1</span>日发布的。</span><br><span class="line"></span><br><span class="line">　　Rkt是一种与Docker类似的容器引擎，由CoreOS公司主导，得到了Redhat、Google、Vmware等公司的支持，更加专注于解决安全、兼容、执行效率等方面的问题。</span><br><span class="line"></span><br><span class="line">　　就这样，CoreOS公司成为了Docker公司的容器引擎竞争对手。由于Docker已经深入人心，尽管Rkt也很优秀，但很少有人愿意将Docker技术栈迁移到Rkt技术栈。最终容器之战Docker占领了大部分市场。</span><br><span class="line"></span><br><span class="line">　　CoreOS是CoreOS Tectonic的创建者，CoreOS Tectonic是一种企业级Kubernetes平台，可提供自动化操作，实现在私有和公共云提供商之间的可移植性，并且基于开源软件。它还提供CoreOS Quay（企业级容器注册表）。</span><br><span class="line"></span><br><span class="line">　　CoreOS还以帮助推动许多开源技术创新而闻名，这些创新技术是容器化应用程序的核心，包括Kubernetes，它是该领域的主要贡献者。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.openshift.com<span class="regexp">/learn/</span>coreos/</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/en/</span>about<span class="regexp">/press-releases/</span>red-hat-acquire-coreos-expanding-its-kubernetes-and-containers-leadership</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/rkt/</span>rkt/releases</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.sohu.com<span class="regexp">/a/</span><span class="number">216850450</span>_468741</span><br></pre></td></tr></table></figure>



<h2 id="5-容器编排工具之争Kubernetes完胜Docker-Swarm系列"><a href="#5-容器编排工具之争Kubernetes完胜Docker-Swarm系列" class="headerlink" title="5.容器编排工具之争Kubernetes完胜Docker Swarm系列"></a>5.容器编排工具之争Kubernetes完胜Docker Swarm系列</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Docker容器开源<span class="number">1</span>年<span class="number">3</span>个月后，Google公司开源了容器编排系统(Kubernetes,下面简称<span class="string">&quot;K8S&quot;</span>)，当时就以最流行的Docker作为底层容器引擎，因此也为该开源项目带来不少Docker用户，可以说是相当的<span class="string">&quot;吸粉&quot;</span>呀~</span><br><span class="line"></span><br><span class="line">　　Docker公司也在同年年底推出了Swarm以抵抗K8S市场，在后续的<span class="number">3</span>年时间内相继推出了SwarmKit，Swarm Mode集群编排方案。在Swarm被纳入Docker <span class="number">1.12</span>后，Swarm与K8S之争日趋白热化。可以看出Docker公司的野心还是非常大的。</span><br><span class="line"></span><br><span class="line">　　在Docker公司和Google公司进行容器编排工具大战时，CoreOS公司开源的rkt容器引擎主动站队到Kubernetes，达成了合作关系，Kubernetes主力代码贡献者是Google(贡献源码第一)和RedHat(贡献源码第二)公司的人员。</span><br><span class="line"></span><br><span class="line">　　由于CoreOS的主动加入，Kubernetes在<span class="number">2016</span>年<span class="number">7</span>月<span class="number">11</span>日发布的kubernetes <span class="number">1.3</span>版本之后将rkt作为可选容器引擎。但这条在当时的新闻对Docker项目发展几乎没有受到任何影响，Docker早已凭借自身的稳定性和易用性占领了大批的用户！</span><br><span class="line"></span><br><span class="line">　　大概在<span class="number">2017</span>年秋季左右，如下图所示，可惜最终容器编排市场Google占有率(<span class="number">69</span>%)远超过了Docker Swarm容器编排的占有率(<span class="number">18</span>%)，这场容器编排技术大战以Google公司完胜宣告结束。</span><br><span class="line"></span><br><span class="line">　　究其原因并不是Docker公司实力不行，而是由于Google公司在开源K8S之前已经有了<span class="number">15</span>年企业内部的使用容器的经验了(在这<span class="number">15</span>年内已经经历了两代调度系统，即Omega和Borg)。</span><br><span class="line"></span><br><span class="line">　　经理了第一代调度系统:Omega，第二代调度系统:Borg，前两者都是商业的调度系统(即Google公司内部使用)，而第三代调度系统K8S则是开源产品，它借鉴了前两者调度的优势和经验。而Docker集群的集群编排是从<span class="number">2014</span>年年底才开始的，经验尚有不足。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/blog/</span><span class="number">2016</span><span class="regexp">/07/</span>rktnetes-brings-rkt-container-engine-to-kubernetes/</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.cncf.io<span class="regexp">/blog/</span><span class="number">2019</span><span class="regexp">/08/</span><span class="number">16</span><span class="regexp">/cncf-archives-the-rkt-project/</span></span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/moby/m</span>oby</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.sohu.com<span class="regexp">/a/</span><span class="number">221638054</span>_198222</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1ab95f6b2ddb05596dc581b947d54f8b?method=download&shareKey=2b70028265caaef229423afe298a90bc" alt="img"></p>
<h2 id="6-Docker的版本变化"><a href="#6-Docker的版本变化" class="headerlink" title="6.Docker的版本变化"></a>6.Docker的版本变化</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB11eee9ed623cb7fdfc7c8bd9a34364d2?method=download&shareKey=9075113bae2bd6aaec09774fef3fa14c" alt="img"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">我们知道Docker在容器编排技术上败给了K8s，大量市场被Google公司拿下，因此它没有找到一个很好的变现方式。</span><br><span class="line"></span><br><span class="line">　　为了让Docker项目做的更大，目的是吸引更多的投资人，将来未上市就想成为传说中的<span class="string">&quot;独角兽&quot;</span>，此时这家领导层发现<span class="string">&quot;Docker&quot;</span>这个关键词在互联网上非常火，该公司始终无法变现，能否通过这个关键词来引流呢?</span><br><span class="line"></span><br><span class="line">　　于是在<span class="number">2017</span>年<span class="number">3</span>月<span class="number">2</span>日，Docker公司高层决定将docker更名为新的项目moby，其GitHub对应的地址为: <span class="string">&quot;https://github.com/moby/moby&quot;</span>。</span><br><span class="line">   </span><br><span class="line">　　moby项目属于Docker项目的全新上游，docker将是一个隶属于moby的子产品，并将Docker开源版做了双发行版本，即Docker社区版(Community Edition，简称<span class="string">&quot;dockerce&quot;</span>)和Docke企业(Enterprise Edition，简称<span class="string">&quot;dockeEE&quot;</span>)版。</span><br><span class="line"></span><br><span class="line">　　在此期间Docker社区版的使用者对此做法有很多不满。后来Docker的CEO不得不解释说是为了Docker社区版更好的发展。很多程序员估计都心里念叨过:<span class="string">&quot;我信你个鬼，你个糟老头子坏得很!&quot;</span></span><br><span class="line"></span><br><span class="line">　　K8S将Docker社区版合并的代码贡献给CNCF组织，其目的是要告诉大家Google公司不会讲K8S私有化，这样大家方能大胆使用。</span><br><span class="line"></span><br><span class="line">　　现在K8S使用Go语言研发(Docker也是使用Go语言研发)，而k8s目前还处于高速发展期，更新版本迭代是相当之快。</span><br><span class="line">　　</span><br><span class="line">　　最早的时候docker就是一个开源项目，主要由docker公司维护。<span class="number">2017</span>年年初，docker公司将原先的docker项目改名为moby，并创建了docker-ce和docker-ee。这三者的关系是：</span><br><span class="line">　　　　(<span class="number">1</span>)moby是继承了原先的docker的项目，是社区维护的的开源项目，谁都可以在moby的基础打造自己的容器产品;</span><br><span class="line">　　　　(<span class="number">2</span>)docker-ce是docker公司维护的开源项目，是一个基于moby项目的免费的容器产品，GitHub地址如下所示:</span><br><span class="line">　　　　　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/docker/</span>docker-ce</span><br><span class="line">　　　　　　　　如下图所示，需要注意的是: 从Docker <span class="number">20.10</span>版本开始，用于Docker Engine和Docker CLI的软件包直接从其各自的源存储库而不是从此存储库构建。</span><br><span class="line">　　　　　　　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/moby/m</span>oby</span><br><span class="line">　　　　　　　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/docker/</span>cli</span><br><span class="line">　　　　(<span class="number">3</span>)docker-ee是docker公司维护的闭源产品，是docker公司的商业产品，官网地址如下所示:</span><br><span class="line">　　　　　　　　https:<span class="regexp">//</span>www.docker.com/enterprise-edition</span><br><span class="line">   </span><br><span class="line">   docker-ce的发布计划v1.<span class="number">13.1</span>之后，发布计划更改为:</span><br><span class="line">　　　　Edge: 月版本，每月发布一次，命名格式为YY.MM，维护到下个月的版本发布</span><br><span class="line">　　　　Stable: 季度版本，每季度发布一次，命名格式为YY.MM，维护<span class="number">4</span>个月</span><br><span class="line"></span><br><span class="line">　　官方原文:</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.docker.com<span class="regexp">/blog/</span>docker-enterprise-edition/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB66b7ad0030c25e12c2371a0085bef70a?method=download&shareKey=a7b2de6278e3d07dcfd22acc5fb0dc70" alt="img"></p>
<h2 id="7-Rkt和Docker陆续被收购"><a href="#7-Rkt和Docker陆续被收购" class="headerlink" title="7.Rkt和Docker陆续被收购"></a>7.Rkt和Docker陆续被收购</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">CoreOS公司(开源了RKT的母公司)被收购:</span><br><span class="line">　　　　<span class="number">2018</span>年<span class="number">1</span>月<span class="number">31</span>日由Redhat公司宣布收购CoreOS且已签署最终协议，收购价格为<span class="number">2.5</span>亿美元。</span><br><span class="line">　　　　<span class="number">2018</span>年<span class="number">4</span>月<span class="number">16</span>日是发布的最新rkt容器工具，目前该项目已经停止维护，因此生产环境中不推荐大家使用该容器技术。推荐使用主流的容器工具，如Docker，Pouch，podman。</span><br><span class="line">　　Docker公司被收购:</span><br><span class="line">　　　　<span class="number">2019</span>年<span class="number">11</span>月左右，Mirantis收购Docker，但收购金额两家公司貌似很保密，至今未公开发布官方说明。Mirantis表示，今后的重点是Kubernetes。他还承诺将对Swarm的支持再延长至少两年。</span><br><span class="line"></span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//</span>analyticsindiamag.com<span class="regexp">/mirantis-docker-acquisition-enterprise-kubernetes-containers/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBe77069bef21f02263ff45e8e0466247e?method=download&shareKey=9bf0a58ffae900a282b96dee0f3d232e" alt="img"></p>
<h1 id="二-OCI与CNI那些事-往期学员面试官有问到这两个概念的含义哟"><a href="#二-OCI与CNI那些事-往期学员面试官有问到这两个概念的含义哟" class="headerlink" title="二.OCI与CNI那些事(往期学员面试官有问到这两个概念的含义哟~)"></a>二.OCI与CNI那些事(往期学员面试官有问到这两个概念的含义哟~)</h1><h2 id="1-OCI-全称-”Open-Container-Initiative”"><a href="#1-OCI-全称-”Open-Container-Initiative”" class="headerlink" title="1.OCI(全称:”Open Container Initiative”)"></a>1.OCI(全称:”Open Container Initiative”)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">业内最早的容器运行时环境(Runtime)是LXC，起初Docker就是利用LXC做容器管理引擎，但是在创建容器用户空间时不在用LXC的模板现场安装生成容器。　　而是实事先通过一种镜像技术(类似于KVM镜像启动)，把一个操作系统用户空间所要用到的所有组件事先准备编排好打包成一个文件，这个文件Docker称之为镜像文件。　　但后来觉得隔离性差，于是自研了libcontainer组件，不过此时Docker已被CNCF挟持了，当然容器的话语权依旧归Docker公司，这并不是说CNCF组织没有能力定制Docker的标准，只不过他们真那样做就太欺负Docker公司了。　　后来Docker又转型到runC，所以说到目前为止，runC是Docker的独生子。　　随着LXC，LXD，Docker，Rkt等容器运行时环境各有不同，这时候容器运行时的确是有点多了，开放容器倡议(Open Container Initiative，简称<span class="string">&quot;OCI&quot;</span>)由多家公司共同成立的项目，并由linux基金会进行管理。 　　　　OCI是建立围绕容器格式和运行时的开放式行业标准的明确目的的开放式的治理结构。OCI由Docker和其他容器行业的领导者于<span class="number">2015</span>年<span class="number">6</span>月建立，但在<span class="number">2015</span>年<span class="number">12</span>月<span class="number">18</span>日才在GitHub上发布的<span class="string">&quot;v0.1.1&quot;</span>。 　　　　　　所谓container runtime，主要负责的是容器的生命周期的管理。OCI目前包含两个规范：运行时规范(runtime-spec)和映像规范(image-spec)。　　　　(<span class="number">1</span>)OCI的runtime spec标准中对于容器的状态描述，创建，删除，查看等操作进行了定义，以及容器运行时如何运行指定文件系统上的包;　　　　(<span class="number">2</span>)OCI的image-spec标准在定义了如何创建一个OCI运行时可运行的文件系统上的包;　　Docker公司将容器镜像格式和runtime(也就是runc)都捐献给了Open Container Initiative组织。runc是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。　　runc直接与容器所依赖的cgroup<span class="regexp">/linux kernel等进行交互，负责为容器配置cgroup/</span>namespace等启动容器所需的环境，创建启动容器的相关进程。　　　　为了兼容OCI标准，docker也做了架构调整。<span class="number">2016</span>年<span class="number">12</span>月<span class="number">14</span>日，Docker公司宣布将将容器运行时相关的程序从docker daemon剥离出来，形成了containerd。而早在同年的<span class="number">3</span>月份，Docker <span class="number">1.11</span>的Docker Engine里就包含了containerd。　　Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。其架构如下图所示。　　　　参考链接:　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencontainers/</span>runc　　　　https:<span class="regexp">//</span>opencontainers.org<span class="regexp">/　　　　https:/</span><span class="regexp">/github.com/</span>opencontainers<span class="regexp">/runtime-spec/</span>releases<span class="regexp">/tag/</span>v0.<span class="number">1.1</span>　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/xuxinkun/</span>p<span class="regexp">/8036832.html　　　　http:/</span><span class="regexp">/www.dockone.io/</span>article/<span class="number">9400</span></span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/03-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%2520Container%25E5%258F%2591%25E5%25B1%2595%25E5%258F%25B2.assets/1912698-20201227221604504-1079617044.png" alt="img"></p>
<h2 id="2-CNI-全称”Container-Runtime-Interface”"><a href="#2-CNI-全称”Container-Runtime-Interface”" class="headerlink" title="2.CNI(全称”Container Runtime Interface”)"></a>2.CNI(全称”Container Runtime Interface”)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。　　在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为PodSandbox。　　据说是Google(对K8S源码贡献第一)和RedHat(对K8S源码贡献第二)这两家公司有意将Docker边缘化，因此大力扶持由CoreOS公司<span class="number">2014</span>年开源的轻量级rkt容器工具引擎。　　在Kubernetes早期版本，主要是支持docker和rkt两种容器引擎，这需要Kubernetes官方做大量的工作来兼容这两种容器，而兼容会带来很多维护性工作。　　于是在OCI提出一年后，大概在<span class="number">2016</span>年<span class="number">12</span>月<span class="number">19</span>日，即在k8s <span class="number">1.5</span>版本之后，kubernetes推出了自己的运行时接口Container Runtime Interface(下面简称<span class="string">&quot;CRI&quot;</span>)。　　凡是支持CRI皆可作为K8S的底层运行时，CRI接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。　　与OCI不同，CRI与kubernetes的概念更加贴合，并紧密绑定。CRI不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。　　但Docker本身并未实现CRI，因此使用临时解决方案: 其中kubelet是通过CRI接口，调用docker-shim，并进一步调用docker api实现的。但这增大了K8S官方的工作负担，于是在<span class="number">2020</span>年<span class="number">12</span>月宣布将来会弃用docker-shim。　　如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了cri-containerd项目，用以将containerd接入到cri的标准中。　　为了进一步与oci进行兼容，kubernetes还孵化了cri-o，成为了架设在cri和oci之间的一座桥梁。通过这种方式，可以方便更多符合oci标准的容器运行时，接入kubernetes进行集成使用。　　可以预见到，通过cri-o，kubernetes在使用的兼容性和广泛性上将会得到进一步加强。　　大概在<span class="number">2017</span>年左右，Docker将自身的容器运行时(即<span class="string">&quot;containerd&quot;</span>)捐给了CNCF组织(该组织维护的是Kubernetes开源产品)。同年，Docker的网络组建(libnetwork)增加了CNI的支持，同时实现基于IPVS的SERVICE负载均衡。　　来自谷歌、Docker、IBM、中兴通讯和ZJU的工程师们致力于为containerd实现CRI。该项目名为cri containerd，其特性在<span class="number">2017</span>年<span class="number">9</span>月<span class="number">25</span>日发布了完整的v1.<span class="number">0.0</span>-alpha.<span class="number">0</span>版本。　　在<span class="number">2018</span>年<span class="number">5</span>月<span class="number">24</span>日，Kubernetes GA版本正式集成了cri containerd架构。使用cri containerd，用户可以运行Kubernetes集群，使用containerd作为底层运行时，而无需安装Docker。　　<span class="number">2019</span>年<span class="number">8</span>月<span class="number">16</span>日，CNCF组织正式将rkt归档，结束了rkt容器的在Kubernetes的生命周期，在此之前，<span class="number">2018</span>年<span class="number">4</span>月<span class="number">16</span>日是发布的最新rkt容器工具。　　　　参考链接:　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/blog/</span><span class="number">2017</span><span class="regexp">/11/</span>containerd-container-runtime-options-kubernetes<span class="regexp">/　　　　https:/</span><span class="regexp">/kubernetes.io/</span>blog<span class="regexp">/2018/</span><span class="number">05</span><span class="regexp">/24/</span>kubernetes-containerd-integration-goes-ga<span class="regexp">/　　　　https:/</span><span class="regexp">/www.cncf.io/</span>blog<span class="regexp">/2019/</span><span class="number">08</span><span class="regexp">/16/</span>cncf-archives-the-rkt-project<span class="regexp">/　　　　https:/</span><span class="regexp">/github.com/</span>containerd<span class="regexp">/cri　　　　https:/</span><span class="regexp">/github.com/</span>cri-o<span class="regexp">/cri-o 　　　　https:/</span><span class="regexp">/kubernetes.io/</span>blog<span class="regexp">/2016/</span><span class="number">12</span><span class="regexp">/container-runtime-interface-cri-in-kubernetes/</span>　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/blog/</span><span class="number">2020</span><span class="regexp">/12/</span><span class="number">02</span><span class="regexp">/dockershim-faq/</span>　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/kubernetes/</span>enhancements<span class="regexp">/tree/m</span>aster<span class="regexp">/keps/</span>sig-node<span class="regexp">/1985-remove-dockershim　　　　https:/</span><span class="regexp">/github.com/</span>rkt<span class="regexp">/rkt/</span>releases　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/xuxinkun/</span>p<span class="regexp">/8036832.html 　　　　　　　　http:/</span><span class="regexp">/www.dockone.io/</span>article/<span class="number">9400</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB48fb42fa8bb35137453b0207276dde15?method=download&shareKey=117206892bc6f2b3700aac305486e96f" alt="img"></p>
<h1 id="三-2020年Docker被误会的两件事"><a href="#三-2020年Docker被误会的两件事" class="headerlink" title="三.2020年Docker被误会的两件事"></a>三.2020年Docker被误会的两件事</h1><h2 id="1-Docker-Inc-”修改DockerHub定价和TOS"><a href="#1-Docker-Inc-”修改DockerHub定价和TOS" class="headerlink" title="1.Docker Inc.”修改DockerHub定价和TOS"></a>1.Docker Inc.”修改DockerHub定价和TOS</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEBc34450c3b70f956e5f50e072ce2f5f33?method=download&shareKey=182a0859082fb8cc0bb757e39bc0c71e" alt="img"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">对免费用户<span class="regexp">/未登录用户影响:　　　　流量限制:　　　　　　(1)未登录用户每6小时允许PULL 100次;　　　　　　(2)已登录用户每6小时允许PULL 200次;　　　　镜像保留策略:　　　　　　由于Docker Hub保留的镜像总大小已经超过了15PB，其中有4.5PB属于无效镜像。　　　　　　从2020年11月1日开始生效，非活跃(指的是没有push或poll操作的)镜像，保留周期为6个月。清理前，会发送通知告知清理操作。　　　　　　Docker团队也宣传会在Docker Hub上开发一个Dashboard以供用户查阅当前镜像的一个健康程度。　　　　上述消息对企业或个人有什么影响吗？我个人觉得影响不大，因为稍微有一点规模的公司，肯定是有基础架构部门的，里面有专门负责运维的同学，它们肯定不会使用官网的Docker Hub仓库，而是会考虑自建私有的高可用Harbor服务仓库。　　对于Docker Hub，Docker Registry，Harbor的部署或基本使用感兴趣的小伙伴可参考我之前整理的笔记，我这里就不赘述啦~　　　　https:/</span><span class="regexp">/www.cnblogs.com/yi</span>nzhengjie<span class="regexp">/p/</span><span class="number">12231835</span>.html　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie/</span>p<span class="regexp">/12232737.html　　　　https:/</span><span class="regexp">/www.cnblogs.com/yi</span>nzhengjie<span class="regexp">/p/</span><span class="number">12233594</span>.html　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie/</span>p<span class="regexp">/12235258.html　　　　https:/</span><span class="regexp">/www.cnblogs.com/yi</span>nzhengjie<span class="regexp">/p/</span><span class="number">12237263</span>.html　　参考链接:　　　　https:<span class="regexp">//</span>www.docker.com<span class="regexp">/legal/</span>docker-terms-service　　　　https:<span class="regexp">//</span>www.docker.com<span class="regexp">/pricing　　　　https:/</span><span class="regexp">/docs.docker.com/</span>docker-hub<span class="regexp">/builds/</span>　　　　https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/docker-hub/</span>repos/</span><br></pre></td></tr></table></figure>



<h2 id="2-Kubernetes宣布开始进入废弃dockershim支持的倒计时"><a href="#2-Kubernetes宣布开始进入废弃dockershim支持的倒计时" class="headerlink" title="2.Kubernetes宣布开始进入废弃dockershim支持的倒计时"></a>2.Kubernetes宣布开始进入废弃dockershim支持的倒计时</h2><p><img src="https://note.youdao.com/yws/api/personal/file/WEB70afa27be547b9c6580222f932f2cc83?method=download&shareKey=1eb469746002952ca1a5cee14a91f6b2" alt="img"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">由于Docker在设计之初并未考虑集群编排的能力，主要考虑的单机的环境迁移问题。而且在<span class="number">2013</span>年<span class="number">3</span>月dotCloud公司开源时Kubernetes还为诞生呢！　　于是谷歌在<span class="number">2014</span>年<span class="number">3</span>月开始开发Kubernetes，到<span class="number">2014</span>年<span class="number">6</span>月<span class="number">6</span>日首次发布。并与<span class="number">2015</span>年<span class="number">7</span>月发布Kubernetes <span class="number">1.0</span>，并加入CNCF组织。<span class="number">2018</span>年K8S从CNCF基金会毕业。　　Kubernetes选择Docker作为容器运行时，本身就是因为当时它没有其他的选择，而且当时最火的容器引擎就是Docker。选择Docker可以为Kubernetes带来更多的用户。　　　　综上所述，因此Kubernetes在开始时那就对Docker做了内置的支持，使用<span class="string">&quot;dockershim&quot;</span>作为调用Docker的API接口作为临时解决方案，以兼容docker引擎，当然维护该组件是需要耗费资源的。　　　　大概在<span class="number">2017</span>年左右，Docker将的容器运行时(即<span class="string">&quot;containerd&quot;</span>)捐给了CNCF组织(该组织维护的是Kubernetes开源产品)。 　　来自谷歌、Docker、IBM、中兴通讯和ZJU的工程师们致力于为containerd实现CRI。该项目名为cri containerd，其特性在<span class="number">2017</span>年<span class="number">9</span>月<span class="number">25</span>日发布了完整的v1.<span class="number">0.0</span>-alpha.<span class="number">0</span>版本。　　在<span class="number">2018</span>年<span class="number">5</span>月<span class="number">24</span>日，Kubernetes GA版本正式集成了cri containerd架构。使用cri containerd，用户可以运行Kubernetes集群，使用containerd作为底层运行时，而无需安装Docker。 　　由于历史性原因，从<span class="number">2014</span>年至今<span class="number">2020</span>年底，一直维护dockershim，Kubernetes将在下一个版本Kubernetes <span class="number">1.20</span>版本中宣布废弃dockershim(若使用其API只会发出警告信息)，当然你依旧可以使用，直到k8s <span class="number">1.23</span>版本发布才会被正式移除哟~ 　　此外，这些较新的CRI运行时中正在实现与dockershim基本上不兼容的功能，例如cgroups v2和用户名称空间。删除对dockershim的支持将允许在这些领域中进行进一步的开发。　　综上所述:　　　　(<span class="number">1</span>)随着cri-containerd从<span class="number">2018</span>年正式发布以来已经有两年多时间了，基本上也侧面证明了cri-containerd的稳定性，K8S官方任务可以将其作为容器的运行时；　　　　(<span class="number">2</span>)因此以后可以使用符合CRI标准的cri-container作为容器运行时，这样符合<span class="number">2016</span>年其推出的CNI规范！不过最新版本的容器运行时版本架构发生变化，如下图所示。　　　　参考链接:　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/blog/</span><span class="number">2020</span><span class="regexp">/12/</span><span class="number">02</span><span class="regexp">/dockershim-faq/</span>　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/blog/</span><span class="number">2018</span><span class="regexp">/05/</span><span class="number">24</span><span class="regexp">/kubernetes-containerd-integration-goes-ga/</span>　　　　　　　　https:<span class="regexp">//</span>www.bilibili.com<span class="regexp">/video/</span>BV1y5411G7Zf</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB1e2f2b29378b4551d5a312df57361964?method=download&shareKey=9ccad19ee566b7cceeb200f1093d971b" alt="img"></p>
<h2 id="3-dockershim之后的方向如何呢"><a href="#3-dockershim之后的方向如何呢" class="headerlink" title="3.dockershim之后的方向如何呢?"></a>3.dockershim之后的方向如何呢?</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Docker</span>和收购它的公司MIRANTIS会一起维护一个开源的dockershim组件，以便docker作为Kubernetes的容器运行时。　　本次Kubernetes放弃对dockershime的维护到底有什么影响?　　　　(<span class="number">1</span>)对普通用户没有任何影响;　　　　(<span class="number">2</span>)对开发工程师也没用太大影响;　　　　(<span class="number">3</span>)对K<span class="number">8</span>S运维工程师的小伙伴需要注意：　　　　　　　　a)需要考虑将容器运行时考虑换成支持CRI的容器运行时，换句话说，就是不使用原生docker的容器运行时，而是使用集成了CRI Plugin的Containerd运行时;　　　　　　　　b)不使用K<span class="number">8</span>S官方提供的cri-containerd组件，那就只能使用Docker公司和MIRANITS公司共同维护的dockershim组件啦，只不过该组件需要你在K<span class="number">8</span>S集群外部维护而已。　　　　听说K<span class="number">8</span>S放弃dockershim后Podman可以借机上位了?　　　　别听风就是雨，Podman和Docker一样都不兼容Container Runtime Interface(就是我们简称的<span class="string">&quot;CRI&quot;</span>)，此前Docker之所以是K<span class="number">8</span>s的底层容器引擎是因为K<span class="number">8</span>S官方提供了dockershim来调用docker容器的API。　　　　尽管我们可以使用支持kind工具(它是一个CRI工具，下面链接有其官网地址)来使得Docker或者Podman容器引擎来实现CRI功能，估计使用者也寥寥无几吧，毕竟已经有比较成熟的cir-contained容器运行时。　　　　当然，如果我们在使用的容器运行时是cri-o的时候，这时候可以使用docker或者podman来做本地调试。　　参考链接:　　　　https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-<span class="number">2</span>/　　　　https://kind.sigs.k<span class="number">8</span>s.</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBdbba5bbdc3f504884268df5a4499ed12?method=download&shareKey=3ad39a4774f43e421488f0fecf1d9faa" alt="img"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的架构介绍及部署实战</title>
    <url>/2021/08/16/Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-Docker架构分析"><a href="#一-Docker架构分析" class="headerlink" title="一.Docker架构分析"></a>一.Docker架构分析</h1><span id="more"></span>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">如下图所示，Docker采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</span><br><span class="line"></span><br><span class="line">　　客户端和服务器可以运行在同一个 Host 上，客户端也可以通过socket或 REST API与远程的服务器通信。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/get-started/</span>overview/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa01bc568b09ac5222e8645fb75df6d01?method=download&shareKey=49155e3956c3635a15254339ce2332a7" alt="img"></p>
<h2 id="1-Client"><a href="#1-Client" class="headerlink" title="1.Client"></a>1.Client</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">　　Docker客户端，最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</span><br><span class="line">　　    </span><br><span class="line">　　docker支持很多操作(docker命令行工具)，用户也可以通过REST API与服务器通信。</span><br><span class="line">　　    </span><br><span class="line">　　Client和Docker daemon通信可使用<span class="keyword">https</span>/<span class="keyword">http</span>协议进行通信，为了安全起见，默认使用的就是<span class="keyword">https</span>协议。</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker-Host"><a href="#2-Docker-Host" class="headerlink" title="2.Docker-Host"></a>2.Docker-Host</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Docker daemon： 　</span><br><span class="line">　　　　Docker daemon是服务器组件，即Docker守护进程服务器，以Linux后台服务的方式运行。</span><br><span class="line">　　　　Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。默认配置下，Docker daemon只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听（支持IPV4和IPV6）。</span><br><span class="line">       </span><br><span class="line">　　Containers： 　　</span><br><span class="line">　　　　Docker容器，用于加载Docker镜像。换句话说，Docker容器就是Docker镜像的运行实例。我们知道镜像(Image)是只读的，在启动一个Container时，其实就是基于Image来新建一个专用的可写仓供用户使用。</span><br><span class="line">       </span><br><span class="line">　　Image： 　　</span><br><span class="line">　　　　可将Docker镜像看成只读模板(它类似于虚拟机使用的ISO镜像文件)，通过它可以创建Docker容器。例如某个镜像可能包含一个Ubuntu操作系统、一个Apache HTTP Server以及用户开发的Web应用。</span><br><span class="line">　　　　镜像有多种生成方法：</span><br><span class="line">　　　　　　(<span class="number">1</span>)可以从无到有开始创建镜像；</span><br><span class="line">　　　　　　(<span class="number">2</span>)也可以下载并使用别人创建好的现成的镜像</span><br><span class="line">　　　　　　(<span class="number">3</span>)还可以在现有镜像上创建新的镜像</span><br><span class="line">　　　　　　(<span class="number">4</span>)我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作Dockerfile，通过执行docker build &lt;docker-file&gt;命令可以构建出Docker镜像。</span><br><span class="line">　　　　公开的镜像仓库有很多种，如下所示: </span><br><span class="line">　　　　　　Docker官方镜像地址：</span><br><span class="line">　　　　　　　　https:<span class="regexp">//</span>hub.docker.com/。</span><br><span class="line">　　　　　　阿里的docker镜像地址：</span><br><span class="line">　　　　　　　　https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux/</span><br><span class="line">　　　　　　清华大学docker镜像地址：</span><br><span class="line">　　　　　　 https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/docker-ce/</span></span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　生产环境中，我们通常在公司内部部署有私有镜像仓库。如使用Harbor，Docker Registry等等。在后续的文章我们会逐一对其进行讲解。</span><br></pre></td></tr></table></figure>



<h2 id="3-Registry"><a href="#3-Registry" class="headerlink" title="3.Registry"></a>3.Registry</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">我们去构建镜像时，镜像做好之后应该有一个统一存放位置，我们称之为Docker仓库，Registry是存放Docker镜像的仓库（官方默认仓库在<span class="string">&quot;https://hub.docker.com&quot;</span>），Registry分私有和公有两种。</span><br><span class="line"></span><br><span class="line">Images和Registry之间默认使用的时https协议，当然如果你非要指定为<span class="keyword">http</span>协议也是可以的。</span><br><span class="line"></span><br><span class="line">启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像不存在时，其将从Registry中下载该镜像并保存到本地。　　</span><br><span class="line"></span><br><span class="line">Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可自建Registry，也可使用官方的Docker Hub。　　</span><br><span class="line"></span><br><span class="line">Docker Registry中的镜像通常由开发人员制作，而后推送至<span class="string">&quot;公共&quot;</span>或<span class="string">&quot;私有&quot;</span>Registry上保存，供其它人员使用，例如<span class="string">&quot;部署&quot;</span>到生产环境。</span><br><span class="line"></span><br><span class="line">Docker Registry可分为以下几类:　　　　</span><br><span class="line">　　　　Sponsor Registry:</span><br><span class="line">　　　　　　第三方的<span class="keyword">registry</span>，供客户端和Docker社区使用。　　　　</span><br><span class="line">　　　　Mirror Registry:</span><br><span class="line">　　　　　　第三方的<span class="keyword">registry</span>，只让客户使用。　　　　</span><br><span class="line">　　　　Vendor Registry:</span><br><span class="line">　　　　　　由发布Docker镜像的供应商提供的<span class="keyword">registry</span>。　　　　</span><br><span class="line">　　　　Private Registry:</span><br><span class="line">　　　　　　通过设有防火墙和额外的安全层的私有实体提供的<span class="keyword">registry</span>。　　</span><br><span class="line"></span><br><span class="line">Registry包括Repository和Index，详细说明如下：　　　　</span><br><span class="line">	Repository:　　　　　　</span><br><span class="line">		由某特定的docker镜像的所有迭代版本组成的镜像仓库；</span><br><span class="line">		一个Registry中可以存在多个Repository：　　　　　　　　</span><br><span class="line">		Repository可分为<span class="string">&quot;顶层仓库&quot;</span>和<span class="string">&quot;用户仓库&quot;</span>；　　　　　　　　</span><br><span class="line">		用户仓库名称格式为<span class="string">&quot;用户名/仓库名&quot;</span>。　　　　　　</span><br><span class="line">		每个仓库可以包含多个Tag(标签)，每个标签对应一个镜像；　　　　</span><br><span class="line">	Index：　　　　　　</span><br><span class="line">		维护用户账户，镜像的校验以及公共命名空间的信息；　　　　　　</span><br><span class="line">		相当于为Registry提供了一个完成用户认证等功能的检索接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-镜像名称判断"><a href="#4-镜像名称判断" class="headerlink" title="4.镜像名称判断"></a>4.镜像名称判断</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">官方仓库:</span><br><span class="line">	官方镜像:</span><br><span class="line">       	nginx:<span class="number">1.20</span>.<span class="number">1</span></span><br><span class="line">       用户上传镜像:</span><br><span class="line">       	jasonyin2020/oldboyedu_birds:v1</span><br><span class="line">       	</span><br><span class="line">第三方仓库:</span><br><span class="line">	用户上传镜像:</span><br><span class="line">		tuv7rqqq.mirror.aliyuncs.com<span class="regexp">/library/</span>nginx:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa2dca432a23a34bf51e0cb222e0b10a9?method=download&shareKey=2771ec0ea3561d364fb9c4f25cdc0c4e" alt="image-20210609221448005"></p>
<h2 id="5-docker、containerd的关系"><a href="#5-docker、containerd的关系" class="headerlink" title="5.docker、containerd的关系"></a>5.docker、containerd的关系</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">为了防止docker一家独大，docker当年的实现被拆分出了几个标准化的模块，标准化的目的是模块是可被其他实现替换的，不由任何一个厂商控制。</span><br><span class="line"></span><br><span class="line">docker由docker-client,dockerd,containerd,docker-shim,runc组成，所以containerd是docker的基础组件之一，下面是从containerd引过来的一张图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>containerd.io/</span><br><span class="line">	https:<span class="regexp">//</span>cloud.tencent.com<span class="regexp">/document/</span>product<span class="regexp">/457/</span><span class="number">35747</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc326e984db898a397b4bf7f6344bc087?method=download&shareKey=1d02f5bdfca71f0f817a5597b3ab67be" alt="image-20210624151140220"></p>
<h1 id="二-部署docker环境"><a href="#二-部署docker环境" class="headerlink" title="二.部署docker环境"></a>二.部署docker环境</h1><h2 id="1-关闭并禁用防火墙"><a href="#1-关闭并禁用防火墙" class="headerlink" title="1.关闭并禁用防火墙"></a>1.关闭并禁用防火墙</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># </span></span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line">Removed symlink <span class="regexp">/etc/</span>systemd<span class="regexp">/system/mu</span>lti-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



<h2 id="2-停用并禁用selinux"><a href="#2-停用并禁用selinux" class="headerlink" title="2.停用并禁用selinux"></a>2.停用并禁用selinux</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># getenforce </span></span><br><span class="line">Enforcing</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># setenforce 0</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># grep ^SELINUX= /etc/selinux/config</span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># sed -ri s<span class="string">&#x27;#(SELINUX=)enforcing#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># grep ^SELINUX= /etc/selinux/config</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤"><a href="#3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤" class="headerlink" title="3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)"></a>3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-<span class="keyword">client</span> docker-<span class="keyword">client</span>-latest docker-<span class="keyword">common</span> docker-lastest docker-lastest-logrotate docker-logrotate  docker-engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　(<span class="number">1</span>)现在将Docker Engine软件包称为docker-ce，较旧的Docker Engine版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项，因为新老docker版本并不相互兼容哟;</span><br><span class="line">　　(<span class="number">2</span>)如果您在之前没有安装过docker环境，则无需做当前步骤，如果您非要做该步骤，可能会出现如下图所示的情况，属于正常现象！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB11f8ff602a8566ed36e000515ede16b1?method=download&shareKey=68879421244c1cfe332ac2553111b81f" alt="image-20210608230633881"></p>
<h2 id="4-Docker-engine常见的安装方法概述"><a href="#4-Docker-engine常见的安装方法概述" class="headerlink" title="4.Docker engine常见的安装方法概述"></a>4.Docker engine常见的安装方法概述</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">您可以根据需要以不同的方式安装<span class="selector-tag">Docker</span> <span class="selector-tag">Engine</span>：</span><br><span class="line">　　　　(<span class="number">1</span>)大多数用户会 设置<span class="selector-tag">Docker</span>的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法。</span><br><span class="line">　　　　(<span class="number">2</span>)一些用户下载并手动安装<span class="selector-tag">RPM</span>软件包，并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装<span class="selector-tag">Docker</span>的情况下非常有用。</span><br><span class="line">　　　　(<span class="number">3</span>)在测试和开发环境中，一些用户选择使用自动便利脚本来安装<span class="selector-tag">Docker</span>。　　</span><br><span class="line">　　　　</span><br><span class="line">　　　　温馨提示:　　　　</span><br><span class="line">　　　　	本篇博客是基于存储库(需要配置软件源)的方式进行安装，即在新主机上首次安装<span class="selector-tag">Docker</span> <span class="selector-tag">Engine</span>之前，需要设置<span class="selector-tag">Docker</span>存储库。之后，您可以从存储库安装和更新<span class="selector-tag">Docker</span>。</span><br></pre></td></tr></table></figure>



<h2 id="5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟"><a href="#5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟" class="headerlink" title="5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)"></a>5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)备份CentOS官网的软件源</span><br><span class="line">mv <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Base.repo /</span>etc<span class="regexp">/yum.repos.d/</span>CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)下载阿里云的软件源</span><br><span class="line">curl -o <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Base.repo https:/</span><span class="regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="number">7</span>.repo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)非阿里云ESC产品推荐操作该步骤</span><br><span class="line">sed -i -e <span class="string">&#x27;/mirrors.cloud.aliyuncs.com/d&#x27;</span> -e <span class="string">&#x27;/mirrors.aliyuncs.com/d&#x27;</span> <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)生成本地缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　上述的sed命令是可选操作，因为非阿里云ECS用户会出现<span class="string">&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;</span>信息，不影响使用。</span><br><span class="line"></span><br><span class="line">参考链接: 　　</span><br><span class="line">　　https:<span class="regexp">//</span>developer.aliyun.com<span class="regexp">/mirror/</span>centos</span><br></pre></td></tr></table></figure>



<h2 id="6-配置docker-ce的软件源-也称为”存储库”"><a href="#6-配置docker-ce的软件源-也称为”存储库”" class="headerlink" title="6.配置docker-ce的软件源(也称为”存储库”)"></a>6.配置docker-ce的软件源(也称为”存储库”)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)添加docker-ce的软件源</span><br><span class="line">	yum -y install yum-utils</span><br><span class="line">	yum-config-manager --add-repo https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/centos/</span>docker-ce.repo</span><br><span class="line">	</span><br><span class="line">(<span class="number">2</span>)官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line">	yum-config-manager --enable docker-ce-test  <span class="comment"># 可选操作，若不启用并不影响安装docker-ce。</span></span><br><span class="line">	yum-config-manager --enable docker-ce-nightly  <span class="comment"># 可选操作</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)如果您启用了多个Docker存储库，则在未在yum installor yum update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求，这个时候我们也可以来禁用最新的软件源哟~</span><br><span class="line">	yum-config-manager --disable docker-ce-test</span><br><span class="line">	yum-config-manager --disable docker-ce-nightly</span><br><span class="line">	</span><br><span class="line">参考链接:</span><br><span class="line">　　https:<span class="regexp">//</span>developer.aliyun.com<span class="regexp">/mirror/</span>docker-ce</span><br><span class="line">　　https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/engine/i</span>nstall<span class="regexp">/centos/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-安装Docker-Engine和容器"><a href="#7-安装Docker-Engine和容器" class="headerlink" title="7.安装Docker Engine和容器"></a>7.安装Docker Engine和容器</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)若不指定安装的docker版本，则默认安装最新版本的Docker Engine和容器</span><br><span class="line">	yum -<span class="keyword">y</span> install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)要安装特定版本的Docker Engine，请在存储库中列出可用版本，然后选择并安装。返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7此示例中的后缀表示）</span><br><span class="line">	yum <span class="keyword">list</span> docker-<span class="keyword">ce</span> --showduplicates | <span class="keyword">sort</span> -r</span><br><span class="line">	</span><br><span class="line">(<span class="number">3</span>)通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（docker-<span class="keyword">ce</span>）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。其语法格式如下所示。</span><br><span class="line">	yum install docker-<span class="keyword">ce</span>-<span class="symbol">&lt;VERSION_STRING&gt;</span> docker-<span class="keyword">ce</span>-cli-<span class="symbol">&lt;VERSION_STRING&gt;</span> containerd.io  # 安装特定docker版本的语法格式，下面有对应的案例哟~</span><br><span class="line">	yum install docker-<span class="keyword">ce</span>-<span class="number">20.10</span>.<span class="number">7</span> docker-<span class="keyword">ce</span>-cli-<span class="number">20.10</span>.<span class="number">7</span> containerd.io</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	(<span class="number">1</span>)此处我安装了指定的版本，我们可以将<span class="string">&quot;/etc/yum.conf&quot;</span>的<span class="string">&quot;keepcache&quot;</span>进行缓存即可。</span><br><span class="line">	(<span class="number">2</span>)将rpm包进行打包下发到其他节点</span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="built_in">mkdir</span> docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="keyword">find</span> /var/cache/yum/ -<span class="built_in">type</span> <span class="keyword">f</span> -name <span class="string">&quot;*.rpm&quot;</span> | xargs mv -t docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# tar zcf docker_rpm_20.<span class="number">10</span>.tar.gz docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="keyword">ll</span> -h</span><br><span class="line">        总用量 <span class="number">109</span>M</span><br><span class="line">        drwxr-xr-<span class="keyword">x</span>. <span class="number">2</span> root root <span class="number">4.0</span>K <span class="number">6</span>月   <span class="number">9</span> <span class="number">21</span>:<span class="number">00</span> docker_rpm_20.<span class="number">10</span></span><br><span class="line">        -rw-r--r--. <span class="number">1</span> root root <span class="number">109</span>M <span class="number">6</span>月   <span class="number">9</span> <span class="number">21</span>:<span class="number">01</span> docker_rpm_20.<span class="number">10</span>.tar.gz</span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-启动docker守护进程并设置开机自启动"><a href="#8-启动docker守护进程并设置开机自启动" class="headerlink" title="8.启动docker守护进程并设置开机自启动"></a>8.启动docker守护进程并设置开机自启动</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl start docker</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl enable docker</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-查看docker的概要信息"><a href="#9-查看docker的概要信息" class="headerlink" title="9.查看docker的概要信息"></a>9.查看docker的概要信息</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker info</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf6c3528b72d292911894bbc9870fef5d?method=download&shareKey=99086b4d84fdddd4d37f77212b7bb952" alt="image-20210609004903141"></p>
<h2 id="10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"><a href="#10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大" class="headerlink" title="10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"></a>10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span></span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt; <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; EOF</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># cat /etc/docker/daemon.json </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl daemon-reload</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl restart docker</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line"></span><br><span class="line">参考链接:</span><br><span class="line">　　https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6bcc5a2697f963c65c8465b964cd5496?method=download&shareKey=7945584776dbc4cc4e10f100ef5444da" alt="image-20210609005632041"></p>
<h1 id="三-dockers命令自动补全-新手必备"><a href="#三-dockers命令自动补全-新手必备" class="headerlink" title="三.dockers命令自动补全(新手必备)"></a>三.dockers命令自动补全(新手必备)</h1><h2 id="1-为啥能自动补全"><a href="#1-为啥能自动补全" class="headerlink" title="1.为啥能自动补全"></a>1.为啥能自动补全</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Linux系统许多命令都会提供该命令自身的命令补齐脚本，在安装命令时会自动安装自动补齐脚本，如果有的话，该机制在Linux中被称为bash-complete。</span><br><span class="line"></span><br><span class="line">如下图所示，在<span class="regexp">/usr/</span>share<span class="regexp">/bash-completion/</span>completions/ 目录下有许多命令自动补齐的脚本，我们已经安装了docker环境。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa972a0a843128890cc870365f1efd248?method=download&shareKey=d9c896e47d73771c6647529a8d88a43b" alt="image-20210609230730489"></p>
<h2 id="2-安装相关依赖包"><a href="#2-安装相关依赖包" class="headerlink" title="2.安装相关依赖包"></a>2.安装相关依赖包</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">yum -y install bash-completion</span><br><span class="line"></span><br><span class="line"><span class="keyword">source</span> <span class="regexp">/usr/</span>share<span class="regexp">/bash-completion/</span>bash_completion</span><br></pre></td></tr></table></figure>



<h2 id="3-验证补全功能"><a href="#3-验证补全功能" class="headerlink" title="3.验证补全功能"></a>3.验证补全功能</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">如下图所示，当我们输入子命令不知道该如何是好的时候，就可以连续按两下<span class="string">&quot;tab&quot;</span>键即可。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc6c43750a805917820329fbe2a0c2785?method=download&shareKey=2e409065dd18acfc18c2bdd84f424aa1" alt="img">)</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/08/16/ELk1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<h1 id="第1章-Elasticsearch介绍"><a href="#第1章-Elasticsearch介绍" class="headerlink" title="第1章 Elasticsearch介绍"></a>第1章 Elasticsearch介绍</h1><h2 id="1-什么是Lucene"><a href="#1-什么是Lucene" class="headerlink" title="1.什么是Lucene"></a>1.什么是Lucene</h2><p><em>Lucene是一个高性能的java搜索引擎库,操作非常繁琐，需要具备java开发经验。</em><br><em>Elasticsearch是基于Lucene之上包装一层外壳，屏蔽了Lucene的复杂操作，即使不会java语言也可以快速上手</em></p>
<span id="more"></span>

<h2 id="2-什么是全文检索和倒排索引"><a href="#2-什么是全文检索和倒排索引" class="headerlink" title="2.什么是全文检索和倒排索引"></a>2.什么是全文检索和倒排索引</h2><h3 id="2-1-什么是索引"><a href="#2-1-什么是索引" class="headerlink" title="2.1 什么是索引"></a>2.1 什么是索引</h3><p><strong>索引就好比书的目录，</strong><br><em>如果我们想快速查看某个章节，只需要找到目录里相应章节对应的页数即可。<br>通过目录找到章节，通过章节找到页码这个过程就是索引的过程。</em></p>
<p><em>索引的目的就是加快数据搜索的效率。</em></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/71DCCF34934D4634AE4DCE8DE2740F40" alt="img"></p>
<h3 id="2-2-什么是全文检索"><a href="#2-2-什么是全文检索" class="headerlink" title="2.2 什么是全文检索"></a>2.2 什么是全文检索</h3><p><em>先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。<br>根据已有的索引,进行查找.</em></p>
<h3 id="2-3-什么是倒排索引"><a href="#2-3-什么是倒排索引" class="headerlink" title="2.3 什么是倒排索引"></a>2.3 什么是倒排索引</h3><p><em><strong>索引是根据章节找到页数，但是如果我并不知道我要找的内容属于哪个章节，比如我只知道一个关键词，但是不知道这个关键词属于哪个章节。<br>大家可以想一下，我们平时利用搜索引擎搜索的时候是不是也是这种场景呢？<br>比如我们想知道一个电影的名字，但是记不起来具体的名字，只知道部分关键词或者剧情的内容，那这种情景背后如何用技术解决呢？<br>这时候就不得不提到倒排索引了。</strong></em><br>那么什么是倒排索引呢？还是拿书的目录举例子:*</p>
<p><em>正常索引：<br>第1章 Elasticsearch介绍 第10页<br>第2章 Elasticsearch安装配置 第15页<br>第3章 Elasticsearch自定义配置 第20页</em></p>
<p><em>倒排索引:<br>关键词      章节<br>Elasticsearch  第1章 第2章 第3章<br>安装          第2章<br>配置          第2章 第3章<br>自定义      第3章</em></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/5A2A27BF9863402E80B80435CC46EDE1" alt="img"></p>
<h2 id="3-ElasticSearch应用场景"><a href="#3-ElasticSearch应用场景" class="headerlink" title="3.ElasticSearch应用场景"></a>3.ElasticSearch应用场景</h2><p><em>1.搜索: 电商,百科,app搜索,搜索结果高亮显示<br>2.日志分析和数据挖掘,数据展示</em></p>
<h2 id="4-ElasticSearch特点"><a href="#4-ElasticSearch特点" class="headerlink" title="4.ElasticSearch特点"></a>4.ElasticSearch特点</h2><p><em>1.高性能,天然分布式集群<br>2.对运维友好,不需要会java语言,开箱即用,配置文件精简<br>3.功能丰富,社区活跃，版本更新特别的快 2.6 – 8.0 肝帝</em></p>
<h2 id="5-Elasticsearch在电商搜索的实现"><a href="#5-Elasticsearch在电商搜索的实现" class="headerlink" title="5.Elasticsearch在电商搜索的实现"></a>5.Elasticsearch在电商搜索的实现</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat</span><br><span class="line">skuid  name </span><br><span class="line">1    狗粮100kg</span><br><span class="line">2    猫粮50kg</span><br><span class="line">3 猫罐头200g</span><br><span class="line">select * from cat <span class="built_in">where</span> name like <span class="string">&#x27;%&#x27;</span></span><br><span class="line">Elasticsearch:</span><br><span class="line">聚合运算之后得到SKUID:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">拿到ID之后,mysql就只需要简单地<span class="built_in">where</span>查询即可</span><br><span class="line">mysql:</span><br><span class="line">select xx from xxx <span class="built_in">where</span> skuid 1</span><br></pre></td></tr></table></figure>

<h1 id="第2章-Elasticsearch安装"><a href="#第2章-Elasticsearch安装" class="headerlink" title="第2章 Elasticsearch安装"></a>第2章 Elasticsearch安装</h1><h2 id="1-关闭防火墙和Selinux"><a href="#1-关闭防火墙和Selinux" class="headerlink" title="1.关闭防火墙和Selinux"></a>1.关闭防火墙和Selinux</h2><p><strong>防火墙,selinux<br>swap(swapoff -a 或/etc/fstab)</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line">关闭swap分区</span><br><span class="line">内存 2G</span><br><span class="line">systemctl  stop firewalld  iptables </span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld iptables</span><br><span class="line"><span class="comment">#关闭selinux</span></span><br><span class="line">临时生效:</span><br><span class="line">setenforce 0</span><br><span class="line">getenforce</span><br><span class="line">永久生效:</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">SELINUX=disabled</span><br><span class="line"></span><br><span class="line"><span class="comment">#hosts解析</span></span><br><span class="line">10.0.0.80    es01 es01.oldboylinux.com es.oldboylinux.com</span><br></pre></td></tr></table></figure>

<h2 id="2-下载软件"><a href="#2-下载软件" class="headerlink" title="2.下载软件"></a>2.下载软件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#7.9.3  讲课</span></span><br><span class="line"><span class="comment">#7.14.0 课下</span></span><br><span class="line">mkdir /data/soft -p</span><br><span class="line"><span class="built_in">cd</span> /data/soft/</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.9.3-x86_64.rpm</span><br></pre></td></tr></table></figure>

<h2 id="3-安装jdk"><a href="#3-安装jdk" class="headerlink" title="3.安装jdk"></a>3.安装jdk</h2><p><em><strong>对于Elasticsearch7.0之后的版本不需要再独立的安装JDK了，软件包里已经自带了最新的JDK，所以直接启动即可。</strong></em></p>
<h2 id="3-安装ES"><a href="#3-安装ES" class="headerlink" title="3.安装ES"></a>3.安装ES</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh elasticsearch-7.9.3-x86_64.rpm </span><br></pre></td></tr></table></figure>

<h2 id="4-启动并检查"><a href="#4-启动并检查" class="headerlink" title="4.启动并检查"></a>4.启动并检查</h2><p><strong>安装后启动es,检查当前环境是否满足es要求</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> elasticsearch.service</span><br><span class="line">systemctl start elasticsearch.service</span><br><span class="line">netstat -lntup|grep 9200</span><br><span class="line">curl 127.0.0.1:9200</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/09CE4F6C9C4644CBBD1882ED607CF28D" alt="img"></p>
<h1 id="第3章-Elasticsearch自定义配置"><a href="#第3章-Elasticsearch自定义配置" class="headerlink" title="第3章 Elasticsearch自定义配置"></a>第3章 Elasticsearch自定义配置</h1><h2 id="1-查看ES有哪些配置"><a href="#1-查看ES有哪些配置" class="headerlink" title="1.查看ES有哪些配置"></a>1.查看ES有哪些配置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/etc/elasticsearch/elasticsearch.yml   <span class="comment">#es核心配置文件 主配置文件</span></span><br><span class="line">/etc/elasticsearch/jvm.options      <span class="comment">#jvm内存信息配置 初始内存用多少 最大内存用多少</span></span><br><span class="line">/etc/elasticsearch/log4j2.properties   <span class="comment">#java 日志配置文件</span></span><br><span class="line">/etc/elasticsearch/role_mapping.yml <span class="comment">#用户与角色配置文件</span></span><br><span class="line">/etc/elasticsearch/roles.yml  <span class="comment">#用户与角色配置文件</span></span><br><span class="line">/etc/elasticsearch/users    <span class="comment">#用户与角色配置文件</span></span><br><span class="line">/etc/elasticsearch/users_roles   <span class="comment">#用户与角色配置文件</span></span><br><span class="line">/etc/init.d/elasticsearch        <span class="comment">#es服务管理脚本</span></span><br><span class="line">/etc/sysconfig/elasticsearch      <span class="comment">#es环境变量</span></span><br><span class="line">/usr/lib/sysctl.d/elasticsearch.conf  <span class="comment">#内核的配置文件 vm.max_map_count=262144</span></span><br><span class="line">/usr/lib/systemd/system/elasticsearch.service  <span class="comment">#systemctl 启动/开机自启动.... 配置文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root@node-51 ~]<span class="comment"># rpm -qc elasticsearch</span></span><br><span class="line">/etc/elasticsearch/elasticsearch.yml <span class="comment">#主配置文件</span></span><br><span class="line">/etc/elasticsearch/jvm.options <span class="comment">#JVM配置文件</span></span><br><span class="line">/etc/init.d/elasticsearch <span class="comment">#init启动脚本</span></span><br><span class="line">/etc/sysconfig/elasticsearch <span class="comment">#环境变量文件</span></span><br><span class="line">/usr/lib/sysctl.d/elasticsearch.conf <span class="comment">#内核参数文件</span></span><br><span class="line">/usr/lib/systemd/system/elasticsearch.service  <span class="comment">#systemd启动文件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-自定义配置文件"><a href="#2-自定义配置文件" class="headerlink" title="2.自定义配置文件"></a>2.自定义配置文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /etc/elasticsearch/elasticsearch.yml /opt/</span><br><span class="line">cat &gt; /etc/elasticsearch/elasticsearch.yml &lt;&lt; <span class="string">&#x27;EOF&#x27;</span>  </span><br><span class="line">node.name: es01.oldboylinux.com</span><br><span class="line">path.data: /var/lib/elasticsearch</span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch</span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span></span><br><span class="line">network.host: 10.0.0.80,127.0.0.1</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>]</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>配置文件解释:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">node.name: node-1    <span class="comment">#节点名称</span></span><br><span class="line">path.data: /var/lib/elasticsearch <span class="comment">#数据目录</span></span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch <span class="comment">#日志目录</span></span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span> <span class="comment">#锁定内存</span></span><br><span class="line">network.host: 10.0.0.51,127.0.0.1 <span class="comment">#监听地址</span></span><br><span class="line">http.port: 9200 <span class="comment">#端口</span></span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;10.0.0.51&quot;</span>] <span class="comment">#发现节点</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;10.0.0.51&quot;</span>] <span class="comment">#集群初始化节点</span></span><br></pre></td></tr></table></figure>

<h2 id="3-重启服务"><a href="#3-重启服务" class="headerlink" title="3.重启服务"></a>3.重启服务</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart elasticsearch.service </span><br></pre></td></tr></table></figure>

<h2 id="4-解决内存锁定失败"><a href="#4-解决内存锁定失败" class="headerlink" title="4.解决内存锁定失败"></a>4.解决内存锁定失败</h2><p><strong>重启后查看日志发现提示内存锁定失败</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[2021-08-10T12:22:58,184][ERROR][o.e.b.Bootstrap     ] [es01.oldboylinux.com] node validation exception</span><br><span class="line">[1] bootstrap checks failed</span><br><span class="line">[1]: memory locking requested <span class="keyword">for</span> elasticsearch process but memory is not locked</span><br></pre></td></tr></table></figure>

<p><strong>官网解决方案</strong>： <strong><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setting-system-settings.html#systemd">https://www.elastic.co/guide/en/elasticsearch/reference/current/setting-system-settings.html#systemd</a></strong></p>
<p><strong>解决命令</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl edit elasticsearch</span><br><span class="line">[Service]</span><br><span class="line">LimitMEMLOCK=infinity</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart elasticsearch.service</span><br></pre></td></tr></table></figure>

<h1 id="第4章-Elasticsearch插件安装"><a href="#第4章-Elasticsearch插件安装" class="headerlink" title="第4章 Elasticsearch插件安装"></a>第4章 Elasticsearch插件安装</h1><h2 id="1-elasticsearch-head介绍"><a href="#1-elasticsearch-head介绍" class="headerlink" title="1.elasticsearch-head介绍"></a>1.elasticsearch-head介绍</h2><p><em><strong>官方地址</strong></em>：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
<p><em><strong>elasticsearch-head是一款用来管理Elasticsearch集群的第三方插件工具。</strong></em><br><em>elasticsearch-Head插件在5.0版本之前可以直接以插件的形式直接安装，但是5.0以后安装方式发生了改变，需要nodejs环境支持，或者直接使用别人封装好的docker镜像，更推荐的是谷歌浏览器的插件。</em></p>
<h2 id="2-elasticsearch-head的三种安装方式"><a href="#2-elasticsearch-head的三种安装方式" class="headerlink" title="2.elasticsearch-head的三种安装方式"></a>2.elasticsearch-head的三种安装方式</h2><p><em>1.npm安装方式       #下载源码,编译,nodejs运行 部分公司使用<br>2.docker安装       #方便 根据已经制作好的es-head插件的容器,下载,运行<br>3.google浏览器插件（推荐） #安装谷歌浏览器插件,直接访问es</em></p>
<h3 id="2-1-docker安装elasticsearch-head"><a href="#2-1-docker安装elasticsearch-head" class="headerlink" title="2.1 docker安装elasticsearch-head"></a>2.1 docker安装elasticsearch-head</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 9100:9100 mobz/elasticsearch-head:7 </span><br></pre></td></tr></table></figure>

<h3 id="2-2-npm安装elasticsearch-head"><a href="#2-2-npm安装elasticsearch-head" class="headerlink" title="2.2 npm安装elasticsearch-head"></a>2.2 npm安装elasticsearch-head</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum/apt</span><br><span class="line"></span><br><span class="line">pip install <span class="comment">#python软件包</span></span><br><span class="line">npm install <span class="comment">#nodejs 软件包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /opt/</span><br><span class="line">wget https://nodejs.org/dist/v12.13.0/node-v12.13.0-linux-x64.tar.xz</span><br><span class="line">tar xf node-v12.13.0-linux-x64.tar.xz</span><br><span class="line">mv node-v12.13.0-linux-x64 node</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/opt/node/bin&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">npm -v</span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/mobz/elasticsearch-head.git</span><br><span class="line"><span class="built_in">cd</span> elasticsearch-head</span><br><span class="line"></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">cnpm install</span><br><span class="line">cnpm run start</span><br></pre></td></tr></table></figure>

<p><strong>修改Elasticsearch配置文件，添加如下参数并重启:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准许es 被跨域访问</span></span><br><span class="line">http.cors.enabled: <span class="literal">true</span></span><br><span class="line">http.cors.allow-origin: <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-es-head谷歌浏览器插件安装"><a href="#2-3-es-head谷歌浏览器插件安装" class="headerlink" title="2.3 es-head谷歌浏览器插件安装"></a>2.3 es-head谷歌浏览器插件安装</h3><p><strong>更多工具–&gt;拓展程序–&gt;开发者模式–&gt;选择解压缩后的插件目录</strong></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/64D443BCC4D04BCC92D40B2A6C3964E5" alt="img"></p>
<h1 id="第5章-kibana安装"><a href="#第5章-kibana安装" class="headerlink" title="第5章 kibana安装"></a>第5章 kibana安装</h1><h2 id="1-安装kibana"><a href="#1-安装kibana" class="headerlink" title="1.安装kibana"></a>1.安装kibana</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh kibana-7.9.3-x86_64.rpm </span><br></pre></td></tr></table></figure>

<h2 id="2-配置kibana"><a href="#2-配置kibana" class="headerlink" title="2.配置kibana"></a>2.配置kibana</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@es01 /soft]<span class="comment"># grep &#x27;^[a-Z]&#x27; /etc/kibana/kibana.yml</span></span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: <span class="string">&quot;10.0.0.80&quot;</span></span><br><span class="line">server.name: <span class="string">&quot;oldboy-kibana&quot;</span></span><br><span class="line">elasticsearch.hosts: [<span class="string">&quot;http://10.0.0.80:9200&quot;</span>]</span><br><span class="line">kibana.index: <span class="string">&quot;.kibana&quot;</span></span><br><span class="line">logging.dest: /var/<span class="built_in">log</span>/kibana/kibana.log</span><br><span class="line">i18n.locale: <span class="string">&quot;zh-CN&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-启动kibana"><a href="#3-启动kibana" class="headerlink" title="3.启动kibana"></a>3.启动kibana</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start kibana</span><br></pre></td></tr></table></figure>



<h2 id="4-检查测试"><a href="#4-检查测试" class="headerlink" title="4.检查测试"></a>4.检查测试</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@es01 /soft]<span class="comment"># ss -lntup |grep 5601</span></span><br><span class="line">tcp  LISTEN   0   128  10.0.0.80:5601  *:* users:((<span class="string">&quot;node&quot;</span>,pid=5358,fd=18))</span><br><span class="line"></span><br><span class="line"><span class="comment">#浏览器 访问 测试</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/5CC8B68B9E224D5CBDBDD41D467B871A" alt="img"></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/28F833C6A3814F86BADCA5E3C2C5A01D" alt="img"></p>
<h1 id="第6章-Elasticsearch插入命令"><a href="#第6章-Elasticsearch插入命令" class="headerlink" title="第6章 Elasticsearch插入命令"></a>第6章 Elasticsearch插入命令</h1><p><strong>进入控制台</strong></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/A07AB8869ED24DD1AC5F8003F2745CD8" alt="img"></p>
<hr>
<p><strong>访问api接口方法</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#curl 指定请求方法</span></span><br><span class="line">GET  查看</span><br><span class="line">POST 上传,新建</span><br><span class="line">PUT  更新</span><br><span class="line">DELETE 删除</span><br><span class="line"></span><br><span class="line"><span class="comment">#kibana 控制台</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#专业调整api接口的工具 Postman</span></span><br></pre></td></tr></table></figure>

<h2 id="1-Elasticsearch数据格式"><a href="#1-Elasticsearch数据格式" class="headerlink" title="1.Elasticsearch数据格式"></a>1.Elasticsearch数据格式</h2><p>**官网地址：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started-index.html</a> **</p>
<p><strong>和MySQL对比:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MySQL术语      Elasticsearch术语</span><br><span class="line">库             索引 index</span><br><span class="line">表             类型 _doc</span><br><span class="line">字段(列)       json数据的key</span><br><span class="line">值            json数据的value</span><br><span class="line">记录(行)       文档 doc</span><br><span class="line"></span><br><span class="line">name  age</span><br><span class="line">lidao  18</span><br><span class="line">huiling 14</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> name: lidao,</span><br><span class="line"> age: 18</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> name: huiling,</span><br><span class="line"> age: 14</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用自定义的ID"><a href="#2-使用自定义的ID" class="headerlink" title="2.使用自定义的ID"></a>2.使用自定义的ID</h2><p><strong>curl命令操作:</strong></p>
<p>-X 指定请求类型<br>-H 修改请求头数据<br>-d 上传数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl 10.0.0.80:9200/_cat/health</span><br><span class="line">curl 10.0.0.80:9200/_cat/</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/C4A2A4A1019A43BA99658BCF7932D577" alt="img"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -XPUT <span class="string">&#x27;http://10.0.0.51:9200/linux/_doc/1&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;: &quot;zhang&quot;, </span></span><br><span class="line"><span class="string">&quot;age&quot;: &quot;29&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> </span><br><span class="line"><span class="comment">#可以直接复制到kibana</span></span><br></pre></td></tr></table></figure>

<p><strong>kibana界面操作：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT linux/_doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>: <span class="string">&quot;29&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /linux/_doc/43</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;lidao996&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>: <span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/B39FDD58193B447CB19C128BF793B99B" alt="img"></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/FCB816F505544A69BED7AF2810A9C57B" alt="img"></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/881AF4C40BD14BCABB0CDED26792831F" alt="img"></p>
<h2 id="3-使用随机ID"><a href="#3-使用随机ID" class="headerlink" title="3.使用随机ID"></a>3.使用随机ID</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;29&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST /linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;lidao007&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-如何保证和mysql数据"><a href="#4-如何保证和mysql数据" class="headerlink" title="4.如何保证和mysql数据"></a>4.如何保证和mysql数据</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql</span></span><br><span class="line">id name age site fav</span><br><span class="line">1 lidao 18 bj linux</span><br><span class="line">2 xiaofei 30 bj xj</span><br><span class="line">3 qinhong 19 bj live</span><br><span class="line">4 oldpang 20 jb sleep</span><br><span class="line"></span><br><span class="line"><span class="comment">#es</span></span><br><span class="line"><span class="comment">#第1个记录---&gt;文档</span></span><br><span class="line">POST /linux/_doc</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:1,</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;lidao&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:18,</span><br><span class="line"><span class="string">&quot;site&quot;</span>:<span class="string">&quot;bj&quot;</span>,</span><br><span class="line"><span class="string">&quot;fav&quot;</span>:<span class="string">&quot;linux&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#第2个记录---&gt;文档</span></span><br><span class="line">POST /linux/_doc</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>:2,</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaofei&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:30,</span><br><span class="line"><span class="string">&quot;site&quot;</span>:<span class="string">&quot;bj&quot;</span>,</span><br><span class="line"><span class="string">&quot;fav&quot;</span>:<span class="string">&quot;xj&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;29&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;it&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;id&quot;</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;ya&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;22&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;SZ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;it&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第7章-Elasticsearch查询命令"><a href="#第7章-Elasticsearch查询命令" class="headerlink" title="第7章 Elasticsearch查询命令"></a>第7章 Elasticsearch查询命令</h1><h2 id="1-创建测试语句"><a href="#1-创建测试语句" class="headerlink" title="1.创建测试语句"></a>1.创建测试语句</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#测试数据</span></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang3&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;22&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;SZ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;ops&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;li4&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;30&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;dev&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;wang5&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;24&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;dev&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhao6&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;35&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;SZ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;devops&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;sun7&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;21&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;ops&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;27&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;BJ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;devops&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST linux/_doc/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;scott&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;25&quot;</span>,</span><br><span class="line"><span class="string">&quot;address&quot;</span>: <span class="string">&quot;SZ&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;dev&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-简单查询"><a href="#2-简单查询" class="headerlink" title="2.简单查询"></a>2.简单查询</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET linux/_search/</span><br></pre></td></tr></table></figure>



<h2 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3.条件查询"></a>3.条件查询</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#term查询 一般根据 数据文档中 某一个键值的内容进行查询 </span></span><br><span class="line">GET linux/_search</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;value&quot;</span>: <span class="string">&quot;zhang3&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET linux/_search</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;job&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;value&quot;</span>: <span class="string">&quot;ops&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-多条件查询"><a href="#4-多条件查询" class="headerlink" title="4.多条件查询"></a>4.多条件查询</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#条件1</span></span><br><span class="line">address是BJ</span><br><span class="line"></span><br><span class="line"><span class="comment">#条件2</span></span><br><span class="line">job是dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#条件3</span></span><br><span class="line">age&gt;=24 &amp;&amp; age&lt;=31</span><br><span class="line"></span><br><span class="line">GET linux/_search</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;bool&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;must&quot;</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;address.keyword&quot;</span>: <span class="string">&quot;BJ&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;job.keyword&quot;</span>: <span class="string">&quot;dev&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;age.keyword&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;gt&quot;</span>: <span class="string">&quot;24&quot;</span>,</span><br><span class="line">      <span class="string">&quot;lt&quot;</span>: <span class="string">&quot;31&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-term-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl-term-query.html</a></p>
<h1 id="第8章-Elasticsearch更新命令"><a href="#第8章-Elasticsearch更新命令" class="headerlink" title="第8章 Elasticsearch更新命令"></a>第8章 Elasticsearch更新命令</h1><h2 id="1-自定义的ID更新"><a href="#1-自定义的ID更新" class="headerlink" title="1.自定义的ID更新"></a>1.自定义的ID更新</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT linux/_doc/1</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: 30,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;it&quot;</span>,</span><br><span class="line"><span class="string">&quot;id&quot;</span>: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-随机ID更新"><a href="#2-随机ID更新" class="headerlink" title="2.随机ID更新"></a>2.随机ID更新</h2><p><strong>创建测试数据</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT linux/_doc/1</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: <span class="string">&quot;30&quot;</span>,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;it&quot;</span>,</span><br><span class="line"><span class="string">&quot;id&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>先根据自定义的Id字段查出数据的随机ID</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET linux/_search/</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line"> <span class="string">&quot;term&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;value&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>取到随机ID后更改数据</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PUT linux/_doc/CVDdknIBq3aq7mPQaoWw</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;tony&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>: 30,</span><br><span class="line"><span class="string">&quot;job&quot;</span>: <span class="string">&quot;it&quot;</span>,</span><br><span class="line"><span class="string">&quot;id&quot;</span>: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第9章-删除"><a href="#第9章-删除" class="headerlink" title="第9章-删除"></a>第9章-删除</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GET linux/_search   <span class="comment">#查询</span></span><br><span class="line">DELETE linux/_doc/43  <span class="comment">#根据_id 进行删除</span></span><br></pre></td></tr></table></figure>

<h1 id="第10章-Elasticsearch集群概念介绍"><a href="#第10章-Elasticsearch集群概念介绍" class="headerlink" title="第10章 Elasticsearch集群概念介绍"></a>第10章 Elasticsearch集群概念介绍</h1><h2 id="1-Elasticsearch集群特点"><a href="#1-Elasticsearch集群特点" class="headerlink" title="1.Elasticsearch集群特点"></a>1.Elasticsearch集群特点</h2><p><em>对运维友好：不需要太多java的知识也可以很方便的维护整个集群。<br>搭建方便：搭建副本非常简单，只需要将新节点加入已有集群即可，会自动同步数据。</em><br><em>自动故障转移：当节点出现故障时，会自动故障转移，将有数据复制到其他正常的节点</em></p>
<h2 id="2-数据分片"><a href="#2-数据分片" class="headerlink" title="2.数据分片"></a>2.数据分片</h2><p><em>主分片: 实际存储的数据,负责读写,粗框的是主分片</em></p>
<p><em>副本分片:  主分片的副本,提供读,同步主分片,细框的是副本分片</em></p>
<h2 id="3-副本"><a href="#3-副本" class="headerlink" title="3.副本"></a>3.副本</h2><p><em>主分片的备份,副本数量可以自定义</em></p>
<h2 id="4-默认分片和副本规则"><a href="#4-默认分片和副本规则" class="headerlink" title="4.默认分片和副本规则"></a>4.默认分片和副本规则</h2><p><em>7.X版本之前默认规则: 1副本，5分片<br>7.x版本之后默认规则: 1副本，1分片</em></p>
<h2 id="5-节点类型"><a href="#5-节点类型" class="headerlink" title="5.节点类型"></a>5.节点类型</h2><p><em>主节点: 管理: 负责调度数据分配到哪个节点<br>数据节点:  实际负责处理数据的节点<br>工作节点-默认: 主节点也是工作节点</em></p>
<h2 id="6-集群健康状态"><a href="#6-集群健康状态" class="headerlink" title="6.集群健康状态"></a>6.集群健康状态</h2><p><em>绿色: 所有数据都完整，且副本数满足<br>黄色: 所有数据都完整，但是副本数不满足<br>红色: 一个或多个索引数据不完整</em></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/580590BC2CDA4C469ACDBE7BCBBCFF12" alt="img"></p>
<h1 id="第11章-Elasticsearch集群部署"><a href="#第11章-Elasticsearch集群部署" class="headerlink" title="第11章: Elasticsearch集群部署"></a>第11章: Elasticsearch集群部署</h1><h2 id="1-部署集群前注意事项"><a href="#1-部署集群前注意事项" class="headerlink" title="1.部署集群前注意事项"></a>1.部署集群前注意事项</h2><p><em><strong>最好是使用干净的环境部署集群，如果以前有单节点的数据，最好备份出来，然后再清空集群数据</strong></em></p>
<h2 id="2-新节点安装java"><a href="#2-新节点安装java" class="headerlink" title="2.新节点安装java"></a>2.新节点安装java</h2><p><em>7.x版本之后不需要单独的安装JDK，软件包自带了JDK</em></p>
<h2 id="3-新节点安装Elasticsearch"><a href="#3-新节点安装Elasticsearch" class="headerlink" title="3.新节点安装Elasticsearch"></a>3.新节点安装Elasticsearch</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh elasticsearch-7.9.1-x86_64.rpm </span><br></pre></td></tr></table></figure>

<h2 id="4-配置内存锁定"><a href="#4-配置内存锁定" class="headerlink" title="4.配置内存锁定"></a>4.配置内存锁定</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl edit elasticsearch.service</span><br><span class="line">[Service]</span><br><span class="line">LimitMEMLOCK=infinity</span><br></pre></td></tr></table></figure>

<h2 id="5-集群配置文件"><a href="#5-集群配置文件" class="headerlink" title="5.集群配置文件"></a>5.集群配置文件</h2><h2 id="0-hosts解析"><a href="#0-hosts解析" class="headerlink" title="0 . hosts解析"></a>0 . hosts解析</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line">127.0.0.1  localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1     localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">172.16.1.5   lb01</span><br><span class="line">172.16.1.6   lb02</span><br><span class="line">172.16.1.7   web01</span><br><span class="line">172.16.1.8   web02</span><br><span class="line">172.16.1.9   web03</span><br><span class="line">172.16.1.31   nfs01</span><br><span class="line">172.16.1.41   backup</span><br><span class="line">172.16.1.51   db01 db01.etiantian.org</span><br><span class="line">172.16.1.61   m01</span><br><span class="line">10.0.0.80    es01 es01.oldboylinux.com es.oldboylinux.com</span><br><span class="line">10.0.0.81    es02 es02.oldboylinux.com</span><br><span class="line">10.0.0.82    es03 es03.oldboylinux.com</span><br></pre></td></tr></table></figure>

<h2 id="5-1-配置文件解释"><a href="#5-1-配置文件解释" class="headerlink" title="5.1 配置文件解释"></a>5.1 配置文件解释</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster.name: oldboy_linux   <span class="comment">#集群名称</span></span><br><span class="line">node.name: node-1 <span class="comment">#节点名称</span></span><br><span class="line">path.data: /var/lib/elasticsearch <span class="comment">#数据目录</span></span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch <span class="comment">#日志目录</span></span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span> <span class="comment">#设置内存锁定</span></span><br><span class="line">network.host: 127.0.0.1,10.0.0.51 <span class="comment">#本地监听地址</span></span><br><span class="line">http.port: 9200 <span class="comment">#本地端口</span></span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;10.0.0.51&quot;</span>,<span class="string">&quot;10.0.0.52&quot;</span>] <span class="comment">#集群节点互相发现的地址，不需要把所有节点IP都写上。</span></span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;10.0.0.51&quot;</span>] <span class="comment">#集群初始化节点，只有创建集群的第一次有用，集群创建后参数失效。</span></span><br></pre></td></tr></table></figure>

<p><img src="%E6%A8%A1%E6%9D%BF.assets/995105CAA37C4B2CAD282C137FE9950D" alt="img"></p>
<h2 id="5-2-node1-es01配置文件"><a href="#5-2-node1-es01配置文件" class="headerlink" title="5.2 node1-es01配置文件:"></a>5.2 node1-es01配置文件:</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@es01 ~]<span class="comment"># grep &#x27;^[a-Z]&#x27; /etc/elasticsearch/elasticsearch.yml</span></span><br><span class="line">cluster.name: oldboy_linux_es</span><br><span class="line">node.name: es01.oldboylinux.com</span><br><span class="line">path.data: /var/lib/elasticsearch</span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch</span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span></span><br><span class="line">network.host: 10.0.0.80,127.0.0.1</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>,<span class="string">&quot;es02.oldboylinux.com&quot;</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="5-3-node2-es02配置文件"><a href="#5-3-node2-es02配置文件" class="headerlink" title="5.3 node2-es02配置文件:"></a>5.3 node2-es02配置文件:</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cluster.name: oldboy_linux_es</span><br><span class="line">node.name: es02.oldboylinux.com</span><br><span class="line">path.data: /var/lib/elasticsearch</span><br><span class="line">path.logs: /var/<span class="built_in">log</span>/elasticsearch</span><br><span class="line">bootstrap.memory_lock: <span class="literal">true</span></span><br><span class="line">network.host: 10.0.0.81,127.0.0.1</span><br><span class="line">http.port: 9200</span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>,<span class="string">&quot;es02.oldboylinux.com&quot;</span>]</span><br><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;es01.oldboylinux.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">cat&gt; /etc/elasticsearch/elasticsearch.yml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">cluster.name: oldboy_linux</span></span><br><span class="line"><span class="string">node.name: node-2</span></span><br><span class="line"><span class="string">path.data: /var/lib/elasticsearch</span></span><br><span class="line"><span class="string">path.logs: /var/log/elasticsearch</span></span><br><span class="line"><span class="string">bootstrap.memory_lock: true</span></span><br><span class="line"><span class="string">network.host: 127.0.0.1,10.0.0.52</span></span><br><span class="line"><span class="string">http.port: 9200</span></span><br><span class="line"><span class="string">discovery.seed_hosts: [&quot;10.0.0.51&quot;,&quot;10.0.0.52&quot;]</span></span><br><span class="line"><span class="string">cluster.initial_master_nodes: [&quot;10.0.0.51&quot;]</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="6-启动"><a href="#6-启动" class="headerlink" title="6.启动"></a>6.启动</h2><p><strong>注意：如果以前单节点有数据，那么先停止运行，然后清空数据</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl stop elasticsearch.service</span><br><span class="line">rm -rf /var/lib/elasticsearch/*</span><br></pre></td></tr></table></figure>

<p><strong>重启命令：</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="7-查看日志"><a href="#7-查看日志" class="headerlink" title="7.查看日志"></a>7.查看日志</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#集群故障日志</span></span><br><span class="line">tail -f /var/<span class="built_in">log</span>/elasticsearch/集群名字.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#es服务相关日志</span></span><br><span class="line">/var/<span class="built_in">log</span>/elasticsearch/elasticsearch.log</span><br></pre></td></tr></table></figure>

<h2 id="8-检查集群"><a href="#8-检查集群" class="headerlink" title="8.检查集群"></a>8.检查集群</h2><p><em>ES-head查看是否有2个节点</em></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/A8CE600330CE40719BFEF90593BA7080" alt="img"></p>
<p><em>kibana 写入数据</em></p>
<h2 id="9-集群注意事项"><a href="#9-集群注意事项" class="headerlink" title="9.集群注意事项"></a>9.集群注意事项</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#01</span></span><br><span class="line">1.插入和读取数据在任意节点都可以执行,效果一样</span><br><span class="line">2.es-head可以连接集群内任一台服务</span><br><span class="line"></span><br><span class="line"><span class="comment">#03.主节点负责读写</span></span><br><span class="line">如果主分片所在的节点坏掉了,副本分片会升为主分片</span><br><span class="line"></span><br><span class="line"><span class="comment">#04.主节点负责调度</span></span><br><span class="line">如果主节点坏掉了,数据节点会自动升为主节点</span><br><span class="line"></span><br><span class="line"><span class="comment">#05.通讯端口</span></span><br><span class="line">默认会有2个通讯端口：9200和9300</span><br><span class="line">9300并没有在配置文件里配置过</span><br><span class="line">如果开启了防火墙并且没有放开9300端口，那么集群通讯就会失败</span><br></pre></td></tr></table></figure>

<h1 id="第12章-Elasticsearch集群扩容"><a href="#第12章-Elasticsearch集群扩容" class="headerlink" title="第12章 Elasticsearch集群扩容"></a>第12章 Elasticsearch集群扩容</h1><h2 id="1-安装java"><a href="#1-安装java" class="headerlink" title="1.安装java"></a>1.安装java</h2><p><em>7.0版本之后不需要单独安装JDK</em></p>
<h2 id="2-安装ES"><a href="#2-安装ES" class="headerlink" title="2.安装ES"></a>2.安装ES</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">rpm -ivh elasticsearch-7.9.1-x86_64.rpm </span><br></pre></td></tr></table></figure>

<h2 id="3-配置内存锁定"><a href="#3-配置内存锁定" class="headerlink" title="3.配置内存锁定"></a>3.配置内存锁定</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl edit elasticsearch.service</span><br><span class="line">[Service]</span><br><span class="line">LimitMEMLOCK=infinity</span><br></pre></td></tr></table></figure>

<h2 id="4-node3集群配置文件"><a href="#4-node3集群配置文件" class="headerlink" title="4.node3集群配置文件"></a>4.node3集群配置文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat&gt; /etc/elasticsearch/elasticsearch.yml &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">cluster.name: oldboy_linux_es          #</span></span><br><span class="line"><span class="string">node.name: es03.oldboylinux.com         #</span></span><br><span class="line"><span class="string">path.data: /var/lib/elasticsearch</span></span><br><span class="line"><span class="string">path.logs: /var/log/elasticsearch</span></span><br><span class="line"><span class="string">bootstrap.memory_lock: true</span></span><br><span class="line"><span class="string">network.host: 127.0.0.1,10.0.0.82        #</span></span><br><span class="line"><span class="string">http.port: 9200</span></span><br><span class="line"><span class="string">discovery.seed_hosts: [&quot;es02.oldboylinux.com&quot;,&quot;es03.oldboylinux.com&quot;] #</span></span><br><span class="line"><span class="string">cluster.initial_master_nodes: [&quot;es01.oldboylinux.com&quot;]</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h2 id="5-添加节点注意"><a href="#5-添加节点注意" class="headerlink" title="5.添加节点注意"></a>5.添加节点注意</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对于新添加的节点来说: </span></span><br><span class="line"><span class="comment">##只需要直到集群内任意一个节点的IP和他自己本身的IP即可</span></span><br><span class="line">discovery.seed_hosts: [<span class="string">&quot;10.0.0.82&quot;</span>,<span class="string">&quot;10.0.0.81&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于以前的节点来说:</span></span><br><span class="line">什么都不需要更改</span><br></pre></td></tr></table></figure>

<h2 id="6-数据分片颜色解释"><a href="#6-数据分片颜色解释" class="headerlink" title="6.数据分片颜色解释"></a>6.数据分片颜色解释</h2><p><em>紫色: 正在迁移<br>黄色: 正在复制<br>绿色: 正常</em></p>
<p><img src="%E6%A8%A1%E6%9D%BF.assets/AD0E5D7A575D47788F2698284F3F0808" alt="img">    </p>
<h2 id="7-集群故障转移实验"><a href="#7-集群故障转移实验" class="headerlink" title="7.集群故障转移实验"></a>7.集群故障转移实验</h2><p><em>1.停掉主节点，观察集群是否正常<br>2.停掉主节点，是否还会选举出新的主节点<br>3.停掉主节点，数据分片的分布会不会发生变化，分片状态会不会发生变化<br>4.停掉主节点，然后在持续的写入数据，等节点恢复之后，会如何处理落后的数据<br>5.3个节点的Elasticsearch集群，极限情况下最多允许坏几台?<br>6.主节点故障，集群健康状态发生什么变化？</em></p>
<p><strong>结论：</strong></p>
<p><em><strong>##01 竞选机制<br>1.如果主节点坏掉了，会从活着的数据节点中选出一台新的主节点</strong></em></p>
<p><em><strong>##02 分片切换 主 与 副<br>2.如果主分片坏掉了，副本分片会升级为主分片</strong></em></p>
<p><em><strong>##03 副本数不足<br>3.如果副本数不满足，会尝试在其他的节点上重新复制一份数据,创建一个新的副本</strong></em></p>
<p><em><strong>##04 修复后重新加入<br>4.修复上线只需要正常启动故障的节点即会自动加入到集群里，并且自动同步数据, 主分片与副本分片分部会变化</strong></em></p>
<p><em><strong>##05 最低节点数量<br>5.7.x版本之后则必须至少2个节点存活集群才能正常工作</strong></em></p>
<p><em><strong>##06 如果中间节点挂了,其他的节点可能无法恢复 需要在配置中添加所有的节点</strong></em></p>
]]></content>
      <categories>
        <category>ELK -</category>
      </categories>
      <tags>
        <tag>ELK -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/2021/07/28/Linuxuser/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.用户基本概述 2.用户相关命令 3.用户扩展知识 3.用户组的管理 4.用户如何提权</p>
<span id="more"></span>
<h1 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h1><p><em><strong>1.什么是用户?</strong></em></p>
<p><em>用户指的是能够正常登录Linux或Windows系统(可以理解为你租了房子，能够正常入驻)<br>F:那Linux与Windows系统的用户有什么区别? Q:本质都是登陆系统，只不过Linux支持多个用户同时登陆。<br>F:难道Windows就不算多用户操作系统吗? Q:其实不是，在Windows系统中可以创建多个用户，但不允许同一时刻多个用户登陆系统，但Linux系统则允许同一时刻多个用户同时登陆，登陆后相互之间操作并不影响。</em></p>
<p><em><strong>2.Linux下的用户有什么用，或者说我们为什么要创建用户？</strong></em></p>
<p><em>1.系统上的每一个进程(运行的程序)，都需要一个特定的用户运行<br>2.通常在公司是使用普通用户管理服务器，因为root权限过大，容易造成故障。</em></p>
<p><em><strong>3.如何查看系统中所存在的用户</strong></em></p>
<p><em>1.查看当前登录的用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@bgx ~]<span class="comment"># id oldboy #查看其它用户的信息</span></span><br><span class="line">uid=1000(oldboy) gid=1000(oldboy) groups=1000(oldboy)</span><br></pre></td></tr></table></figure>

<p><em>2.每一个进程都会由一个用户身份运行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ps aux|less #简单使用一下，不用理解</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure>

<p><em><strong>4.那我们的用户存在哪呢?</strong></em></p>
<p><em>Linux系统会将用户的信息存放在/etc/passwd，记录了用户的信息，但没有密码信息，密码被存放在/etc/shadow中。也就是说这两个文件非常的重要，不要轻易删除与修改。</em></p>
<p><em>1./etc/passwd 配置文件解释如下图，或者man 5 passwd</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/shadow 配置文件解释如下图，或者man 5 shadow</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728213756.png" alt="imageTitle"></p>
<p><em><strong>4.最后我们需要了解下系统对用户的一个约定？(约定娶你，就真的会娶吗？)</strong></em></p>
<table>
<thead>
<tr>
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>超级管理员，最高权限，有着极强的破坏能力</td>
</tr>
<tr>
<td>1~200</td>
<td>系统用户，用来运行系统自带的进程，默认已创建</td>
</tr>
<tr>
<td>201~999</td>
<td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td>
</tr>
<tr>
<td>1000+</td>
<td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td>
</tr>
</tbody></table>
<p><em>PS:在CentOS7系统之前, UID1-499用于系统用户, 而UID 500+则用于普通用户</em></p>
<h1 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h1><p><em>下面我们就围绕着用户的创建、变更、删除等来讲讲涉及到的命令: useradd、usermod、userdel</em></p>
<p><em>1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要创建用户的UID,不允许冲突</span></span><br><span class="line"><span class="comment"># -g 指定要创建用户默认组</span></span><br><span class="line"><span class="comment"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span></span><br><span class="line"><span class="comment"># -d 指定要创建用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要创建用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要创建用户注释信息</span></span><br><span class="line"><span class="comment"># -M 给创建的用户不创建家目录</span></span><br><span class="line"><span class="comment"># -r 创建系统账户，默认无家目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建bgx用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure>

<p><em>2.如何使用usermod命令修改用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要修改用户的UID</span></span><br><span class="line"><span class="comment"># -g 指定要修改用户基本组</span></span><br><span class="line"><span class="comment"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></span><br><span class="line"><span class="comment"># -d 指定要修改用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要修改用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要修改用户注释信息</span></span><br><span class="line"><span class="comment"># -l 指定要修改用户的登陆名</span></span><br><span class="line"><span class="comment"># -L 指定要锁定的用户</span></span><br><span class="line"><span class="comment"># -U 指定要解锁的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.检查此前创建的用户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx:x:5001:503:2019 new student:/home/bgx:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.修改bgx用户uid、gid，附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改bgx用户的注释信息, 用户家目录, 登录shell, 登录名</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /bgx -s /bin/sh -l change_bgx bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否修改成功</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx_xuliangwei:x:6001:5008:2019 new student:/bgx:/bin/sh</span><br><span class="line">[root@bgx ~]<span class="comment"># id change_bgx</span></span><br><span class="line">uid=6001(change_bgx) gid=5008(network_sa) groups=5008(network_sa),503(sa),5009(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /bgx</span></span><br><span class="line">drwx------. 2 bgx_xuliangwei network_sa 4096 2014-09-23 00:13 /bgx</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.锁定用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin change_bgx</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -L change_bgx  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解锁用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -U change_bgx</span></span><br></pre></td></tr></table></figure>

<p>*S: 当然还有很多命令可以查看用户的信息，以下简单列举一些，但都是我们常用，所以了解即可</p>
<ol>
<li>使用finger命名查询用户信息以及登录信息，示例: finger UserName</li>
<li>使用chfn命令修改用户信息，示例: chfn UserName</li>
<li>使用chsh命令修改用户登录Bash Shell，示例: chsh UserName</li>
<li>使用who、whoami、w检查用户登陆情况*</li>
</ol>
<p><em>3.使用userdel命令删除账户</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项 -r 删除用户同时删除它的家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.删除user1用户，但不删除用户家目录和 mail spool</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.-r参数可以连同用户家目录一起删除(慎用)</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure>

<h1 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h1><p><em><strong>1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？</strong></em></p>
<p><em>1.useradd创建用户时，系统会以/etc/login.defs、/etc/defaults/useradd两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖/etc/login.defs、/etc/defaults/useradd文件默认配置，如未指定则使用默认。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@bgx ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      <span class="comment">#把用户的家目录建在/home中。</span></span><br><span class="line">INACTIVE=-1     <span class="comment">#是否启用账号过期停权,-1表示不启用。</span></span><br><span class="line">EXPIRE=         <span class="comment">#账号终止日期,不设置表示不启用。</span></span><br><span class="line">SHELL=/bin/bash <span class="comment">#新用户默认所有的shell类型。</span></span><br><span class="line">SKEL=/etc/skel  <span class="comment">#配置新用户家目录的默认文件存放路径。</span></span><br><span class="line">CREATE_MAIL_SPOOL=yes   <span class="comment">#创建mail文件。</span></span><br></pre></td></tr></table></figure>

<p><em>2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<p><em>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用passwd命令。建议密码复杂度高一些、长度大于10、出现各种特殊字符、无任何规律(不要出现名字，电话，生日等)<br> PS: 注意事项<br> 1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须8位字符<br> 2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用passwd命令修改用户密码</span></span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd oldboy #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.验证如下几项指标</span></span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd Lucifer        #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin xuliangwei    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.系统内置变量生成随机字符串</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@bgx ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span></span><br><span class="line">[root@bgx ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure>

<p><em>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件<a href="https://www.lastpass.com/zh">Lastpass官方网站</a></em></p>
<h1 id="3-用户组的管理"><a href="#3-用户组的管理" class="headerlink" title="3.用户组的管理"></a>3.用户组的管理</h1><p><em><strong>1.什么是用户组？</strong></em></p>
<p><em>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</em></p>
<p><em><strong>2.对于用户来说，组有几种类别？</strong></em></p>
<p><em>基本组，用户只能有一个基本组，创建时可通过-g指定，如未指定则创建一个默认的组(与用户同名)</em></p>
<p><em>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组</em></p>
<p><em><strong>3.那组的信息保存在哪呢？</strong></em></p>
<p><em>组账户信息保存在/etc/group和/etc/gshadow两个文件中。重点关注group</em></p>
<p><em>1./etc/group 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/gshadow 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728211204.png" alt="imageTitle"><br><em>1.使用groupadd命令新增组，groupadd [-g GID] groupname</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建基本组, 不指定gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建基本组, 指定gid为5555</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建系统组，gid从201-999</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure>

<p><em>2.使用groupmod命令新增组</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-g 修改组gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line"><span class="comment">#-n 修改组名称</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure>

<p><em>3.groupdel删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除用户附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无法删除用户基本组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line"><span class="comment">#只有删除用户或者用户变更基本后,方可删除该组</span></span><br></pre></td></tr></table></figure>

<p><em>4.使用gpasswd设置组密码[扩展，可以不会]</em></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># groupadd devops</span></span><br><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> <span class="keyword">group</span> devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter <span class="keyword">new</span> password:</span><br></pre></td></tr></table></figure>

<p><em>5.使用newgrp命令切换基本组身份[扩展，可以不会]</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.检查账户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd xuliangwei</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建新文件,查看文件的属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_roots</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用newgrp切换到devops组</span></span><br><span class="line">[xuliangwei@bgx ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.创建文件，检查属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_test</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 xuliangwei devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure>

<h1 id="4-用户如何提权"><a href="#4-用户如何提权" class="headerlink" title="4.用户如何提权"></a>4.用户如何提权</h1><p><em>往往公司的服务器对外都是禁止root用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？<br> 当我们使用普通用户执行/sbin目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用root用户直接登录系统，同时又保证普通用户能完成日常工作？<br> PS: 我们可以使用如下两种方式: su、sudo<br> 1.su切换用户，使用普通用户登录，然后使用su命令切换到root。优点:简单 缺点:需要知道root密码<br> 2.sudo提权，当需要使用root权限时进行提权，而无需切换至root用户，优点:安全、方便 缺点:复杂</em></p>
<p><em><strong>1.su身份切换</strong></em></p>
<p><em>在使用su切换前，我们需要了解一些预备知识，比如shell分类、环境变量配置文件有哪些</em></p>
<p><em>1.Linux Shell主要分为如下几类<br>交互式shell，等待用户输入执行的命令(终端操作,需要不断提示)<br>非交互式shell，执行shell脚本, 脚本执行结束后shell自动退出<br>登陆shell，需要输入用户名和密码才能进入Shell，日常接触的最多的一种<br>非登陆shell，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</em></p>
<p><em>2.bash shell配置文件介绍(文件主要保存用户的工作环境)<br>个人配置文件：~/.bash_profile ~/.bashrc 。全局配置文件：/etc/profile /etc/profile.d/*.sh /etc/bashrc<br>profile类文件, 设定环境变量, 登陆前运行的脚本和命令。bashrc 类文件, 设定本地变量, 定义命令别名<br>PS: 如果全局配置和个人配置产生冲突，以个人配置为准。</em></p>
<p><em>3.登陆系统后，环境变量配置文件的应用顺序是?</em><br> <em>登录式shell配置文件执行顺序: /etc/profile-&gt;/etc/profile.d/*.sh-&gt;<del>/.bash_profile-&gt;</del>/.bashrc-&gt;/etc/bashrc<br> 非登陆式shell配置文件执行顺序: ~/.bashrc-&gt;/etc/bashrc-&gt;/etc/profile.d/*.sh<br> PS: 验证使用echo在每行添加一个输出即可</em></p>
<p><em>4.说了这么多预备知识，那这些和su命令切换用户有什么关系?<br> su - username属于登陆式shell，su username属于非登陆式shell，区别在于加载的环境变量不一样。<br>普通用户<code>su -</code>可以直接切换至root用户，但需要输入root用户的密码。<br>超级管理员root用户使用<code>su - username</code>切换普通用户不需要输入任何密码。</em> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[xuliangwei@node1 ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@node1 xuliangwei]<span class="comment"># pwd</span></span><br><span class="line">/home/xuliangwei</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[xuliangwei@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.sudo提权</strong></em></p>
<p><em>su命令在切换用户身份时，如果每个普通用户都能拿到root用户的密码，当其中某个用户不小心泄漏了root的密码，那系统会变得非常不安全。为了改进这个问题，从而产生了sudo这个命令。</em></p>
<p><em>其实sudo就相当于给某个普通用户埋下了浩克(hulk)的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</em></p>
<p><em>1.如何快速埋下hulk的种子呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式[先睹为快]</span></span><br><span class="line">[root@node1 ~]<span class="comment"># usermod bgx -G wheel</span></span><br><span class="line">[root@node1 ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@www ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名）       4.命令名</span></span><br><span class="line">bgx       ALL=(ALL)         /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">oldboy   ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure>

<p><em>2.埋下了hulk种子后又如何提权使用呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo -l</span><br><span class="line">User xuliangwei may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure>

<p><em>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</em></p>
<p><em>第一种方式:使用sudo中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># visudo  #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个系统group没什么关系</span></span><br><span class="line">User_Alias OPS = oldboy,alex</span><br><span class="line">User_Alias DEV = bgx,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure>

<p><em>第二种方式:使用groupadd添加组,然后给组分配sudo的权限,如果有新用户加入,直接将用户添加到该组.</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure>

<p><em>4.sudo命令的执行流程:</em><br> <em>1) 普通用户执行sudo命令时, 会检查/var/db/sudo是否存在时间戳缓存<br> 2) 如果存在则不需要输入密码, 否则需要输入用户与密码<br> 3) 输入密码会检测是否该用户是否拥有该权限<br> 4) 如果有则执行，否则报错退出</em></p>
<p><em>下图为sudo执行流程</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728212235.png" alt="imageTitle"></p>
<p><a href="https://www.jianshu.com/p/d172a92475f1">sudo不支持系统内置命令</a></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>用户 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本权限</title>
    <url>/2021/08/02/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.权限基本概述  2.权限设置示例  3.权限设置案例  4.属主属组设置</p>
<span id="more"></span>

<h1 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h1><p><em><strong>1.什么是权限？</strong></em></p>
<p><em>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</em></p>
<p><em><strong>2.为什么要有权限</strong></em></p>
<p><em>因为系统中不可能只存在一个root用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。(比如三个租客合租同一个房子，a租客要使用b租客的肥皂，那这个事情？？</em></p>
<p><em><strong>3.权限与用户之间的关系？</strong></em></p>
<p><em>在Linux系统中，针对文件定义了三种身份，分别是属主(owner)、属组(group)、其他人(others)，每一种身份又对应三种权限(rwx)，分别是可读(readable)、可写(writable)、可执行(excutable)。</em></p>
<p>*用户对文件资源，有三种角色ugo，当一个用户访问文件流程如下</p>
<ol>
<li>判断用户是否为文件所有者，如果是则按所有者的权限进行访问</li>
<li>判断用户是否为文件所有组成员，如果是则按组的权限进行访问</li>
<li>如果不是所有者，也不是该文件所属组，则按匿名权限进行访问*</li>
</ol>
<p><em><strong>4.权限中的rwx分别代表什么含义？</strong></em></p>
<p><em>当我们使用ls -l查看一个文件的详细属性时，能看到每个文件都有一个9位基本权限位，比如: <code>rwxr-xr-x</code>其中每三位字符为一组，分别表示属主权限位，属组权限位，匿名权限位。<br>linux中基本权限位则是使用这9位字符来表示，主要控制文件属主(User)、属组(Group)、其他用户(Other)</em></p>
<table>
<thead>
<tr>
<th>字母</th>
<th>含义</th>
<th>对应权限</th>
</tr>
</thead>
<tbody><tr>
<td>r（read）</td>
<td>读取权限</td>
<td>4</td>
</tr>
<tr>
<td>w（write）</td>
<td>写入权限</td>
<td>2</td>
</tr>
<tr>
<td>x（execute）</td>
<td>执行权限</td>
<td>1</td>
</tr>
<tr>
<td>-（没有权限）</td>
<td>没有权限</td>
<td>0</td>
</tr>
</tbody></table>
<p><em>PS: 如果权限位不可读、不可写、不可执行，则全部使用-作为占位符表示。</em></p>
<h1 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h1><p><em>文件示例: rwxrw-r– alice hr file1.txt<br> Q1: alice对file1文件拥有什么权限?<br> Q2: jack 对 file1.txt 文件有什么权限? 前提:jack 属于 hr 组<br> Q3: tom 对 file1.txt 文件有什么权限?</em></p>
<p><em><strong>1.为什么要设定权限，我们又如何修改一个文件的权限?</strong></em></p>
<p><em>Q1: 为什么要设定权限，可以赋于某个用户或组 – 能够以何种方式 – 访问某个文件<br>Q2: Linux下使用chmod命令来变更权限，root用户可以变更所有文件的权限，而普通用户仅能变更属于自己的文件。</em></p>
<p><em><strong>2.使用chmod设定权限示例</strong></em></p>
<p><em>方式一: ugo</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># touch file                    #创建文件</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=rwx file              #给所有人添加读写执行权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=-rwx file             #取消所有的权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod u=rwx,g=rw,o=- file     #属主读写执行，属组读写，其他人无权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod ug=rwx,o=r file         #属主属组读写执行，其他人读权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure>

<p><em>方式二、number</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项:  -R递归修改</span></span><br><span class="line">[root@bgx ~]<span class="comment"># touch file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 644 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 600 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对目录设定权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 777 dir/    #修改目录允许所有人访问</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod -R 755 dir/ #修改目录及子目录权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d dir/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir/</span><br></pre></td></tr></table></figure>

<p><em><strong>3.权限设置案例</strong></em></p>
<p><em>针对 hr 部门的访问目录/home/hr 设置权限，要求如下:<br>1.root 用户和 hr 组的员工可以读、写、执行<br>2.其他用户没有任何权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># groupadd hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr01 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr02 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chgrp hr /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 770 /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /home/hr</span></span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 /home/hr</span><br></pre></td></tr></table></figure>

<h1 id="3-权限设置案例"><a href="#3-权限设置案例" class="headerlink" title="3.权限设置案例"></a>3.权限设置案例</h1><p><em>在Linux中权限对文件和对目录的影响是有不同区别的。</em></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>读取权限（r）</td>
<td>具有读取\阅读文件内容权限</td>
<td>具有浏览目录及子目录</td>
</tr>
<tr>
<td>写入权限（w）</td>
<td>具有新增、修改文件内容的权限</td>
<td>具有增加和删除目录内文件</td>
</tr>
<tr>
<td>执行权限（x）</td>
<td>具有执行文件的权限</td>
<td>具有访问目录的内容(取决于目录中文件权限)</td>
</tr>
</tbody></table>
<p><em>文件权限实验案例:</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.新建文件，并添加内容至文件中，默认文件匿名用户仅有读权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;date&quot; &gt; filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll filename</span></span><br><span class="line">-rw-r--r-- 1 root root 5 Jan 24 08:24 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换bgx普通用户</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># su - bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对文件拥有读取的权限，但bgx用户对文件没有执行和删除的权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat  /root/filename</span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用root增加x执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+x /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--r-x 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.测试x权限是否真的能执行该文件</span></span><br><span class="line">[bgx@lucifer ~]$ /root/filename</span><br><span class="line">Wed Jan 24 08:28:34 EST 2018</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.增加w执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+w /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--rwx 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#7.测试执行权限</span></span><br><span class="line">[bgx@lucifer ~]$ vim /root/filename</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对文件的影响</em><br> <em>读取权限（r）具有读取\阅读文件内容权限<br> 1.只能使用查看类命令cat、head、tail、less、more</em></p>
<p><em>写入权限（w）具有新增、修改文件内容的权限<br>1.使用vim编辑会提示权限拒绝, 但可强制保存,会覆盖文件的所有内容<br>2.使用echo命令重定向的方式可以往文件内写入数据,&gt;&gt;可以进行追加<br>3.不能删除文件,因为删除文件看的不是文件的属性,需要看上级目录是否有w的权限</em></p>
<p><em>执行权限（x）具有执行文件的权限<br>1.执行权限什么用都没有<br>2.如果普通用户需要执行文件,需要配合r权限</em></p>
<p><strong>目录权限实验案例:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1: 创建目录，并在该目录下创建文件，匿名用户对目录没有w权限，对文件有777权限 </span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir /dirname</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;test&quot; &gt;&gt; /dirname/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限，能正常查看，但无法删除[奇怪]</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">rm: cannot remove ‘/dirname/filename’: Permission denied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 设置目录777权限，相当于匿名用户对目录有w权限，对文件没有任何权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 000 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line">cat: /dirname/filename: Permission denied</span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">[bgx@lucifer ~]$ touch /dirname/filename_2</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对目录的影响</em></p>
<p><em>读取权限（r），如果目录只有r权限: 具有浏览目录及子目录权限<br>1.可以使用ls命令浏览目录及子目录， 但同时也会提示权限拒绝<br>2.使用ls -l命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br>总结: 目录只有r权限，仅仅只能浏览内的文件名，无其他操作权限</em></p>
<p><em>写入权限（w），如果目录只有w权限: 具有增加、删除或修改目录内文件名权限(需要x权限配合)<br>PS: 如果目录有w权限, 可以在目录内创建文件, 删除文件(跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</em></p>
<p><em>执行权限（x），如果目录只有x权限<br>1.只能进入目录<br>2.不能浏览、复制、移动、删除</em></p>
<p><em><strong>Linux权限总结与注意事项</strong></em></p>
<p><em>文件r权限,  只给用户查看,无其他操作<br>文件rw权限, 可以查看和编辑文件内容<br>文件rx权限, 允许查看和执行文件、但不能修改文件—–&gt;PASS<br>文件rwx权限, 能读,能写,能执行,但不能删除,因为删除需要看上级目录的权限有没有w—–&gt;PASS<br>目录rx权限, 允许浏览目录内文件以及子目录、并允许在目录内新建文件, 不允许创建、删除文件和目录<br>目录wx权限, 能进入目录,能删除内容,能写入内容,但就是无法使用ls cat这样的命令—–&gt;PASS<br>目录rw权限, 能看,能写,但无法进入目录—–&gt;PASS<br>PS: 文件的 x权限小心给予，目录的 w权限小心给予。<br>PS: 文件通常设定的权限是644,目录设定的权限是755<br>PS: 控制目录权限755, 如果有普通用户需要操作目录里面的文件，在来看文件的权限</em></p>
<h1 id="4-属主属组设置变更文件属主和属组的意义？"><a href="#4-属主属组设置变更文件属主和属组的意义？" class="headerlink" title="4.属主属组设置变更文件属主和属组的意义？"></a>4.属主属组设置<em>变更文件属主和属组的意义？</em></h1><p><em>变更文件属主和属组的意义？</em><br> <em>比如: 我现在手里有多套房，希望出售其中的A房进行变现，那么我会考虑将A房过户给金主，过户成功后A房就属于金主了，那么此时A房的拥有者就属于金主而不再属于我。</em></p>
<p><em>在Linux中如何变更一个文件或者一个资源的属主和属组呢，可以使用chown、chgrp命令实现。<br>chown能设置属主和属组，chgrp仅能设置属组。（所以用哪个你懂的）</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chown 更改属主以及属组 -R：递归修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备环境，创建文件和目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir/test1 &amp;&amp; touch dir/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1: 修改所属主为bin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown bin dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 修改所属组为adm</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown .adm dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 递归修改目录及目录下的所有文件属主和属组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown -R root.root dir/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux容器（Container）发展史</title>
    <url>/2021/08/17/Linux%E5%AE%B9%E5%99%A8(Container)%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<span id="more"></span>


<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">原文连接:</span><br><span class="line">	https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14013388</span>.html</span><br></pre></td></tr></table></figure>



<h1 id="一-容器-Container-技术概述"><a href="#一-容器-Container-技术概述" class="headerlink" title="一.容器(Container)技术概述"></a>一.容器(Container)技术概述</h1><h2 id="1-什么是容器-Container"><a href="#1-什么是容器-Container" class="headerlink" title="1.什么是容器(Container)"></a>1.<strong>什么是容器(Container)</strong></h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">容器是一种基础工具；泛指任何可以用于容纳其它物品的工具，可以部分或完全封闭，被用于容纳，存储，运输物品；物体可以被放置在容器中，而容器则可以保护内容物。</span><br><span class="line"></span><br><span class="line">　　人类使用容器的历史至少有十万年，甚至可能有数百万的历史。以下是我们生活中常见到的容器的类型:</span><br><span class="line">       瓶:</span><br><span class="line">           指口部比腹部窄小，颈长的容器。</span><br><span class="line">       罐:</span><br><span class="line">           指那些开口较大，一般为近圆筒形的器皿。</span><br><span class="line">       箱:</span><br><span class="line">           通常是立方体或圆柱体。形状固定。</span><br><span class="line">       篮:</span><br><span class="line">           以条形物编织而成。</span><br><span class="line">       桶:</span><br><span class="line">           一种圆柱形的容器。</span><br><span class="line">       袋:</span><br><span class="line">           柔性材料制成的容器，形状会受内容物而变化。</span><br><span class="line">       翁:</span><br><span class="line">           通常是指陶制，口小肚大的容器。</span><br><span class="line">       碗:</span><br><span class="line">           用来盛载食物的容器。</span><br><span class="line">       柜:</span><br><span class="line">           指由一个盒组成的家俱。</span><br><span class="line">       鞘:</span><br><span class="line">           用于装载刀刃的容器。</span><br><span class="line"></span><br><span class="line">   综上所述，想必大家对容器这个概念应该有所了解，说了这么多，我想表达的是: <span class="string">&quot;计算机中的技术来源于现实生活&quot;</span>。</span><br><span class="line"></span><br><span class="line">   那计算机所指的容器(Container)到底是什么呢？可能你会说它是能装<span class="string">&quot;东西&quot;</span>的一个技术，那这个<span class="string">&quot;东西&quot;</span>到底是啥呢？自然是就是我们熟悉的所有应用程序(Application Program)啦。</span><br><span class="line"></span><br><span class="line">   我们以Linux容器为例，它是运行在操作系统上的一系列进程。运行这些进程所需的所有文件都由另一个只读镜像文件提供，这意味着从<span class="string">&quot;开发 -&gt; 测试 --&gt; 生产&quot;</span>的整个过程中，Linux容器都具有可移植性和一致性。</span><br><span class="line"></span><br><span class="line">   换句话说，Linux容器技术能够让您对应用及其整个运行时环境(包括全部所需文件)一起进行打包或隔离。从而让您可以在不同环境(如开发、测试和生产等环境)之间轻松迁移应用，同时还可保留应用的全部功能。</span><br><span class="line"></span><br><span class="line">   因而，相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多。容器比较普遍也易于使用，因此也成了IT安全方面的重要组成部分。将安全性内置于容器管道，可以为您的基础架构增添防护，从而保障容器的可靠性、可扩展性和信赖度。</span><br><span class="line">   </span><br><span class="line">   推荐阅读: </span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics<span class="regexp">/containers/</span>whats-a-linux-container。</span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics<span class="regexp">/security/</span>container-security</span><br><span class="line">       https:<span class="regexp">//</span>www.redhat.com<span class="regexp">/zh/</span>topics/security</span><br><span class="line">       https:<span class="regexp">//</span>www.docker.com<span class="regexp">/resources/</span>what-container</span><br><span class="line">       https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/get-started/</span><span class="comment">#what-is-a-container</span></span><br></pre></td></tr></table></figure>



<h2 id="2-为什么要用容器"><a href="#2-为什么要用容器" class="headerlink" title="2.为什么要用容器"></a>2.为什么要用容器</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">场景:</span><br><span class="line">　　　　假设您在使用一台笔记本电脑开发一个应用，而且您的开发环境具有特定的配置。其他开发人员身处的环境配置可能稍有不同。您正在开发的应用不止依赖于您当前的配置，还需要某些特定的库、依赖项和文件。</span><br><span class="line">　　　　与此同时，您的企业还拥有标准化的开发和生产环境，有着自己的配置和一系列支持文件。您希望尽可能多在本地模拟这些环境，而不产生重新创建服务器环境的开销。</span><br><span class="line"></span><br><span class="line">　　根据以上场景分析，您要考虑如何确保应用能够在这些环境中运行和通过质量检测，并且在部署过程中不出现令人头疼的各种依赖问题，也无需重新编写代码和进行故障修复呢？答案就是使用容器。</span><br><span class="line">　　　　(<span class="number">1</span>)容器可以确保您的应用拥有必需的库、依赖项和文件，让您可以在生产中自如地迁移这些应用，无需担心会出现任何负面影响。</span><br><span class="line">　　　　(<span class="number">2</span>)实际上，您可以将容器镜像中的内容，视为<span class="selector-tag">Linux</span>发行版的一个安装实例，因为其中完整包含<span class="selector-tag">RPM</span>软件包、配置文件等内容。但是，安装容器镜像发行版，要比安装新的操作系统副本容易得多。这样可以避免不必要的麻烦，做到皆大欢喜。</span><br><span class="line"></span><br><span class="line">　　虽然这只是一个常见情况的示例，但在需要很高的可移植性、可配置性和隔离的情况下，我们可以利用<span class="selector-tag">Linux</span>容器通过很多方式解决难题。 <span class="selector-tag">Linux</span>容器的价值在于，它能加速开发并满足新出现的业务需求。</span><br><span class="line"></span><br><span class="line">　　在某些情形中(如通过Apache Kafka进行实时数据流处理)，容器是不可或缺的，因为它们是提供应用所需的可扩展性的唯一途径。 无论基础架构是在企业内部还是在云端，或者混合使用两者，容器都能满足您的需求。当然，选择正确的容器平台也同样重要。</span><br><span class="line"></span><br><span class="line">　　在云服务范畴内，<span class="selector-tag">CaaS</span>被认为是基础架构即服务(IaaS)的一种子集，介于<span class="selector-tag">IaaS</span>和平台即服务(PaaS)之间。  <span class="selector-tag">CaaS</span>的基本资源为容器，它是云原生应用和微服务的常见部署机制。此外，<span class="selector-tag">CaaS</span>还可以提高环境之间的可移植性，无论是混合环境还是多云环境。</span><br><span class="line"></span><br><span class="line">　　使用容器有很多好处，以下是比较容器可圈可点的特性:</span><br><span class="line">       (<span class="number">1</span>)可移植性：</span><br><span class="line">           用容器开发的应用拥有运行所需的一切，并可以部署在包括私有云和公共云在内的多种环境中。</span><br><span class="line">           可移植性也意味着灵活性，因为您可以更轻松地在环境和提供商之间移动工作负载。 </span><br><span class="line">       (<span class="number">2</span>)可扩展性：</span><br><span class="line">           容器具有水平扩展的功能，这意味着用户可以在同一集群中成倍增加相同容器的数量，从而根据需要进行扩展。</span><br><span class="line">           通过仅在需要时使用和运行所需的内容，可以大大降低成本。 </span><br><span class="line">       (<span class="number">3</span>)高效性：</span><br><span class="line">           容器所需的资源要少于虚拟机(VM)，因为它们不需要虚拟单独的操作系统。</span><br><span class="line">           您可以在单个服务器上运行多个容器，而且它们需要较少的裸机硬件，这意味着成本更低。</span><br><span class="line">       (<span class="number">4</span>)更高的安全性：</span><br><span class="line">           容器之间彼此隔离，这意味着在一个容器遭到破坏的情况下，其他容器并不会受到影响。 </span><br><span class="line">       (<span class="number">5</span>)速度：</span><br><span class="line">           由于容器相对于操作系统具有自主性，因此其启动和停止仅需几秒钟的时间。这也加快了开发和运维工作，同时带来了更快、更流畅的用户体验。</span><br></pre></td></tr></table></figure>



<h1 id="二-常见的容器管理技术概述"><a href="#二-常见的容器管理技术概述" class="headerlink" title="二.常见的容器管理技术概述"></a>二.常见的容器管理技术概述</h1><h2 id="1-Unix-chroot"><a href="#1-Unix-chroot" class="headerlink" title="1.Unix chroot"></a>1.Unix chroot</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">　　容器的概念始于<span class="number">1979</span>年前后的UNIX chroot，它是一个UNIX操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。</span><br><span class="line"></span><br><span class="line">　　这个功能的想法是为每个进程提供独立的磁盘空间。其后在<span class="number">1982</span>年前后，它被加入到了<span class="keyword">BSD系统中。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　<span class="keyword">BSD是Unix的扩展版本，FreeBSD是BSD发行版最流行的系统。</span></span><br></pre></td></tr></table></figure>



<h2 id="2-Unix-FreeBSD-jail"><a href="#2-Unix-FreeBSD-jail" class="headerlink" title="2.Unix FreeBSD jail"></a>2.Unix FreeBSD jail</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">在<span class="number">2000</span>年前后，FreeBSD jail这种技术可将FreeBSD系统分区为多个子系统(也称为Jail)。Jail是作为安全环境而开发的，系统管理员可与企业内部或外部的多个用户共享这些Jail。</span><br><span class="line">   </span><br><span class="line">　　Jail的目的是让进程在经过修改的chroot环境中创建，而不会脱离和影响整个系统。在chroot环境中，对文件系统、网络和用户的访问都实现了虚拟化。　　</span><br><span class="line">　　</span><br><span class="line">　　尽管Jail在实施方面存在局限性，但最终人们找到了脱离这种隔离环境的方法。但这个概念非常有吸引力。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">       https:<span class="regexp">//</span>www.freebsd.org<span class="regexp">/doc/</span>handbook/jails.html</span><br><span class="line">       https:<span class="regexp">//</span>www.freebsd.org/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/5460EC51825E46C0BE8059FAA9E676D9?method=download&shareKey=9d5b906bf6c8d799d10c4a1979168b43" alt="img"></p>
<h2 id="3-Linux-VServer"><a href="#3-Linux-VServer" class="headerlink" title="3.Linux-VServer"></a>3.Linux-VServer</h2><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="number">2001</span>年前后，通过Jacques Gélinas的VServer项目，隔离环境的实施进入了Linux领域。正如Gélinas所说:<span class="string">&quot;这项工作的目的是高度独立且安全的单一环境中运行多个通用Linux服务器&quot;</span>。 </span><br><span class="line"></span><br><span class="line">　　Linux-VServer也是一个操作系统级虚拟化解决方案。Linux-VServer对Linux内核进行虚拟化，这样多个用户空间环境又称为<span class="string">&quot;Virtual Private Server&quot;</span>(简称<span class="string">&quot;VPS&quot;</span>)就可以单独运行，而不需要互相了解。</span><br><span class="line"></span><br><span class="line">　　Linux-VServer通过修改Linux内核实现用户空间的隔离。Linux VServer也使用了chroot来为每个VPS隔<span class="built_in">离root</span>目录。虽然chroot允许指定<span class="built_in">新root</span>目录，但还是需要其他一些功能(称为Chroot-Barrier)来限制VPS脱离其隔离<span class="built_in">的root</span>目录回到上级目录。</span><br><span class="line"></span><br><span class="line">　　给定一个隔离<span class="built_in">的root</span>目录之后，每个VPS就可以拥有自己的用户列表<span class="built_in">和root</span>密码。在完成了这项针对Linux中多个受控制用户空间的基础性工作后，Linux容器开始逐渐成形并最终发展成了现在的模样。</span><br><span class="line">　　</span><br><span class="line">　　如下图所示，<span class="number">2.4</span>和<span class="number">2.6</span>版本的Linux内核支持Linux-VServer，它可以运行于很多平台之上，包括 x86、x86-<span class="number">64</span>、SPARC、MIPS、ARM 和 PowerPC。</span><br><span class="line">　　</span><br><span class="line">　　温馨提示:　　　　</span><br><span class="line">		同年时间(即<span class="number">2001</span>年)，Parallels公司发布了Virtuozzo Container产品，只不过该版本是商用版本。直到<span class="number">2005</span>年才基于Virtuozzo Containers研发了OpenVZ进行开源。</span><br><span class="line">	</span><br><span class="line">	推荐阅读:</span><br><span class="line">        http://linux-vserver.org/Welcome_to_Linux-VServer.org</span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/FFB7E088B246455D914EE9CA1FFA2B8C?method=download&shareKey=c2fdcdd84be6c9a319f433609374d628" alt="img"></p>
<h2 id="4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版"><a href="#4-Oracle-Solaris-Container-Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版-即BSD-的发行版" class="headerlink" title="4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)"></a>4.Oracle Solaris Container(Sun公司的Solaris与FreeBSD，Mac系统一样，均是Unix扩展版(即BSD)的发行版)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">2004</span>年前后，作为Solaris <span class="number">10</span>中具有突破性意义的关键技术之一，由Sun公司虚拟化专家Joost Pronk van Hoogeveen、Jeff Victor和Chien-Hua Yen等研发的Solaris Containers能够促进服务器整合，并提高应用程序可用性和易管理性。</span><br><span class="line"></span><br><span class="line">　　Solaris网格容器由两个主要组件构成：Solaris区域(Zone)和Solaris资源管理器(SRM)。SRM 管理每个容器接收到的物理系统资源，而Solaris区域则控制名称空间隔离。<span class="string">&quot;区域&quot;</span>和SRM一起构成Solaris容器的基础。</span><br><span class="line"></span><br><span class="line">　　在<span class="number">2008</span>年前后Sun以<span class="number">10</span>亿美元收购开源数据库公司MySQL，做为一个开源的关系型数据库管理系统，MySQL在市场上受到了广泛的欢迎，并成为流行的网站架构方式LAMP(Linux+Apache+MySQL+PHP)的一部分。</span><br><span class="line">　　　　</span><br><span class="line">　　<span class="number">2009</span>年<span class="number">4</span>月<span class="number">20</span>日，加利福尼亚州圣克拉拉市Sun Microsystems（NASDAQ：JAVA）和Oracle Corporation（NASDAQ：ORCL）今天宣布，他们已达成最终协议，根据该协议，Oracle将以每股<span class="number">9.50</span>美元的现金价格收购Sun普通股。</span><br><span class="line">　　　　交易总价值约为<span class="number">74</span>亿美元，扣除Sun的现金和债务后为<span class="number">56</span>亿美元。曾经的工作站之王、Unix之王和缔造了Solaris、Java传奇的巨人Sun倒下了</span><br><span class="line"></span><br><span class="line">　　Java和JavaScript啥关系?　　　　</span><br><span class="line">　　	Java由SUN公司研发，SUN公司和网景(Netscape)公司的是合作关系。JavaScript在<span class="number">1995</span>年由Netscape公司(该公司成立于<span class="number">1994</span>年)的Brendan Eich，在网景导航者浏览器上首次设计实现而成。</span><br><span class="line">　　　　因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。JavaScript的标准是ECMAScript 。</span><br><span class="line">　　　　<span class="number">1998</span>年<span class="number">11</span>月，网景被美国在线（American OnLine，AOL）收购，而后来美国在线和时代华纳合并，之后再独立。美国在线依然使用网景这品牌。</span><br><span class="line">　　　　<span class="number">2007</span>年<span class="number">12</span>月<span class="number">28</span>日，美国在线在博客表示将停止网景浏览器的开发，并于<span class="number">2008</span>年<span class="number">3</span>月<span class="number">1</span>日停止安全更新和所有的技术支持，并建议用户转移使用Mozilla Firefox浏览器。</span><br><span class="line">　　　　这就意味着于<span class="number">1994</span>年问世的Netscape将正式退出历史舞台。于<span class="number">2008</span>年<span class="number">3</span>月<span class="number">1</span>日停止支持的网景浏览器后，保留了门户网站Netscape。此外也有经营着一个以网景为名的廉价互联网服务。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.lampchina.net<span class="regexp">/ask/</span>MTM3MTkwMg.html</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.fujitsu.com<span class="regexp">/global/</span>products<span class="regexp">/computing/</span>servers<span class="regexp">/unix/</span>sparc-enterprise<span class="regexp">/software/</span>solaris10<span class="regexp">/container/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>baike.baidu.com<span class="regexp">/item/</span>%E7%BD%<span class="number">91</span>%E6%<span class="number">99</span>%AF/<span class="number">70176</span>?fromtitle=netscape&amp;fromid=<span class="number">2778944</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/DAAE3B5719C74AC082F59E02370867CB?method=download&shareKey=890184d5eeabed4b0732a5d940d1ee46" alt="img"></p>
<h2 id="5-Parallels-Virtuozzo-OpenVZ"><a href="#5-Parallels-Virtuozzo-OpenVZ" class="headerlink" title="5.Parallels Virtuozzo/OpenVZ"></a>5.Parallels Virtuozzo/OpenVZ</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">2005</span>年前后，前面我们提到过，Virtuozzo(<span class="number">2001</span>年发布)是SWsoft公司（目前SWsoft已经改名为Parallels）的操作系统虚拟化软件的命名，Virtuozzo是商业解决方案，而OpenVZ是以Virtuozzo为基础的开源项目，它们采用的也是操作系统级虚拟化技术。</span><br><span class="line"></span><br><span class="line">　　OpenVZ类似于Linux-VServer，它通过对Linux内核进行补丁来提供虚拟化、隔离、资源管理和状态检查。每个OpenVZ容器都有一套隔离的文件系统、用户及用户组等。</span><br><span class="line"></span><br><span class="line">　　OpenVZ是Linux的基于容器的虚拟化。OpenVZ在单个物理服务器上创建多个安全的，隔离的Linux容器(也称为VE或VPS)，以提高服务器利用率并确保应用程序不冲突。</span><br><span class="line"></span><br><span class="line">　　每个容器的执行和执行都完全像独立服务器一样。容器可以独立地重新引导，并且具有root用户访问权限，用户，IP地址，内存，进程，文件，应用程序，系统库和配置文件。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Main_Page</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Quick_installation</span><br><span class="line">　　　　https:<span class="regexp">//</span>wiki.openvz.org/Download</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/19B0AC02D1FD40F2A970D566E4AAC044?method=download&shareKey=2f809f15505179b4fd510a02797f544a" alt="img"></p>
<h2 id="6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术"><a href="#6-Linux-Kernel支持Cgroup-控制组-和NameSpace-命名空间-技术" class="headerlink" title="6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术"></a>6.Linux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">早期，<span class="selector-tag">Jail</span>和<span class="selector-tag">VServer</span>基本上都是在<span class="selector-tag">chroot</span>概念之上稍作改进和其他一些标准工具的组合来实现此特定的虚拟服务器模型。很快，更多技术结合进来，让这种隔离方法从构想变为现实。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">2007</span>年前后，<span class="selector-tag">Linux</span>内核支持<span class="selector-tag">Cgroup</span>和<span class="selector-tag">NameSpace</span>技术，这两种技术在增加对<span class="selector-tag">Linux</span>的整体控制的同时，也成为了保持环境隔离的重要框架。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">NameSpace</span>(命名空间)主要包含以下六种技术:</span><br><span class="line">　　　　<span class="selector-tag">MNT</span> <span class="selector-tag">Namespace</span>(提供磁盘挂载点和文件系统的隔离能力):</span><br><span class="line">　　　　　　每个容器都要有独立的根文件系统用户空间，以实现在容器里面启动服务并且使用容器的运行环境。换句话说，就是在容器里面不能访问宿主机的资源，宿主机是使用了<span class="selector-tag">chroot</span>技术把容器锁定到一个指的运行目录里面。</span><br><span class="line">　　　　　　举个例子:</span><br><span class="line">　　　　        一个宿主机是<span class="selector-tag">ubuntu</span>的服务器，可以在里面启动一个<span class="selector-tag">centos</span>运行环境的容器并且在里面启动一个<span class="selector-tag">Nginx</span>服务，此<span class="selector-tag">Nginx</span>运行时使用的运行环境就是<span class="selector-tag">centos</span>系统目录的运行环境。</span><br><span class="line">　　　　<span class="selector-tag">IPC</span> <span class="selector-tag">Namespace</span>(提供进程间通信的隔离能力):</span><br><span class="line">　　　　　　一个容器内的进程间通信，允许一个容器内的不同进程的(内存,缓存等)数据访问，但是不能跨容器访问其他容器的数据 。</span><br><span class="line">　　　　<span class="selector-tag">UTS</span> <span class="selector-tag">Namespace</span>(提供主机名隔离能力):</span><br><span class="line">　　　　　　用于系统标识,其中包含了<span class="selector-tag">hostname</span>和域名<span class="selector-tag">domainname</span>,它使得一个容器拥有属于自己<span class="selector-tag">hostname</span>标识,这个主机名标识独立于宿主机系统和其上的他容器 。</span><br><span class="line">　　　　<span class="selector-tag">PID</span> <span class="selector-tag">Namespace</span>(提供进程隔离能力):</span><br><span class="line">　　　　　　<span class="selector-tag">CentOS</span> <span class="selector-tag">Linux</span>系统中，有一个<span class="selector-tag">PID</span>为<span class="selector-tag">1</span>的进程(init/systemd)是其他所有进程的父。</span><br><span class="line">　　　　　　在每个容器内也要有一个父进程来管理其下属的子进程，多个容器进程的<span class="selector-tag">PID</span> <span class="selector-tag">namespace</span>进程隔离(比如PID编号重复、容器内的主进程与回收子进程等)。</span><br><span class="line">　　　　<span class="selector-tag">Net</span> <span class="selector-tag">Namespace</span>(提供网络隔离能力):</span><br><span class="line">　　　　　　每一个容器都类似于虚拟机一样有自己的网卡，监听端口，<span class="selector-tag">TCP</span>/<span class="selector-tag">IP</span>协议栈等。</span><br><span class="line">　　　　　　以<span class="selector-tag">Docker</span>为例，使用<span class="selector-tag">network</span> <span class="selector-tag">namespace</span>启动一个<span class="selector-tag">vethX</span>接口，这样你的容器将拥有它自己的桥接<span class="selector-tag">ip</span>地址，通常是<span class="selector-tag">docker0</span>。</span><br><span class="line">　　　　　　上面提到的<span class="selector-tag">docker0</span>本质上是<span class="selector-tag">Linux</span>的虚拟网桥(Virtual Bridge)，网桥是在<span class="selector-tag">OSI</span>七层模型的数据链路网络设备，通过<span class="selector-tag">mac</span>地址对网络进行划分，并且在不同网络直接传递数据。</span><br><span class="line">　　　　<span class="selector-tag">User</span> <span class="selector-tag">Namespace</span>(提供用户隔离能力):</span><br><span class="line">　　　　　　各个容器内可能会出现重名的用户和用户组名称,或重复的用户<span class="selector-tag">UID</span>或者<span class="selector-tag">GID</span>,那么怎隔离各个容器内的用户空间呢？</span><br><span class="line">　　　　　　<span class="selector-tag">User</span> <span class="selector-tag">Namespace</span>允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户<span class="selector-tag">UID</span>和<span class="selector-tag">GID</span>，只是会用户的作用范围限制在每个容器内。</span><br><span class="line">　　　　　　即<span class="selector-tag">A</span>容器和<span class="selector-tag">B</span>容器可以有相同的用户名称和<span class="selector-tag">ID</span>的账户，但是此用户的有效范围仅是当前容器内，不能访问另外一个容器内的文件系统，即相互隔离，互不影响，永不相见。</span><br><span class="line"></span><br><span class="line">　　<span class="selector-tag">Cgroups</span>:</span><br><span class="line">　　　　一个容器如果不对其做任何资源限制，则宿主机(也称为物理机，英文名称为:<span class="string">&quot;Physical machine&quot;</span>)会允许其占用无限大的内存空间，有时候会因为代码<span class="selector-tag">bug</span>程序会一直申请内存，直到把宿主机内存占完。</span><br><span class="line">　　　　综上所述，为了避免此类的问题出现，宿主机有必要对容器进行资源分配限制，比如<span class="selector-tag">CPU</span>，内存，磁盘等。</span><br><span class="line">　　　　<span class="selector-tag">Linux</span> <span class="selector-tag">Cgroups</span>的全称是<span class="selector-tag">Linux</span> <span class="selector-tag">Control</span> <span class="selector-tag">Groups</span>，它最主要的作用就是限制一个进程组能够使用的资源上限，包括<span class="selector-tag">CPU</span>，内存，磁盘，网络带宽等等。</span><br><span class="line">　　　　此外，<span class="selector-tag">Linux</span> <span class="selector-tag">Cgroups</span>还能够对进程优先级设置，以及将进程挂起和恢复等操作。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　如下图所示，有关的<span class="selector-tag">NameSpace</span>(命名空间)各种核心技术所支持的<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span>的发行版本。因此推荐大家使用<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span> <span class="selector-tag">3</span><span class="selector-class">.8</span>+的版本哟~</span><br><span class="line">　　　　如果您使用的是<span class="selector-tag">Ubuntu</span>就不用担心<span class="selector-tag">Linux</span> <span class="selector-tag">Kernel</span>版本啦，因为它使用的<span class="selector-tag">Kernel</span>版本要比<span class="selector-tag">CentOS</span>的新，但如果您要是想使用<span class="selector-tag">CentOS</span>发行，推荐使用<span class="selector-tag">CentOS</span> <span class="selector-tag">7</span><span class="selector-class">.6</span>+版本。</span><br><span class="line"></span><br><span class="line">   参考连接:</span><br><span class="line">       <span class="selector-tag">https</span>:<span class="comment">//www.cnblogs.com/yinzhengjie/p/12183066.html</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/52EB4ADF496F4B25B049BB3864CCD9A9?method=download&shareKey=cee90ddb278ddaa76c3489247e270793" alt="img"></p>
<h2 id="7-LXC-LXD"><a href="#7-LXC-LXD" class="headerlink" title="7.LXC/LXD"></a>7.LXC/LXD</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">由于inux Kernel支持Cgroup(控制组)和NameSpace(命名空间)技术，这意味着一切都可在Linux内核中实现虚拟化，因此推动了容器的进一步发展。</span><br><span class="line"></span><br><span class="line">　　LXC:</span><br><span class="line">　　　　<span class="number">2008</span>年前后，作为一个开源容器平台，Linux容器项目LXC是众所周知的工具，模板，库和语言绑定集。它的级别很低，非常灵活，几乎涵盖了上游内核支持的每个遏制功能。同年，RedHat公司发布了用于管理虚拟化平台的Libvirt工具。</span><br><span class="line">　　　　LXC是Linux内核包含功能的用户空间接口。通过功能强大的API和简单的工具，它使Linux用户可以轻松地创建和管理系统或应用程序容器。LXC采用简单的命令行界面，可改善容器启动时的用户体验。</span><br><span class="line">　　　　LXC提供了一个操作系统级的虚拟化环境，可在许多基于Linux的系统上安装。在Linux发行版中，可能会通过其软件包存储库来提供LXC。</span><br><span class="line">　　　　当前的LXC使用以下内核功能来包含进程：</span><br><span class="line">　　　　　　(<span class="number">1</span>)Kernel namespaces (ipc, uts, mount, pid, network and user);</span><br><span class="line">　　　　　　(<span class="number">2</span>)Apparmor and SELinux profiles;</span><br><span class="line">　　　　　　(<span class="number">3</span>)Seccomp policies;</span><br><span class="line">　　　　　　(<span class="number">4</span>)Chroots (using pivot_root);</span><br><span class="line">　　　　　　(<span class="number">5</span>)Kernel capabilities;</span><br><span class="line">　　　　　　(<span class="number">6</span>)CGroups (control groups);</span><br><span class="line">　　　　LXC容器通常被认为是chroot和成熟的虚拟机之间的中间对象。LXC的目标是创建一个与标准Linux安装尽可能接近的环境，而不需要单独的内核。</span><br><span class="line">　　　　LXC的意思是LinuX Containers，它是第一个最完善的Linux容器管理器的实现方案，是通过cgroups和Linux名字空间namespace实现的。</span><br><span class="line">　　　　LXC存在于liblxc库中，提供了各种编程语言的API实现，包括Python3、Python2、Lua、Go、Ruby和Haskell等。</span><br><span class="line">　　　　与其它容器技术不同的是，LXC可以工作在普通的Linux内核上，而不需要增加补丁。现在LXC project是由Canonical Ltd.赞助的项目，目前由Canonical公司赞助并托管的。</span><br><span class="line"></span><br><span class="line">　　LXD: </span><br><span class="line">　　　　虽然LXC使得用户能够通过简单的命令行界面轻松地启动使用容器，但是和我们过去使用的虚拟机来讲，它的复杂程度并没有多大降低，而且其隔离性依旧没有虚拟机好。　　</span><br><span class="line">　　　　LXC最大的好处就是在性能和资源上有所节约，但是在大规模容器使用上LXC依然没有找到很好的突破口，于是后来就出现了LXD，Docker等技术。</span><br><span class="line">　　　　LXD是新的LXC体验。它使用一个命令行工具来管理容器，从而提供了全新的直观用户体验。可以通过REST API以透明方式通过网络管理容器。通过与OpenNebula和OpenStack等云平台集成，它还可以用于大规模部署。 </span><br><span class="line">　　　　LXD是下一代系统容器管理器。它提供类似于虚拟机的用户体验，但是使用Linux容器。它基于映像，并带有可用于各种Linux发行版的预制映像，并且基于非常强大但非常简单的REST API构建。 </span><br><span class="line"></span><br><span class="line">　　推荐阅读: </span><br><span class="line">　　　　https:<span class="regexp">//</span>www.freedesktop.org<span class="regexp">/wiki/</span>Software<span class="regexp">/systemd/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org/</span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org<span class="regexp">/lxc/i</span>ntroduction/</span><br><span class="line">　　　　https:<span class="regexp">//</span>linuxcontainers.org<span class="regexp">/lxd/i</span>ntroduction/</span><br><span class="line">　　　　http:<span class="regexp">//</span>www.canonical.com/</span><br><span class="line">　　　　https:<span class="regexp">//</span>libvirt.org/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/41A1C4F35B914459A3CA9553F7963BF1?method=download&shareKey=cee7e1cfadecd718bf40d47dc3d2da1a" alt="img"></p>
<h2 id="8-Docker"><a href="#8-Docker" class="headerlink" title="8.Docker"></a>8.Docker</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">2013</span>年dotCloud公司首次在pycon官网首次公布了Docker开源版本。Docker带来了一种先进的软件交付方式，即通过容器进行进行软件的交付。并对外宣传的是Build(本地编译)，Ship(传输到其他服务器节点)，Run(可以移植到指定的服务器运行)。</span><br><span class="line"></span><br><span class="line">　　实际上我们可以使用docker build将代码的运行环境制作成镜像，通过dock push将镜像发布至私有或共有的docker仓库。其他人可以通过dock pull下载你提交的镜像，而后使用docker run将指定在镜像启动。此过程可以排除环境依赖等问题。</span><br><span class="line"></span><br><span class="line">　　docker这款开源软件可以有效的解决(程序员开发的)程序在运行时环境差异而带来的一系列问题，达到<span class="string">&quot;Build once, Run anywhere&quot;</span>的目标。</span><br><span class="line"></span><br><span class="line">　　此后docker也称为了容器的代名词(就想Hadoop成了大数据的代名词一样)，并成为容器时代的引领者。关于Docker容器的历史，架构，应用场景等我这里不做赘述，感兴趣的小伙伴可参考我另外一篇笔记。 　　</span><br><span class="line">   Docker容器的应用场景:</span><br><span class="line">　　　　(<span class="number">1</span>)应用程序打包和发布;</span><br><span class="line">　　　　(<span class="number">2</span>)应用程序隔离；</span><br><span class="line">　　　　(<span class="number">3</span>)持续集成;</span><br><span class="line">　　　　(<span class="number">4</span>)部署微服务;</span><br><span class="line">　　　　(<span class="number">5</span>)快速搭建测试环境;</span><br><span class="line">　　　　(<span class="number">6</span>)提供CAAS产品;</span><br><span class="line">　　　　</span><br><span class="line">　　推荐阅读: 　　　　 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14017860</span>.html 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.cnblogs.com<span class="regexp">/yinzhengjie2020/</span>p/<span class="number">14022268</span>.html 　　　　</span><br><span class="line">　　　　https:<span class="regexp">//u</span>s.pycon.org<span class="regexp">/2013/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/724E98446FE142399ECC746F000399A0?method=download&shareKey=1706a7eabac30938ff3ddd2f2b17e456" alt="img"></p>
<h2 id="9-RedHat-已被IBM收购-的CoreOS-rkt容器技术"><a href="#9-RedHat-已被IBM收购-的CoreOS-rkt容器技术" class="headerlink" title="9.RedHat(已被IBM收购)的CoreOS rkt容器技术"></a>9.RedHat(已被IBM收购)的CoreOS rkt容器技术</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Rkt诞生于<span class="number">2014</span>年<span class="number">11</span>月末，我在GitHub上发现他在<span class="number">2014</span>年<span class="number">11</span>月<span class="number">27</span>日就发布了<span class="string">&quot;v0.0.0&quot;</span>版本，<span class="string">&quot;v0.1.0&quot;</span>版本是在同年的<span class="number">12</span>月<span class="number">1</span>日发布的。</span><br><span class="line"></span><br><span class="line">   Rkt是一种与Docker类似的容器引擎，由CoreOS公司主导，得到了Redhat、Google、Vmware等公司的支持，更加专注于解决安全、兼容、执行效率等方面的问题。</span><br><span class="line"></span><br><span class="line">   CoreOS公司最早是Docker的支持者，其产品CoreOS操作系统是适用于企业的轻量级容器化的Linux发行版，是Docker生态圈的重要一员。</span><br><span class="line">   </span><br><span class="line">   随着Docker在容器行业变得逐渐强大，Docker也越来越臃肿，CoreOS公司希望有一个更加开放和中立的容器标准，因此推出了自己的容器计划，很明显CoreOS公司也想在容器方面有一席之地。</span><br><span class="line"></span><br><span class="line">   就这样，CoreOS公司成为了Docker公司的容器引擎竞争对手。由于Docker已经深入人心，尽管Rkt也很优秀，但很少有人愿意将Docker技术栈迁移到Rkt技术栈。最终容器之战Docker占领了大部分市场。</span><br><span class="line"></span><br><span class="line">   <span class="number">2018</span>年<span class="number">4</span>月<span class="number">16</span>日是发布的最新rkt容器工具，目前该项目已经停止维护，因此生产环境中不推荐大家使用该容器技术。推荐使用主流的容器工具，如Docker，Pouch，podman。</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   参考链接:</span><br><span class="line">       https:<span class="regexp">//gi</span>thub.com<span class="regexp">/rkt/</span>rkt/releases</span><br><span class="line">       https:<span class="regexp">//</span>www.sohu.com<span class="regexp">/a/</span><span class="number">216850450</span>_468741</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/8612FE371E8E4095BAD4891027AFBCD9?method=download&shareKey=d4bbef959f682552830c095de0baf589" alt="img"></p>
<h2 id="10-阿里开源的Pouch容器技术"><a href="#10-阿里开源的Pouch容器技术" class="headerlink" title="10.阿里开源的Pouch容器技术"></a>10.阿里开源的Pouch容器技术</h2><p><img src="https://note.youdao.com/yws/api/personal/file/D4C678E2013948C6ADF8653042E5F162?method=download&shareKey=7a2e981d8184f61337bc74f6b2f8cd6f" alt="img"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span>年<span class="number">11</span>月<span class="number">19</span>日上午，在中国开源年会现场，阿里巴巴正式开源了基于Apache <span class="number">2.0</span>协议的容器技术Pouch。</span><br><span class="line"></span><br><span class="line">　　Pouch Container是阿里巴巴集团创建的一个开源项目，旨在促进集装箱技术的发展。</span><br><span class="line"></span><br><span class="line">　　Pouch Container的愿景是改善容器生态系统并促进容器标准OCI（开放容器计划），从而使容器技术成为云时代应用程序开发的基础。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以打包，交付和运行任何应用程序。它为应用程序提供了轻量级的运行时环境，具有强大的隔离性和最小的开销。Pouch Container将应用程序与变化的运行时环境隔离开来，并最大程度地减少了操作工作量。</span><br><span class="line"></span><br><span class="line">　　Pouch Container可以最大程度地减少应用程序开发人员编写本机应用程序或将旧版应用程序迁移到Cloud平台的工作。</span><br><span class="line"></span><br><span class="line">　　Pouch是一款轻量级的容器技术，拥有快速高效、可移植性高、资源占用少等特性，主要帮助阿里更快的做到内部业务的交付，同时提高超大规模下数据中心的物理资源利用率。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　上图是Pouch容器的内部实现架构图，下图是Pouch容器的生态系统图。</span><br><span class="line">　　　　在Pouch Container的路线图中，我们将拥抱生态系统作为主要目标。对于上层业务流程层，Pouch Container支持Kubernetes和Swarm。</span><br><span class="line">　　　　对于底层运行时层，Pouch Container支持runC，runV(该容器引擎由音速神童公司<span class="number">2015</span>年<span class="number">5</span>月左右发起的，同年发布的还有Intel公司发起的Clear Container)，runlxc等。为了使存储和网络大为补充，CNI和CSI就在其中。</span><br><span class="line"></span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/alibaba/</span>pouch</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com/opencontainers</span><br><span class="line">　　　　https:<span class="regexp">//</span>www.infoq.cn<span class="regexp">/article/</span>alibaba-pouch</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/alibaba/</span>pouch<span class="regexp">/blob/m</span>aster<span class="regexp">/docs/</span>architecture.md</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/opencontainers/</span>runc</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/hyperhq/</span>runv</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/containernetworking/</span>cni</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com/container-storage-interface</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/CA81AB020972443A8B9C492CB28783A6?method=download&shareKey=f6552922b3ed5aca9cb83076290fc538" alt="img"></p>
<h2 id="11-音速神童kata-containers"><a href="#11-音速神童kata-containers" class="headerlink" title="11.音速神童kata-containers"></a>11.音速神童kata-containers</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">技术创业公司音速神童成立于<span class="number">2015</span>年，由两位中国开发者赵鹏和王旭创建。经过两年的发展，成长为全球容器行业的的重要技术和力量，</span><br><span class="line"></span><br><span class="line">　　<span class="number">2017</span>年<span class="number">12</span>月，音速神童在KubeCon上对外发布了Kata Containers安全容器项目，这个项目的两个前身是:音速神童的自研容器产品runV和Inter公司的容器产品Clear Container，而这两个项目均发布于<span class="number">2015</span>年<span class="number">5</span>月。</span><br><span class="line"></span><br><span class="line">　　kata COntainers其支持者包括<span class="number">99</span>cloud、AWcloud、Canonical、中国移动、City Network、CoreOS、Dell/EMS、EasyStack、Fiberhome、谷歌、华为、京东、Mirantis、NetApp、Red Hat、SUSE、腾讯、Ucloud、UnitedStack 和中兴。</span><br><span class="line"></span><br><span class="line">　　自<span class="number">2017</span>年<span class="number">12</span>月启动以来，kata COntainers该社区成功地将Intel Clear Containers的最佳部分与Hyper.sh RunV合并，并进行了扩展，以包括对主要架构的支持，包括x86_64之外的AMD64，ARM，IBM p系列和IBM z系列。</span><br><span class="line"></span><br><span class="line">　　Kata Containers是一个开放源代码社区，致力于通过轻量级虚拟机来构建安全的容器运行时，这些虚拟机的感觉和性能类似于容器，但是使用硬件虚拟化技术作为第二防御层，可以提供更强的工作负载隔离。</span><br><span class="line">　　</span><br><span class="line">　　Kata Containers还支持多个虚拟机管理程序，包括QEMU，NEMU和Firecracker，并与其他容器化项目集成。</span><br><span class="line"></span><br><span class="line">　　Kata Containers社区由开放基础设施基金会管理，该基金会支持全球开放基础设施的开发和采用。该代码在Apache <span class="number">2</span>许可下托管在GitHub上。</span><br><span class="line"></span><br><span class="line">　　综上所述，Kata容器与容器一样轻便，快速，并与容器管理层集成在一起，包括流行的编排工具，如Docker和Kubernetes（k8s），同时还具有VM的安全优势。Kata Container具有以下几个优势：</span><br><span class="line">　　　　(<span class="number">1</span>)安全:</span><br><span class="line">　　　　　　在专用内核中运行，提供网络，I/O和内存的隔离，并可以通过虚拟化VT扩展利用硬件强制隔离。</span><br><span class="line">　　　　(<span class="number">2</span>)兼容性:</span><br><span class="line">　　　　　　支持行业标准，包括OCI容器格式，Kubernetes CRI接口以及旧版虚拟化技术。</span><br><span class="line">　　　　(<span class="number">3</span>)性能:</span><br><span class="line">　　　　　　提供与标准Linux容器一致的性能；提高隔离度，而无需增加标准虚拟机的性能。</span><br><span class="line">　　　　(<span class="number">4</span>)简单:</span><br><span class="line">　　　　　　消除了在完整的虚拟机内部嵌套容器的要求；标准接口使插入和入门变得容易。</span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　这一容器引擎其中一个特殊之处在于，它试图解决传统运维体验的问题，让容器可以像传统虚拟机一样操作。这其实就是VM与容器的结合，也正是Kata的用武之地。</span><br><span class="line">　　　　在之前，蚂蚁金服自研了一套技术来做到这点，而现在它们可以结合Kata的长处做到更好，同时又能保持和国内外主流技术保持同步。</span><br><span class="line">　　　　据InfoQ独家消息，技术创业公司音速神童创始人赵鹏王旭加入蚂蚁金服，打造虚拟机级别的安全容器技术。这也是为什么你所看到的pouch container是支持runV容器引擎的一个原因吧，因为runV研发团队核心成员已经入职阿里的蚂蚁金服!</span><br><span class="line">　　　　音速神童加入蚂蚁金服这件事在容器和云原生领域掀起新的波澜，它意味着云计算基础技术仍有可挖掘的的地方，而随着互联网大公司和云计算厂商的介入，未来的技术演进的竞争将更加激烈。</span><br><span class="line">　　</span><br><span class="line">　　参考链接:</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/kata-containers/</span>kata-containers</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/hyperhq/</span>runv</span><br><span class="line">　　　　https:<span class="regexp">//</span>katacontainers.io/</span><br><span class="line">　　　　https:<span class="regexp">//</span>katacontainers.io<span class="regexp">/learn/</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>www.infoq.cn<span class="regexp">/article/</span>OI-CCUqPe82xKUwtVoA2</span><br><span class="line">　　　　https:<span class="regexp">//</span>blog.csdn.net<span class="regexp">/weixin_44326589/</span>article<span class="regexp">/details/</span><span class="number">103726445</span></span><br><span class="line">　　　　https:<span class="regexp">//</span>www.kubernetes.org.cn<span class="regexp">/tags/</span>kubecon</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/D4650DCC5B7F45929D163F18DE88498D?method=download&shareKey=7a5f00386ee74a0e69543760367ef6e5" alt="img"></p>
<h2 id="12-podman"><a href="#12-podman" class="headerlink" title="12.podman"></a>12.<strong>podman</strong></h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Podman是一个无守护进程的容器引擎，用于在Linux系统上开发，管理和运行OCI容器。容器可以以root用户或无根模式运行。简而言之：alias docker = podman。</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span>年<span class="number">2</span>月，PodMan的v0.<span class="number">2</span>版本发布。Podman（POD管理器）是一种基于Apache-<span class="number">2.0</span> License开源工具，用于管理容器和镜像，安装在这些容器中的体积以及由容器组制成的容器。</span><br><span class="line"></span><br><span class="line">　　Podman基于libpod，libpod是一个用于容器生命周期管理的库，该库也包含在其中。libpod库提供用于管理容器，pod，容器映像和卷的API。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">　　　　https:<span class="regexp">//</span>podman.io/</span><br><span class="line">　　　　https:<span class="regexp">//gi</span>thub.com<span class="regexp">/containers/</span>podman</span><br></pre></td></tr></table></figure>



<h1 id="三-容器技术改变了传统部署应用程序的方式"><a href="#三-容器技术改变了传统部署应用程序的方式" class="headerlink" title="三.容器技术改变了传统部署应用程序的方式"></a>三.容器技术改变了传统部署应用程序的方式</h1><h2 id="1-容器和虚拟机之间的架构差异"><a href="#1-容器和虚拟机之间的架构差异" class="headerlink" title="1.容器和虚拟机之间的架构差异"></a>1.容器和虚拟机之间的架构差异</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">我们通常会说容器和虚拟化技术实现了一个互补，接下来我们来简单列举一下容器(Container)和虚拟机(<span class="keyword">virtual</span> machine)直接的差别。</span><br><span class="line">　　　　启动速度:</span><br><span class="line">　　　　　　Docker Container只需加载镜像文件，通常情况下是秒级(除非你的镜像不在本地，而是在公网上，这需要一个下载镜像的过程)。</span><br><span class="line">　　　　　　而<span class="keyword">virtual</span> machine需要启动宿主机,速度较慢。</span><br><span class="line">　　　　运行性能:</span><br><span class="line">　　　　　　接近原生物理系统，因为Docker Container和原生操作系统使用的是同一个kernel。</span><br><span class="line">　　　　　　而<span class="keyword">virtual</span> machine使用的宿主机的虚拟kernel，这意味着需要将虚拟kernel的指令经过编译，翻译成机器码交由物理kernel取执行。因此会多占用一些资源。</span><br><span class="line">　　　　镜像体积:</span><br><span class="line">　　　　　　Docker Container镜像基本上都是MB级别。</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine就需要ISO镜像来安装，官方有<span class="number">900</span>MB+(Minimal的ISO镜像),<span class="number">4</span>GB+(DVD的ISO镜像)，<span class="number">10</span>GB+(Everything的ISO镜像)等等。</span><br><span class="line">　　　　可管理性:</span><br><span class="line">　　　　　　Docker Container单进程(即进程级隔离)</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine是虚拟完整的系统管理(即系统级隔离，相对来隔离更彻底)</span><br><span class="line">　　　　资源利用率:</span><br><span class="line">　　　　　　一台物理机可以运行数百个容器Docker Container，但是一般只能运行数十多个<span class="keyword">virtual</span> machine。</span><br><span class="line">　　　　封装程度:</span><br><span class="line">　　　　　　Docker Container只打包项目代码及其运行环境所依赖的关系</span><br><span class="line">　　　　　　<span class="keyword">virtual</span> machine虚拟完整的操作系统。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/2E4759DCA4A144A4A307115113C633D2?method=download&shareKey=2c3f3d97bdf7270363f2f24fb8428015" alt="img"></p>
<h2 id="2-容器改变了部署方式"><a href="#2-容器改变了部署方式" class="headerlink" title="2.容器改变了部署方式"></a>2.容器改变了部署方式</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">传统部署时代： </span><br><span class="line">　　　　早期，组织在物理服务器上运行应用程序。无法为物理服务器中的应用程序定义资源边界，这会导致资源分配问题。</span><br><span class="line">　　　　例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况，结果，另一个应用程序的性能将下降。</span><br><span class="line">　　　　解决方案是在不同的物理服务器上运行每个应用程序。但是，这并没有随着资源利用不足而扩展，并且组织维护许多物理服务器的成本很高。</span><br><span class="line"></span><br><span class="line">　　虚拟化部署时代：</span><br><span class="line">　　　　作为解决方案，引入了虚拟化。</span><br><span class="line">　　　　它允许您在单个物理服务器的CPU上运行多个虚拟机（VM）。虚拟化允许在VM之间隔离应用程序，并提供安全级别，因为一个应用程序的信息不能被另一应用程序自由访问。</span><br><span class="line">　　　　虚拟化可以更好地利用物理服务器中的资源，并可以实现更好的可伸缩性，因为可以轻松地添加或更新应用程序，降低硬件成本等等。借助虚拟化，您可以将一组物理资源呈现为一组一次性虚拟机。</span><br><span class="line">　　　　每个VM都是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</span><br><span class="line"></span><br><span class="line">　　容器部署时代：</span><br><span class="line">　　　　容器类似于VM，但是它们具有轻松的隔离属性，可以在应用程序之间共享操作系统（OS）。因此，容器被认为是轻质的。</span><br><span class="line">　　　　与VM相似，容器具有自己的文件系统，CPU，内存，进程空间等的共享。由于它们与基础架构分离，因此可以跨云和OS分发进行移植。</span><br><span class="line"></span><br><span class="line">　　参考连接:</span><br><span class="line">　　　　https:<span class="regexp">//</span>kubernetes.io<span class="regexp">/docs/</span>concepts<span class="regexp">/overview/</span>what-is-kubernetes/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/551FA84F4E074D1B8DD63780D89360EF?method=download&shareKey=baa1a8d753fb6a6df08d470ae3755734" alt="img"></p>
<h1 id="四-chroot工具使用（了解即可）"><a href="#四-chroot工具使用（了解即可）" class="headerlink" title="四.chroot工具使用（了解即可）"></a>四.chroot工具使用（了解即可）</h1><h2 id="1-chroot概述"><a href="#1-chroot概述" class="headerlink" title="1.chroot概述"></a>1.chroot概述</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">chroot</span>(全称为:<span class="string">&quot;change root directory&quot;</span>)命令用来在指定的根目录下运行指令。在linux系统中，系统默认的目录结构都是以/，即是以根(root)开始的。而在使用<span class="keyword">chroot</span>之后，系统的目录结构将以指定的位置作为/位置。</span><br><span class="line"></span><br><span class="line">其实<span class="keyword">chroot</span>的概念我们并不是第一次接触了，还记得我们讲解的kafka在zookeeper的元数据znode位置吗？我们也为其指定了根znode哟~</span><br><span class="line"></span><br><span class="line">在经过<span class="keyword">chroot</span>之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下(即被指定的新的位置)的目录结构和文件，因此它带来的好处大致有以下<span class="number">3</span>个：</span><br><span class="line">	(<span class="number">1</span>)增加了系统的安全性，限制了用户的权力；</span><br><span class="line">		在经过<span class="keyword">chroot</span>之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。</span><br><span class="line">		这个一般是在登录(login)前使用<span class="keyword">chroot</span>，以此达到用户不能访问一些特定的文件。</span><br><span class="line"></span><br><span class="line">	(<span class="number">2</span>)建立一个与原系统隔离的系统目录结构，方便用户的开发；</span><br><span class="line">		使用<span class="keyword">chroot</span>后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。</span><br><span class="line">		在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。</span><br><span class="line"></span><br><span class="line">	(<span class="number">3</span>)切换系统的根目录位置，引导Linux系统启动以及急救系统等。</span><br><span class="line">		<span class="keyword">chroot</span>的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始RAM磁盘 (initrd) 切换系统的根位置并执行真正的init。</span><br><span class="line">		另外，当系统出现一些问题时，我们也可以使用<span class="keyword">chroot</span>来切换到一个临时的系统。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-centos测试"><a href="#2-centos测试" class="headerlink" title="2.centos测试"></a>2.centos测试</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># mkdir -pv oldboyedu/linux </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta">#</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># scp -r /usr/&#123;bin,lib64&#125; oldboyedu/linux/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/DBAA973F58584CE691A19000F3178114?method=download&shareKey=00f821858bc3da933fa2e653a3b168f9" alt="img"></p>
<h2 id="3-ubuntu测试"><a href="#3-ubuntu测试" class="headerlink" title="3.ubuntu测试"></a>3.ubuntu测试</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir -pv oldboyedu<span class="regexp">/linux/</span>&#123;bin,lib,lib64&#125;</span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/bin/</span>bash oldboyedu<span class="regexp">/linux/</span>bin/</span><br><span class="line"> </span><br><span class="line">cp <span class="regexp">/lib/</span>x86_64-linux-gnu<span class="regexp">/&#123;libtinfo.so.5,libdl.so.2,libc.so.6&#125; oldboyedu/</span>linux/lib</span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/lib/</span>x86_64-linux-gnu<span class="regexp">/ld-linux-x86-64.so.2 oldboyedu/</span>linux<span class="regexp">/lib64/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/67B91A6715A94E24A5E936B0FCAED97B?method=download&shareKey=60496ad4a8dd2e813c508e2510e28276" alt="image-20210629232129052"></p>
<h2 id="4-创建文件"><a href="#4-创建文件" class="headerlink" title="4.创建文件"></a>4.创建文件</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">bash</span>-<span class="number">4</span>.<span class="number">2</span># echo <span class="string">&quot;oldboyedu linux 2021&quot;</span> &gt; /oldboyedu.log </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/E224146AF87A45F8841A40708B23B2B1?method=download&shareKey=6501d4f6ef3781c06a81baebb856c57d" alt="image-20210629232454393"></p>
<h2 id="5-chroot的局限性"><a href="#5-chroot的局限性" class="headerlink" title="5.chroot的局限性"></a>5.chroot的局限性</h2><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">从<span class="keyword">chroot</span>的用法可以看出它的使用场景有一定的局限性，首先它依赖于一台现成的unix系统（根目录必须存在于某台现有系统上）。</span><br><span class="line"></span><br><span class="line">其次<span class="keyword">chroot</span>仅仅是在系统目录上进行了隔离，并没有对进程、环境变量，网络等层面进行隔离。因此我们说<span class="keyword">chroot</span>并不能完全保证系统安全。</span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">	(<span class="number">1</span>)如下图所示，演示了进程和环境变量并没有实现隔离；</span><br><span class="line">	(<span class="number">2</span>)此处的<span class="keyword">chroot</span>中无法使用ping命令或者ifconfig相关的命令，否则就可以进一步验证网络也没有隔离哟~</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/D467971654AB406093C01D555654D41F?method=download&shareKey=639a57ec915384074d5cb5716d7e41f8" alt="image-20210629232909485"></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/715783B7E3584337B5A4CF0A2AC4D7A9?method=download&shareKey=acd952c73bbdba74c9612951a4a70ef5" alt="image-20210629233508001"></p>
<h1 id="五-LXC容器管理工具使用（了解即可）"><a href="#五-LXC容器管理工具使用（了解即可）" class="headerlink" title="五.LXC容器管理工具使用（了解即可）"></a>五.LXC容器管理工具使用（了解即可）</h1><h2 id="1-centos按照lxc，lxd-比较麻烦"><a href="#1-centos按照lxc，lxd-比较麻烦" class="headerlink" title="1.centos按照lxc，lxd(比较麻烦)"></a>1.centos按照lxc，lxd(比较麻烦)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># yum -y install lxc lxd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>bbs.huaweicloud.com<span class="regexp">/blogs/</span><span class="number">150538</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	lxc:</span><br><span class="line">		客户端。</span><br><span class="line">	lxd:</span><br><span class="line">		服务端。</span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="2-ubuntu安装lxc，lxd"><a href="#2-ubuntu安装lxc，lxd" class="headerlink" title="2.ubuntu安装lxc，lxd"></a>2.ubuntu安装lxc，lxd</h2><figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">apt-<span class="keyword">get</span> -y install lxc lxd</span><br><span class="line"></span><br><span class="line"><span class="symbol">lxd:</span></span><br><span class="line">	服务端。</span><br><span class="line">	</span><br><span class="line"><span class="symbol">lxc:</span></span><br><span class="line">	客户端</span><br></pre></td></tr></table></figure>





<h2 id="3-检查内核对lxc的支持情况"><a href="#3-检查内核对lxc的支持情况" class="headerlink" title="3.检查内核对lxc的支持情况"></a>3.检查内核对lxc的支持情况</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># lxc-checkconfig </span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/CDBF782AD81F4AB9AC010A2BDB74F7BF?method=download&shareKey=bfb0b3276d7240854eb60679556a6cc7" alt="image-20210629234317680"></p>
<h2 id="4-下载镜像"><a href="#4-下载镜像" class="headerlink" title="4.下载镜像"></a>4.下载镜像</h2><figure class="highlight brainfuck"><table><tr><td class="code"><pre><span class="line"><span class="comment">lxc</span><span class="literal">-</span><span class="comment">create</span> <span class="literal">-</span><span class="comment">t</span> <span class="comment">download</span> --<span class="comment">name</span> <span class="comment">my_alpine2021</span> -- --<span class="comment">dist</span> <span class="comment">alpine</span> --<span class="comment">release</span> <span class="comment">lates</span></span><br><span class="line"><span class="comment">t</span> --<span class="comment">arch</span> <span class="comment">adm64</span> --<span class="comment">keyserver</span> <span class="comment">hkp://keyserver</span><span class="string">.</span><span class="comment">ubuntu</span><span class="string">.</span><span class="comment">com</span></span><br><span class="line"></span><br><span class="line"><span class="comment">相关参数说明:</span></span><br><span class="line"><span class="comment">	</span><span class="literal">-</span><span class="comment">t:</span></span><br><span class="line"><span class="comment">　　　　指定模板名称，我们这里指定download模板，就会调用&quot;/usr/share/lxc/templates/lxc</span><span class="literal">-</span><span class="comment">download&quot;脚本，该脚本说明我们目前没有自己的模板，需要下载官方的模板。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">name:</span></span><br><span class="line"><span class="comment">　　　　指定容器名称，即为创建的容器命名。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">:</span></span><br><span class="line"><span class="comment">　　　　用来说明后面的参数是传递给download脚本的，告诉脚本需要下载什么养的模板。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">dist:</span></span><br><span class="line"><span class="comment">　　　　操作系统名称，即指定操作系统。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">release:</span></span><br><span class="line"><span class="comment">　　　　指定操作系统的发行版本。可以是各种Linux的变种。</span></span><br><span class="line"><span class="comment">　　</span>--<span class="comment">arch:</span></span><br><span class="line"><span class="comment">　　　　指定CPU架构，是x86还是arm，是32位还是64位。　</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-管理lxc容器命令"><a href="#5-管理lxc容器命令" class="headerlink" title="5.管理lxc容器命令"></a>5.管理lxc容器命令</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">lxc-start my_alpi<span class="symbol">ne2021</span>:</span><br><span class="line"> 	启动lxc容器。</span><br><span class="line"> 	</span><br><span class="line">lxc-attach my_alpi<span class="symbol">ne2021</span>:</span><br><span class="line">	进入lxc容器。</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-lxc启动容器依赖于模板"><a href="#6-lxc启动容器依赖于模板" class="headerlink" title="6.lxc启动容器依赖于模板"></a>6.lxc启动容器依赖于模板</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">　　lxc启动容器依赖于模板，清华模板源：</span><br><span class="line">　　　　https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/help/</span>lxc-images/</span><br><span class="line"></span><br><span class="line">　　但是做模板相对较难，需要手动一步步构建文件系统，准备基础目录及可执行程序等，而且在大规模使用容器的场景很难横向扩展，另外后期代码升级也需要重新从头构建模板，基于以上种种原因便有了docker容器管理工具。</span><br></pre></td></tr></table></figure>





<h1 id="六-可能会遇到的报错"><a href="#六-可能会遇到的报错" class="headerlink" title="六.可能会遇到的报错"></a>六.可能会遇到的报错</h1><h2 id="1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory"><a href="#1-chroot-failed-to-run-command-‘-bin-bash’-No-such-file-or-directory" class="headerlink" title="1.chroot: failed to run command ‘/bin/bash’: No such file or directory"></a>1.chroot: failed to run command ‘/bin/bash’: No such file or directory</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">报错原因:</span><br><span class="line">	指定的chroot目录中没有‘<span class="regexp">/bin/</span>bash’文件。</span><br><span class="line"></span><br><span class="line">解决方案:</span><br><span class="line">	如下图所示，拷贝‘<span class="regexp">/bin/</span>bash’文件到指定的目录结构并将其依赖的库文件也要拷贝过去。此处我为了偷懒，就没进行拷贝。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/D871C9EE3C7948C8BEBF81A30E53DCD8?method=download&shareKey=899c49b50e6b59c7c900f3bdbf890e06" alt="image-20210629230138235"></p>
<h2 id="2-ERROR-Unable-to-fetch-GPG-key-from-keyserver"><a href="#2-ERROR-Unable-to-fetch-GPG-key-from-keyserver" class="headerlink" title="2.ERROR: Unable to fetch GPG key from keyserver"></a>2.ERROR: Unable to fetch GPG key from keyserver</h2><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">故障原因:</span><br><span class="line">	无法从密钥服务器获取GPG密钥。</span><br><span class="line">	</span><br><span class="line">解决方案:</span><br><span class="line">	方案一:</span><br><span class="line">		vim ~<span class="string">/.bashrc</span></span><br><span class="line">		export DOWNLOAD_KEYSERVER=<span class="string">&quot;keyserver.ubuntu.com&quot;</span></span><br><span class="line">		</span><br><span class="line">	方案二:</span><br><span class="line">		DOWNLOAD_KEYSERVER=<span class="string">&quot;keyserver.ubuntu.com&quot;</span> lxc-create -t download <span class="string">...</span></span><br><span class="line">	</span><br><span class="line">	方案三:</span><br><span class="line">		lxc-create -t download <span class="string">...</span> <span class="params">--keyserver</span> hkp:<span class="string">//keyserver.ubuntu.com</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Doker -</category>
      </categories>
      <tags>
        <tag>Doker -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件管理</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.文件管理概述 2.系统目录结构 3.文件路径定位 4.系统文件管理 5.系统文件属性 6.系统文件类型  7.系统链接文件</p>
<span id="more"></span>
<h1 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h1><p><em><strong>1.Bash Shell对文件进行管理</strong></em></p>
<p><em>谈到Linux文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？<br> 其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等<br> 例如: 当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</em></p>
<h1 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h1><p><em>几乎所有的计算机操作系统都是使用目录结构组织文件。具体来说就是在一个目录中存放子目录和文件, 而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支, 所以该结构又被称为“目录树”。<br> Windows: 以多根的方式组织文件 C:\ D:<br> Linux:以单根的方式组织文件   /</em></p>
<p><em><strong>1.存放命令相关的目录</strong></em></p>
<p><em>/bin， 普通用户使用的命令 /bin/ls, /bin/date</em><br><em>/sbin，管理员使用的命令 /sbin/service</em></p>
<p><em><strong>2.存放用户相关数据的家目录</strong></em></p>
<p><em>/home，普通用户的家目录, 默认为/home/username<br>/root，超级管理员root的家目录, 普通用户无权操作</em></p>
<p><em><strong>3.系统文件目录</strong></em></p>
<p><em>/usr，相当于C:\Windows<br>/usr/local，软件安装的目录，相当于C:\Program<br>/usr/bin/，普通用户使用的应用程序(重要)<br>/usr/sbin，管理员使用的应用程序(重要)<br>/usr/lib，库文件Glibc 32bit<br>/usr/lib64，库文件Glibc 64bit</em></p>
<p><em><strong>4.启动目录</strong></em></p>
<p>/boot 存放的系统启动相关的文件，例如:kernel，grub(引导装载程序)*</p>
<p><em><strong>5.配置文件目录</strong></em></p>
<p><em>/etc，极其重要，后续所有服务的配置都在这个目录中<br>/etc/sysconfig/network-script/ifcfg-，网络配置文件<br>/etc/hostname，系统主机名配置文件<br>/etc/resolv.conf，dns客户端配置文件<br>/etc/hosts，本地域名解析配置文件</em></p>
<p><em><strong>6.可变的目录与临时目录</strong></em></p>
<p><em>/var，存放一些变化文件，比如/var/log/下的日志文件<br>/var/tmp，进程产生的临时文件<br>/tmp，系统临时目录(类似于公共厕所)</em></p>
<p><em><strong>7.设备目录文件</strong></em></p>
<p><em>/dev，存放设备文件，比如硬盘，硬盘分区，光驱，等等<br>/dev/null，黑洞设备，只进不出。类似于垃圾回收站<br>/dev/random，生成随机数的设备<br>/dev/zero，能远远不断的产生数据，类似于取款机，随时随地取钱</em></p>
<p><em><strong>8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)</strong></em></p>
<p><em>/proc，反映系统当前进程的实时状态<br>PS：类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了。</em></p>
<p><em><strong>9.PS: 在Linux7系统中, /bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下</strong></em></p>
<p><em>/bin  –&gt; /usr/bin<br>/sbin –&gt; /usr/sbin<br>lib -&gt; usr/lib<br>lib64 -&gt; usr/lib64</em></p>
<h1 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h1><p><em>在我们开始操作文件前，首先需要对文件进行定位，比如:<br>你要在哪创建什么文件? 你要将文件复制到什么地方? 或者你要删除的文件在什么地方?<br>那什么是定位: 比如/etc/hostname，整个文件中包含文件名称以及文件所在的位置，我们将这个叫做路径，那么路径就是对文件进行定位的一种方式.</em></p>
<p><em><strong>1.每个目录下都有一个.和..的目录是干啥的?</strong></em><br> <em>一个点代表当的是当前目录, 两个点代表的是当前目录的上层目录。<br>假设当前目录在<code>/usr/</code>下, 那么它的上层(/)目录用<code>../</code>表示, 而<code>/usr/</code>的下层(local)目录则用<code>./local</code>表示。</em></p>
<p><em><strong>2.那什么是绝对路径，什么又是相对路径呢?</strong></em><br> <em>绝对路径: 只要从/开始的路径，比如/home/alice/file<br>相对路径: 相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3 [加入: 此时在目录/home/alice]<br>小结: 所谓的(.)和(..)目录实际上属于相对路径的一种表示形式。</em></p>
<p><em><strong>3.绝对路径与相对路径示例</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch file4</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure>

<p><em>cd改变目录，常见的使用方法</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>改变目录，常见的使用方法<span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure>

<h1 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h1><h2 id="1-文件管理之-创建-复制-移动-删除"><a href="#1-文件管理之-创建-复制-移动-删除" class="headerlink" title="1.文件管理之: 创建/复制/移动/删除"></a><em><strong>1.文件管理之: 创建/复制/移动/删除</strong></em></h2><p><em><strong>—————————————-创建—————————————-</strong></em></p>
<p><em>1.文件创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch file                    #无则创建,有则修改时间</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>2.目录创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>3.以树状显示目录结构命令tree</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cp复制—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-mv移动—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rm删除—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)"></a><em><strong>2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)</strong></em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure>

<h2 id="3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)"></a><em><strong>3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)</strong></em></h2><p><em><strong>—————————————-wget、curl联网下载文件—————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rzsz上传下载文件—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rz            #只能上传文件文件上传</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件管理之：文件或命令查找-locate、which、whereis、find"><a href="#4-文件管理之：文件或命令查找-locate、which、whereis、find" class="headerlink" title="4.文件管理之：文件或命令查找(locate、which、whereis、find)"></a><em><strong>4.文件管理之：文件或命令查找(locate、which、whereis、find)</strong></em></h2><p><em><strong>—————————————-文件查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-命令查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       //查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    //仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls        #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、"><a href="#5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、" class="headerlink" title="5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)"></a><em><strong>5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)</strong></em></h2><p><em><strong>—————————————-sort排序—————————————-</strong></em></p>
<p><em>在有些情况下，需要对应一个无序的文本文件进行数据的排序，这时就需要使用sort进行排序了。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例，下载文件http://fj.lucifer.com/public/ip.txt，对该文件进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-uniq去重—————————————</strong></em></p>
<p><em>如果文件中有多行完全相同的内容，当前是希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数, 那么就可以使用<code>uniq</code>命令解决这个问题(但是必须配合<code>sort</code>使用)。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cut截取字段—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-wc统计行号—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure>

<h1 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h1><p><em>当我们使用ls -l列目录下所有文件时，通常会以长格式的方式显示，其实长格式显示就是我们Windows下看到的文件详细信息，我们也将其称为文件属性，那整个文件的属性分为十列。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls -l ks.cfg</span></span><br><span class="line">-rw-------. 1 root root 4434 May 30 13:58 ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">4434        ⑤:文件大小</span><br><span class="line">May30 13:58 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure>

<h1 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h1><p><em>1.通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过ls -l以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure>

<p><em>2.但有些情况下，我们无法通过ls -l文件的类型，比如: 一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@lucifer ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure>

<p><em>PS: Linux文件扩展名不代表任何含义，仅为了我们能更好的识别该文件是什么类型。</em></p>
<h1 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h1><p><em>文件有文件名与数据，在Linux上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。<br>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方，我们将其称为Block<br>元数据，即文件的附加属性，如文件大小、创建时间、所有者等信息。我们称其为Inode<br>在Linux中，inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）<br>文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</em></p>
<h2 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)"></a><em><strong>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)</strong></em></h2><h3 id="1-什么是软链接"><a href="#1-什么是软链接" class="headerlink" title="1.什么是软链接"></a><em><strong>1.什么是软链接</strong></em></h3><p><em>软链接相当于Windows的快捷方式，软链接文件会将inode指向源文件的block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个inode指向同一个block。当我们删除软链接文件时，其实只是删除了一个inode指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。</em></p>
<h3 id="2-什么是硬链接"><a href="#2-什么是硬链接" class="headerlink" title="2.什么是硬链接"></a><em><strong>2.什么是硬链接</strong></em></h3><p><em>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，如下图hard link 就是 file 的一个别名，他们有共同的 inode。</em></p>
<p><em>软链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak</span><br><span class="line">ll /tmp/file_bak  //root下file链接到/tmp下并重命名为file_bak</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx</span><br><span class="line">ll /soft/nginx   //查看链接指向</span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure>

<p><em>硬链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">4.硬链接实践<span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard</span><br><span class="line">ll /tmp/file_hard</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS：目录不能创建硬链接，硬链接文件可以用rm命令删除</span></span><br></pre></td></tr></table></figure>

<h3 id="3-硬链接与软链接区别"><a href="#3-硬链接与软链接区别" class="headerlink" title="3.硬链接与软链接区别"></a><em>3.硬链接与软链接区别</em></h3><p> <em>1)ln命令创建硬链接，ln -s命令创建软链接。<br> 2)目录不能创建硬链接，并且硬链接不可以跨越分区系统。<br> 3)目录软链接特别常用,并且软链接支持跨越分区系统。<br> 4)硬链接文件与源文件的inode相同，软链接文件与源文件inode不同。<br> 5)删除软链接文件，对源文件及硬链接文件无任何影响。<br> 6)删除文件的硬链接文件，对源文件及链接文件无任何影响。<br> 7)删除链接文件的源文件，对硬链接无影响，会导致软链接失效。<br> 8)删除源文件及其硬链接文件，整个文件会被真正的删除。</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件编辑(vim)</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%EF%BC%88vim%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.VIM基本概述 2.VIM模式使用 3.VIM扩展知识 4.VIM练习示例</p>
<span id="more"></span>
<h1 id="1-vim基本概述"><a href="#1-vim基本概述" class="headerlink" title="1.vim基本概述"></a>1.vim基本概述</h1><p><em><strong>1.什么是vim</strong></em></p>
<p><em>vi和vim是Linux下的一个文本编辑工具。(可以理解为windows的记事本，或word文档)</em></p>
<p><em><strong>2.为什么要使用VIM?</strong></em></p>
<p><em>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</em></p>
<p><em><strong>3.VI与VIM有什么区别?</strong></em></p>
<p><em>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于window</em>s<em>系统下的文本编辑软件“记事本”与”notepad++”的区别)</em><br>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y安装*</p>
<p><em><strong>4.如何使用VIM编辑器?</strong></em></p>
<p><em>在使用VIM之前，我们需要先介绍下VIM的三种模式: 普通模式、编辑模式、命令模式，每种模式分别支持多种不同的快捷键，要想高效率地操作文本，那就必须先搞清这三种模式的操作区别以及模式之间的切换方法。</em></p>
<p><em><strong>5.VIM模式三种模式介绍</strong></em></p>
<p><em>1.普通模式: 主要是控制光标移动，可对文本进行复制、粘贴、删除等工作。<br> 使用vim filename 编辑一个文件时，一进入该文件就是普通模式了。<br> 在这个模式下，可以进行光标移动、复制、删除、粘贴操作。</em></p>
<p><em>2.编辑模式: 主要进行文本内容编辑和修改<br> 从普通模式进入编辑模式，只需你按一个键即可（i, I, a, A, o, O）<br> 当进入编辑模式时，会在屏幕的最下一行会出现 “INSERT”标记<br> 从编辑模式回到普通模式只需要按键盘左上方的 ESC 键即可。</em></p>
<p><em>3.末行模式: 主要用于保存或退出文本。<br> 在普通模式下，输入 “:” 或者 “/“ 即可进入命令模式。<br> 在命令该模式下，可进行的操作有，显示行号、搜索、替换、保存、退出。</em></p>
<p><em>小结: vim编辑打开文件整体流程如下:<br> 1.默认打开文件处于普通模式<br> 2.从普通模式切换至编辑模式需要使用a、i、o<br> 3.编辑模式修改完毕后需要先使用ECS返回普通模式<br> 4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br> PS: 在vim中，无法直接从编辑模式切换到命令模式。</em></p>
<h1 id="2-VIM模式使用"><a href="#2-VIM模式使用" class="headerlink" title="2.VIM模式使用"></a>2.VIM模式使用</h1><h2 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1.普通模式"></a><em>1.普通模式</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G       <span class="comment">#光标跳转至末端</span></span><br><span class="line">gg      <span class="comment">#光标跳转至顶端</span></span><br><span class="line">Ngg     <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$       <span class="comment">#光标跳转至当前光标所在行的尾部</span></span><br><span class="line">^|0     <span class="comment">#光标跳转至当前光标所在行的首部</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容较多</span></span><br><span class="line">ctrl+f  <span class="comment">#往下翻页(行比较多)</span></span><br><span class="line">ctrl+b  <span class="comment">#往上翻页</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.复制与粘贴</span></span><br><span class="line">yy      <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">5yy     <span class="comment">#复制当前光标以及光标向下4行</span></span><br><span class="line"> </span><br><span class="line">p(小写)   <span class="comment">#粘贴至当前光标下一行   </span></span><br><span class="line">P(大写)   <span class="comment">#粘贴至当前光标上一行</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.删除、剪贴、撤销  </span></span><br><span class="line">dd      <span class="comment">#删除当前光标所在的行   </span></span><br><span class="line">4dd     <span class="comment">#删除当前光标所在的行以及往下的3行</span></span><br><span class="line">dG      <span class="comment">#删除当前光标以后的所有行</span></span><br><span class="line">D       <span class="comment">#删除当前光标及光标以后的内容  </span></span><br><span class="line">x       <span class="comment">#删除当前光标标记往后的字符</span></span><br><span class="line">X       <span class="comment">#删除当前光标标记往前的字符</span></span><br><span class="line">dd &amp; p  <span class="comment">#剪贴、先删除dd(number dd)，后粘贴p</span></span><br><span class="line">u       <span class="comment">#撤销上一次的操作</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.替换</span></span><br><span class="line">r       <span class="comment">#替换当前光标标记的单个字符</span></span><br><span class="line">R       <span class="comment">#进入REPLACE模式, 连续替换，ESC结束</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编辑模式-从普通模式进入到编辑模式"><a href="#2-编辑模式-从普通模式进入到编辑模式" class="headerlink" title="2.编辑模式(从普通模式进入到编辑模式)"></a><em>2.编辑模式(从普通模式进入到编辑模式)</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i   <span class="comment">#进入编辑模式，光标不做任何操作</span></span><br><span class="line">a   <span class="comment">#进入编辑模式，将当前光标往后一位</span></span><br><span class="line">o   <span class="comment">#进入编辑模式，并在当前光标下添加一行空白内容</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">I   <span class="comment">#进入编辑模式，并且光标会跳转至本行的头部</span></span><br><span class="line">A   <span class="comment">#进入编辑模式，将光标移动至本行的尾部</span></span><br><span class="line">O   <span class="comment">#进入编辑模式，并在当前光标上添加一行空白内容</span></span><br></pre></td></tr></table></figure>

<h2 id="3-命令模式，主要用于搜索-保存-退出文件。"><a href="#3-命令模式，主要用于搜索-保存-退出文件。" class="headerlink" title="3.命令模式，主要用于搜索, 保存, 退出文件。"></a><em>3.命令模式，主要用于搜索, 保存, 退出文件。</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.文件保存与退出</span></span><br><span class="line">:w      保存当前状态</span><br><span class="line">:w!     强制保存当前状态</span><br><span class="line">:q      退出当前文档(文档必须保存才能退出)</span><br><span class="line">:q!     强制退出文档不会修改当前内容</span><br><span class="line">:wq     先保存，在退出</span><br><span class="line">:wq!    强制保存并退出</span><br><span class="line">:x      先保存，在退出</span><br><span class="line">ZZ      保存退出, shfit+zz</span><br><span class="line">:number 跳转至对应的行号</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容查找</span></span><br><span class="line">/string <span class="comment">#需要搜索的内容（查找）</span></span><br><span class="line">n       <span class="comment">#按搜索到的内容依次往下进行查找</span></span><br><span class="line">N       <span class="comment">#按搜索到的内容依次往上进行查找</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.文件内容替换</span></span><br><span class="line">:1,5s<span class="comment">#sbin#test#g   #替换1-5行中包含sbin的内容为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#g     #替换整个文本文件中包含sbin的替换为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#gc    #替换内容时时提示是否需要替换</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.文件内容另存</span></span><br><span class="line">:w /root/test.txt  <span class="comment">#将所有内容另存为/root/test.txt文件中</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.文件内容读入</span></span><br><span class="line">:r  /etc/hosts  <span class="comment">#读入/etc/hosts文件至当前光标下面</span></span><br><span class="line">:5r /etc/hosts  <span class="comment">#指定插入/etc/hosts文件至当前文件的第五行下面</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视图模式-从普通模式进入视图模式-，主要进行批量操作"><a href="#4-视图模式-从普通模式进入视图模式-，主要进行批量操作" class="headerlink" title="4.视图模式(从普通模式进入视图模式)，主要进行批量操作"></a><em>4.视图模式(从普通模式进入视图模式)，主要进行批量操作</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<h1 id="3-VIM扩展知识"><a href="#3-VIM扩展知识" class="headerlink" title="3.VIM扩展知识"></a>3.VIM扩展知识</h1><h2 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1.环境变量临时生效"></a><em>1.环境变量临时生效</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure>

<h2 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量"></a><em>2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3.如何同时编辑多个文件"></a><em>3.如何同时编辑多个文件</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure>

<h2 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4.相同文件之间差异对比，通常用于对比修改前后差异"></a><em>4.相同文件之间差异对比，通常用于对比修改前后差异</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后"><a href="#5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后" class="headerlink" title="5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后"></a><em>5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux特殊权限</title>
    <url>/2021/08/05/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.特殊权限概述  2.特殊权限SUID  3.特殊权限SGID  4.特殊权限SBIT  5.权限属性chattr  6.进程掩码umask</p>
<span id="more"></span>

<h1 id="1-特殊权限概述"><a href="#1-特殊权限概述" class="headerlink" title="1.特殊权限概述"></a>1.特殊权限概述</h1><p><em>前面我们已经学习过 r（读）、w（写）、 x（执行）这三种普通权限，但是我们在査询系统文件权限时会发现出现了一些其他权限字母，比如：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p><em>在属主本来应该是 x（执行）权限的位置出现了一个小写s，这是什么权限？我们把这种权限称作 SetUID 权限，也叫作 SUID 的特殊权限。这种权限有什么作用呢？或者说能干啥？别急，先往下看….</em></p>
<h1 id="2-特殊权限SUID"><a href="#2-特殊权限SUID" class="headerlink" title="2.特殊权限SUID"></a>2.特殊权限SUID</h1><p><em><strong>1.问题抛出</strong></em><br> <em>在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd  文件中，用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow  文件中的加密密码，但是文件权限显示，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的权限呢？……(难道学了个假的权限)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /etc/passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 6209 Apr 13 03:26 /etc/passwd</span><br><span class="line">[root@bgx ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">---------- 1 root root 11409 Apr 13 03:26 /etc/shadow</span><br></pre></td></tr></table></figure>

<p><em><strong>2.解决方案</strong></em></p>
<p><em>其实，普通用户可以修改自己的密码在于 passwd 命令。该命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。</em></p>
<p><em>PS: 当普通用户使用 passwd 命令更改自己的密码时，实际上是在用 passwd 命令所有者 root 的身份在执行  passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow  文件，命令执行完成后，该身份也随之消失。</em></p>
<p><em><strong>3.示例演示</strong></em></p>
<p><em>举个例子，有一个用户 lamp，她可以修改自己的密码，因为 passwd 命令拥有 SetUID 权限；但是她不能査看 /etc/shadow 文件的内容，因为査看文件的命令（如 cat）没有 SetUID 权限。命令如下：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自己可以修改自己的密码，从而改变/etc/shadow中的数据</span></span><br><span class="line">[lamp@bgx ~]$ passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#但无法使用cat命令查看/etc/shadow</span></span><br><span class="line">[lamp@bgx ~]$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure>

<p><em><strong>4.例子解释</strong></em></p>
<p><em>passwd 是系统命令，可以执行，所以可以赋予 SetUID 权限。<br>lamp 用户对 passwd 命令拥有 x（执行）权限。<br>lamp 用户在执行 passwd 命令的过程中，会暂时切换为 root 身份，所以可以修改 /etc/shadow 文件。<br>命令结束，lamp 用户切换回自己的身份。<br>PS: cat命令没有 SetUID权限，所以使用 lamp 用户身份去访问 /etc/shadow 文件，当然没有相应权限了。<br>F: 但如果将passwd命令的suid去掉会发生什么？？？</em></p>
<p><em>2.suid授权方法4000 权限字符s(S),用户位置上的x位上设置</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 4755 passwd</span></span><br><span class="line"><span class="comment"># chmod  u+s  passwd</span></span><br></pre></td></tr></table></figure>

<p><em>3.suid的作用</em><br> <em>1.让普通用户对可执行的二进制文件，临时拥有二进制文件的所属主权限。<br>2.如果设置的二进制文件没有执行权限,那么suid的权限显示就是大S。<br>3.特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效。<br>注意: suid极度危险，不信可以尝试对vim或rm进行设定SetUID。</em></p>
<h1 id="3-特殊权限SGID"><a href="#3-特殊权限SGID" class="headerlink" title="3.特殊权限SGID"></a>3.特殊权限SGID</h1><p><em>将目录设置为sgid后，如果在该目录下创建文件，都将与该目录的所属组保持一致，演示如下</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.建立测试目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># cd /tmp/ &amp;&amp; mkdir dtest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.给测试目录赋予SetGID权限，检查SetGID是否生效</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod g+s dtest/ &amp;&amp; ll -d dtest/</span></span><br><span class="line">drwxr-sr-x 2 root root 6 Apr 13 05:21 dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.给测试目录赋予777权限，让普通用户可以写</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod 777 dtest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.切换成普通用户lamp，并进入该目录</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># su - lamp</span></span><br><span class="line">[lamp@bgx ~]$ <span class="built_in">cd</span> /tmp/dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.普通用户创建测试文件，检查文件的信息</span></span><br><span class="line">[lamp@bgx dtest]$ touch lamp_test</span><br><span class="line">[lamp@bgx dtest]$ ll</span><br><span class="line">-rw-rw-r-- 1 lamp root 0 Apr 13 05:21 lamp_test</span><br></pre></td></tr></table></figure>

<p><em>2.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 2755  directory </span></span><br><span class="line"><span class="comment"># chmod  g+s  directory</span></span><br></pre></td></tr></table></figure>

<p><em>3.sgid作用<br>1.针对用户组权限位修改，用户创建的目录或文件所属组和该目录的所属组一致。<br>2.当某个目录设置了sgid后，在该目录中新建的文件不在是创建该文件的默认所属组<br>3.使用sgid可以使得多个用户之间共享一个目录的所有文件变得简单。</em></p>
<h1 id="4-特殊权限SBIT"><a href="#4-特殊权限SBIT" class="headerlink" title="4.特殊权限SBIT"></a>4.特殊权限SBIT</h1><p><em>Sticky(SI TI KI)粘滞位目前只对目录有效，作用如下：<br>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。如果没有粘滞位，那么普通用户拥有 w  权限，就可以删除此目录下的所有文件，包括其他用户建立的文件。但是一旦被赋予了粘滞位，除了 root 可以删除所有文件，普通用户就算拥有 w  权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx tmp]<span class="comment"># ll -d /tmp/</span></span><br><span class="line">drwxrwxrwt. 12 root root 4096 Apr 13 05:32 /tmp/</span><br></pre></td></tr></table></figure>

<p><em>sticky授权方法，1000 权限字符t(T),其他用户位的x位上设置。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 1755  /tmp</span></span><br><span class="line"><span class="comment"># chmod o+t /tmp</span></span><br></pre></td></tr></table></figure>

<p><em>3.sticky作用</em><br> <em>1.让多个用户都具有写权限的目录，并让每个用户只能删自己的文件。<br> 2.特殊sticky目录表现在others的x位，用小t表示，如果没有执行权限是T<br> 3.一个目录即使它的权限为”777”如果是设置了粘滞位，除了目录的属主和”root”用户有权限删除，除此之外其他用户都不允许删除该目录。</em></p>
<h1 id="5-权限属性chattr"><a href="#5-权限属性chattr" class="headerlink" title="5.权限属性chattr"></a>5.权限属性chattr</h1><p><em>chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。<br>chatrr 命令格式：[root@bgx ~]# chattr [+-=] [选项] 文件或目录名</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: + 增加权限 -减少权限 =等于某个权限</span></span><br><span class="line"><span class="comment"># a：让文件或目录仅可追加内容</span></span><br><span class="line"><span class="comment"># i：不得任意更动文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建文件并设置属性</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file_a file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">---------------- file_a</span><br><span class="line">---------------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用chattr设置属性，lsattr查看权限限制</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +a file_a</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +i file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">-----a---------- file_a</span><br><span class="line">----i----------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.a权限，无法写入和删除文件，但可以追加数据，适合/etc/passwd这样的文件</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt; file_a</span></span><br><span class="line">bash: file_a: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f file_a</span></span><br><span class="line">rm: cannot remove ‘file_a’: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt;&gt; file_a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.i权限, 无法写入，无法删除，适合不需要更改的重要文件加锁</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt;&gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f  file_i</span></span><br><span class="line">rm: cannot remove ‘file_i’: Operation not permitted</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解除限制</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -a file_a	</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -i file_i</span></span><br></pre></td></tr></table></figure>

<h1 id="6-进程掩码umask"><a href="#6-进程掩码umask" class="headerlink" title="6.进程掩码umask"></a>6.进程掩码umask</h1><p><em><strong>1.umask是什么?</strong></em><br> <em>当我们登录系统之后创建一个文件总是有一个默认权限的，比如: 目录755、文件644、那么这个权限是怎么来的呢？这就是umask干的事情。umask设置了用户创建文件的默认权限。</em></p>
<p><em><strong>2.umask是如何改变创建新文件的权限</strong></em><br><em>系统默认umask为022，那么当我们创建一个目录时，正常情况下目录的权限应该是777，但umask表示要减去的值，所以新目录文件的权限应该是777 - 022 =755。至于文件的权限也依次类推666 - 022 =644。</em></p>
<p><em><strong>3.umask涉及哪些配置文件</strong></em><br><em>umask涉及到的相关文件/etc/bashrc /etc/profile ~/.bashrc ~/.bash_profile<br> shell (vim,touch) –umask–&gt; 会影响创建的新文件或目录权限<br> vsftpd服务如果修改–umask–&gt; 会影响ftp服务中新创建文件或创建目录权限<br> useradd如果修改umask–&gt; 会影响用户HOME家目录权限</em></p>
<p><em><strong>4.umask演示示例</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.假设umask值为：022（所有位为偶数）</span></span><br><span class="line"><span class="comment">#文件的起始权限值</span></span><br><span class="line">6 6 6  -  0 2 2  = 6 4 4 </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.假设umask值为：045（其他用户组位为奇数）</span></span><br><span class="line"><span class="comment">#计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。</span></span><br><span class="line">6 6 6  -   0 4 5 = 6 2 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.默认目录权限计算方法</span></span><br><span class="line">7 7 7  -  0 2 2 = 7 5 5</span><br><span class="line"> </span><br><span class="line"><span class="comment">#umask所有位全为偶数时</span></span><br><span class="line"><span class="comment"># umask 044</span></span><br><span class="line"><span class="comment"># mkdir d044   目录权限为733</span></span><br><span class="line"><span class="comment"># touch f044   文件权限为622</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask部分位为奇数时</span></span><br><span class="line"><span class="comment"># umask 023</span></span><br><span class="line"><span class="comment"># mkdir d023   目录权限为754</span></span><br><span class="line"><span class="comment"># touch f023   文件权限为644	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask值的所有位为奇数时</span></span><br><span class="line"><span class="comment"># umask 035</span></span><br><span class="line"><span class="comment"># mkdir d035   目录权限为742</span></span><br><span class="line"><span class="comment"># touch f035   文件权限为642</span></span><br></pre></td></tr></table></figure>

<p><em>示例1: 在 shell 进程中创建文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前用户的umask权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d file0022  dir0022/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Jan 24 09:02 dir0022/</span><br><span class="line">-rw-r--r-- 1 root root 0 Jan 24 09:02 file0022</span><br></pre></td></tr></table></figure>

<p><em>示例2: 修改 shell umask 值(临时生效)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># umask 000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d dir000 file000</span></span><br><span class="line">drwxrwxrwx 2 root root 6 Jan 24 09:04 dir000</span><br><span class="line">-rw-rw-rw- 1 root root 0 Jan 24 09:04 file000</span><br></pre></td></tr></table></figure>

<p><em>示例3: 通过 umask 决定新建用户 HOME 目录的权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 077</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd dba</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/dba/</span></span><br><span class="line">drwx------. 4 dba dba 4096 3 月 11 19:50 /home/dba/</span><br><span class="line"></span><br><span class="line">[root@tianyun ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 000</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd sa</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/sa/</span></span><br><span class="line">drwxrwxrwx. 4 sa sa 4096 3 月 11 19:53 /home/sa/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux输入输出</title>
    <url>/2021/08/11/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.重定向概述 2.输出重定向 3.输入重定向 4.进程管道技术</p>
<span id="more"></span>

<h1 id="1-重定向概述"><a href="#1-重定向概述" class="headerlink" title="1.重定向概述"></a>1.重定向概述</h1><p><em><strong>1.什么是重定向</strong></em></p>
<p><em>将原本要输出到屏幕的数据信息，重新定向到某个指定的文件中。比如：每天凌晨定时备份数据，希望将备份数据的结果保存到某个文件中。这样第二天通过查看文件的内容就知道昨天备份的数据是成功还是失败。</em></p>
<p><em><strong>2.为什么要使用重定向</strong></em></p>
<p><em>1.当屏幕输出的信息很重要，而且希望保存重要的信息时；<br>2.后台执行中的程序，不希望他干扰屏幕正常的输出结果时；<br>3.系统的例行命令, 例如定时任务的执行结果，希望可以存下来时；<br>4.一些执行命令，我们已经知道他可能出现错误信息, 想将他直接丢弃时;<br>5.错误日志与正确日志需要分别输出至不同的文件保存时;</em></p>
<p><em><strong>3.学习重定向的预备知识，标准输入与输出</strong></em></p>
<p><em>当运行一个程序时通常会自动打开三个标准文件，分别是标准输入、标准输出、错误输出</em></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>文件描述符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入（STDIN）</td>
<td>0</td>
<td>默认是键盘，也可以是其他文件或其他命令的输出</td>
</tr>
<tr>
<td>标准输出（STDOUT）</td>
<td>1</td>
<td>默认输出到屏幕</td>
</tr>
<tr>
<td>错误输出（STDERR）</td>
<td>2</td>
<td>默认输出到屏幕</td>
</tr>
<tr>
<td>文件名称（filename）</td>
<td>3+</td>
<td></td>
</tr>
</tbody></table>
<p><em>进程将从标准输入中得到数据，将正常输出打印至屏幕终端，将错误的输出信息也打印至屏幕终端。<br>PS: 进程是使用文件描述符<code>(file descriptors)</code>来管理打开的文件</em></p>
<h1 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a>2.输出重定向</h1><table>
<thead>
<tr>
<th>类型</th>
<th>操作符</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>标准覆盖输出重定向</td>
<td>&gt;</td>
<td>将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td>
</tr>
<tr>
<td>标准追加输出重定向</td>
<td>&gt;&gt;</td>
<td>将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr>
<td>错误覆盖输出重定向</td>
<td>2&gt;</td>
<td>将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td>
</tr>
<tr>
<td>错误追加输出重定向</td>
<td>2&gt;&gt;</td>
<td>将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr>
<td>标准输入重定向</td>
<td>&lt;&lt;</td>
<td>将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td>
</tr>
</tbody></table>
<h1 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h1><p><em>输入重定向，即原本从键盘等上获得的输入信息，重定向由命令的输出作为输入。&lt; 等价 0&lt;</em></p>
<p><em>案例1: 从文件中读入输入的操作</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail alice </span></span><br><span class="line">Subject: hello</span><br><span class="line">1111 </span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">.   <span class="comment">#结束</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否收到邮件</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># su - alice</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入重定向，来自于文件</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail -s &quot;test01&quot; alice &lt; /etc/hosts</span></span><br></pre></td></tr></table></figure>

<p><em>案例2: 无法形容案例，请看实际操作</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘，此时等待输入</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># grep &#x27;root&#x27; </span></span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># grep &#x27;root&#x27; &lt; /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br></pre></td></tr></table></figure>

<p><em>案例3: 无法形容案例，请看实际操作</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># dd if=/dev/zero of=/file1.txt bs=1M count=20</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># dd &lt;/dev/zero &gt;/file2.txt bs=1M count=20</span></span><br></pre></td></tr></table></figure>

<p><em>案例4: mysql如何恢复备份，了解即可，不用关注。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># mysql -uroot -p123 &lt; bbs.sql</span></span><br></pre></td></tr></table></figure>

<p><em>案例5: 利用重定向建立多行数据的文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动执行 shell 命令</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># echo &quot;111&quot; &gt; file1.txt </span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat file1.txt</span></span><br><span class="line">111</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat &gt;file2.txt</span></span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">^D</span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat &gt;&gt;file3.txt</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">^D</span><br></pre></td></tr></table></figure>

<p><em>案例6: 脚本中打印菜单的一种使用方法。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># vim vm.sh</span></span><br><span class="line">cat &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">+------------------- --- ---- --- ---- --- --- ---- --- --+ ||</span></span><br><span class="line"><span class="string">| ====================== | </span></span><br><span class="line"><span class="string">| 虚拟机基本管理 v5.0 |</span></span><br><span class="line"><span class="string">| by xuliangwei |</span></span><br><span class="line"><span class="string">| ====================== | </span></span><br><span class="line"><span class="string">| 1. 安装 KVM |</span></span><br><span class="line"><span class="string">| 2. 安装或重置 CentOS-6.9 | </span></span><br><span class="line"><span class="string">| 3. 安装或重置 CentOS-7.4 | </span></span><br><span class="line"><span class="string">| 5. 安装或重置 Windows-7  | </span></span><br><span class="line"><span class="string">| 6. 删除所有虚拟机 |</span></span><br><span class="line"><span class="string">| q. 退出管理程序 |</span></span><br><span class="line"><span class="string">+------------------- --- ---- --- ---- --- --- ---- --- --+ </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p><em>案例7: 两条命令同时重定向</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># ls; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ls &amp;&gt;/dev/null; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (ls; date) &amp;&gt;/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;</span></span><br><span class="line">[1] 6378</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;date.txt &amp;</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># jobs</span></span><br><span class="line">[1]+ 运行中 ( <span class="keyword">while</span> :; <span class="keyword">do</span> date; sleep 2;</span><br><span class="line"><span class="keyword">done</span> ) &amp;&gt;/date.txt &amp;</span><br></pre></td></tr></table></figure>

<p><em>扩展点: subshell 了解即可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># cd /boot; ls</span></span><br><span class="line"></span><br><span class="line">//subshell 中执行</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (cd /boot; ls)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不希望某些命令的执行对当前 shell 环境产生影响，请在subshell中执行</span></span><br></pre></td></tr></table></figure>

<h1 id="4-进程管道技术"><a href="#4-进程管道技术" class="headerlink" title="4.进程管道技术"></a>4.进程管道技术</h1><p>*<strong>1.什么是管道*</strong><br> <em>管道操作符号 “|” ，主要用来连接左右两个命令, 将左侧的命令的标准输出, 交给右侧命令的标准输入<br>PS: 无法传递标准错误输出至后者命令</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>输入输出 -</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像常用命令</title>
    <url>/2021/08/16/docker%E9%95%9C%E5%83%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(1)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-docker常用命令概述"><a href="#一-docker常用命令概述" class="headerlink" title="一.docker常用命令概述"></a>一.docker常用命令概述</h1><span id="more"></span>
<h2 id="1-docker命令的使用方法"><a href="#1-docker命令的使用方法" class="headerlink" title="1.docker命令的使用方法"></a>1.docker命令的使用方法</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">如下图所示，对应的是docker命令的使用方法。</span><br><span class="line"></span><br><span class="line">root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBa1b09cd4e8367cff954da5894fd62145?method=download&shareKey=b79e77e15aae2b5c0eb95265453925bf" alt="image-20210609213405422"></p>
<h2 id="2-查看docker子命令的帮助信息"><a href="#2-查看docker子命令的帮助信息" class="headerlink" title="2.查看docker子命令的帮助信息"></a>2.查看docker子命令的帮助信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以查看docker命令的帮助信息哟<span class="operator">~</span></span><br><span class="line"></span><br><span class="line">root<span class="variable">@docker201</span>.oldboyedu.com <span class="operator">~</span>]# docker <span class="keyword">search</span> <span class="comment">--help</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB6e05b6635d195f21b94e1d8f640d1cb7?method=download&shareKey=974002314d9cfbb8263faf9e53cf84d0" alt="image-20210609214340268"></p>
<h2 id="3-镜像管理命令概述"><a href="#3-镜像管理命令概述" class="headerlink" title="3.镜像管理命令概述"></a>3.镜像管理命令概述</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">如下图所示，不难发现<span class="string">&quot;docker image ls&quot;</span>和<span class="string">&quot;docker images&quot;</span>的效果是一样的。<span class="string">&quot;docker image pull&quot;</span>和<span class="string">&quot;docker pull&quot;</span>效果是相同的。</span><br><span class="line"></span><br><span class="line">后者是较老docker版本者的使用习惯，有关镜像管理命令由于历史性原因保留了两种用法。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb0e3f973d439eba1eef3db8cfb1062cb?method=download&shareKey=23f3fb4eff247598f7b54f8a47ebfcdc" alt="image-20210609223402204"></p>
<h1 id="二-生产环境中常用的-docker镜像相关指令"><a href="#二-生产环境中常用的-docker镜像相关指令" class="headerlink" title="二.生产环境中常用的 docker镜像相关指令"></a>二.生产环境中常用的 docker镜像相关指令</h1><h2 id="1-搜索docker镜像-search"><a href="#1-搜索docker镜像-search" class="headerlink" title="1.搜索docker镜像(search)"></a>1.搜索docker镜像(search)</h2><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]<span class="meta"># docker search mysql</span></span><br><span class="line"></span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="meta"># docker search mysql --limit 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">搜索效果如下图所示，其提供了五个字段，分别代表的含义解释如下:</span><br><span class="line"><span class="symbol">	NAME:</span></span><br><span class="line">		镜像的名称。</span><br><span class="line"><span class="symbol">	</span></span><br><span class="line"><span class="symbol">	DESCRIPTION:</span></span><br><span class="line">    	镜像的描述信息。</span><br><span class="line"><span class="symbol">    	</span></span><br><span class="line"><span class="symbol">    STARS:</span></span><br><span class="line">    	镜像的星星数量，星星越多，说明受欢迎度越高哟~</span><br><span class="line"><span class="symbol">    	</span></span><br><span class="line"><span class="symbol">    OFFICIAL:</span></span><br><span class="line">    	该镜像是否是官方发布。</span><br><span class="line">    	</span><br><span class="line">    AUTOMATED</span><br><span class="line">		该镜像是否支持支持自动化构建功能。</span><br><span class="line">		</span><br><span class="line">温馨提示:</span><br><span class="line">	(<span class="number">1</span>)选镜像时建议优先考虑官方(OFFICIAL)和星星(STARS)数量较多的镜像，官方镜像仓库地址如下所示:</span><br><span class="line">	hub.docker.com</span><br><span class="line">	(<span class="number">2</span>)关于自动化构建，此处建议先战略性跳过，感兴趣的小伙伴可参考以下连接哟;</span><br><span class="line"><span class="symbol">	https:</span><span class="comment">//docs.docker.com/docker-hub/builds/</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBaaa2c96612a58cef5deb98e155635c7f?method=download&shareKey=f1c2441038068a631fd4a29b68fd9040" alt="image-20210609215802087"></p>
<h2 id="2-下载镜像-pull"><a href="#2-下载镜像-pull" class="headerlink" title="2.下载镜像(pull)"></a>2.下载镜像(pull)</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker pull nginx:1.20.1</span></span><br><span class="line"></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker pull nginx</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBfce8b97916ed696de7356e76ee0bc9d3?method=download&shareKey=12be685d09ee3c80a504e63e14650a8a" alt="image-20210609222829366"></p>
<h2 id="3-上传镜像-push，先战略性跳过"><a href="#3-上传镜像-push，先战略性跳过" class="headerlink" title="3.上传镜像(push，先战略性跳过)"></a>3.上传镜像(push，先战略性跳过)</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">在后面构建镜像仓库的时候讲解，此处战略性跳过。</span><br></pre></td></tr></table></figure>



<h2 id="4-查看本地镜像列表-ls"><a href="#4-查看本地镜像列表-ls" class="headerlink" title="4.查看本地镜像列表(ls)"></a>4.查看本地镜像列表(ls)</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker images</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB83aa1364dcf8b67a47486ce846338194?method=download&shareKey=feeeb9254f51a80eecdab20ee3184217" alt="image-20210609224007741"></p>
<h2 id="5-导出镜像-save"><a href="#5-导出镜像-save" class="headerlink" title="5.导出镜像(save)"></a>5.导出镜像(save)</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker save nginx:1.20.1 -o oldboyedu_docker_nginx.tar.gz</span></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">	如下图所示，我们可以基于镜像的ID从而导出指定的镜像。我不推荐这样做，因为导入镜像的时候会发现镜像名称和其版本号均为<span class="string">&quot;&lt;none&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB792460399beee2a5e441a474626151e3?method=download&shareKey=7a1a43b230e1e236e9dea135ec6216bf" alt="image-20210609224811160"></p>
<h2 id="6-删除镜像-rm"><a href="#6-删除镜像-rm" class="headerlink" title="6.删除镜像(rm)"></a>6.删除镜像(rm)</h2><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">[root@docker<span class="number">201.</span>oldboyedu.com ~]<span class="attr"># docker rmi 993</span>ef<span class="number">3592</span>f<span class="number">66</span>温馨提示:	<span class="comment">(1)</span>我们可以基于镜像的ID来删除指定的镜像文件，当然，也可以基于镜像名称和TAG编号一起删除;	<span class="comment">(2)</span>很明显<span class="string">&quot;docker image rm&quot;</span>有<span class="string">&quot;docker rmi&quot;</span>,<span class="string">&quot;docker remove&quot;</span>多个别名哟;	<span class="comment">(3)</span>使用<span class="string">&quot;docker rm&quot;</span>删除的是容器哟，而非镜像;	<span class="comment">(4)</span>想要批量删除镜像，可以先停止docker服务，然后将<span class="string">&quot;/var/lib/docker/*&quot;</span>目录全部删除，这意味着对docker进行初始化操作，因为它意味着删除了所有数据，该操作是不可逆的。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB626ccb680756386d7f9c08e5e912cc2c?method=download&shareKey=a0517324a685e303c0b3b8051d85bc80" alt="image-20210609231702768"></p>
<h2 id="7-导入镜像-load"><a href="#7-导入镜像-load" class="headerlink" title="7.导入镜像(load)"></a>7.导入镜像(load)</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker image load -i oldboyedu_docker_nginx.tar.gz </span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB98eda67f056a6b51e47dfa1f93ac94da?method=download&shareKey=90dca910bd88fe01bf9e7b358c29b1d5" alt="image-20210609232131913"></p>
<h2 id="8-导入镜像-import"><a href="#8-导入镜像-import" class="headerlink" title="8.导入镜像(import)"></a>8.导入镜像(import)</h2><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">如下图所示，使用<span class="keyword">import</span>指令也可以导入镜像，但都没有名字哟~	请先允许我买个关子哈，后面给大家介绍一下它的妙用哟！</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc3f8a54d9320315c7f7ff5c5442baa72?method=download&shareKey=c23168b37d24ef706578dfd95065874d" alt="image-20210609234235462"></p>
<h2 id="9-打标签-tag"><a href="#9-打标签-tag" class="headerlink" title="9.打标签(tag)"></a>9.打标签(tag)</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以为一个镜像打多个标签哟~</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb4cfc8c013b11809d5b2cafd8f768f76?method=download&shareKey=bbf931b6eaf86df870c85747556a1945" alt="image-20210610000547806"></p>
<h2 id="10-清除无效镜像-prune"><a href="#10-清除无效镜像-prune" class="headerlink" title="10.清除无效镜像(prune)"></a>10.清除无效镜像(prune)</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">如下图所示，我们可以清理无效的镜像。所谓的无效的镜像我们指的就是没有镜像名称和标签的。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBdd07e56007d4e20ed0796223213c22fb?method=download&shareKey=e5b489a02a2be0070d56640c9ae3145d" alt="image-20210610000922663"></p>
<h2 id="11-构建镜像-build，战略性跳过"><a href="#11-构建镜像-build，战略性跳过" class="headerlink" title="11.构建镜像(build，战略性跳过)"></a>11.构建镜像(build，战略性跳过)</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">docker image <span class="keyword">build </span>-t oldboyedu_dockerfile_xiaoniao:<span class="built_in">v1</span> .</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB14a2c2d450069aa8557b4d4651cde152?method=download&shareKey=291fdf5664cded2e6a4545140031da07" alt="image-20210616224136999"></p>
<h2 id="12-查看构建历史-history，战略性跳过"><a href="#12-查看构建历史-history，战略性跳过" class="headerlink" title="12.查看构建历史(history，战略性跳过)"></a>12.查看构建历史(history，战略性跳过)</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">docker image <span class="keyword">history</span> cento<span class="variable">s:7</span> --<span class="keyword">no</span>-<span class="built_in">trunc</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBf9169889087fb0b58b1b2bb4758b31fd?method=download&shareKey=0279059f27439fce1252af6baf0740cc" alt="image-20210616235412627"></p>
<h2 id="13-查看镜像属性-inspect，战略性跳过"><a href="#13-查看镜像属性-inspect，战略性跳过" class="headerlink" title="13.查看镜像属性(inspect，战略性跳过)"></a>13.查看镜像属性(inspect，战略性跳过)</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">后期会补，此处先跳过。</span><br></pre></td></tr></table></figure>

<h1 id="三-课堂练习"><a href="#三-课堂练习" class="headerlink" title="三.课堂练习"></a>三.课堂练习</h1><h2 id="1-批量导入镜像"><a href="#1-批量导入镜像" class="headerlink" title="1.批量导入镜像"></a>1.批量导入镜像</h2><h3 id="请批量导入镜像"><a href="#请批量导入镜像" class="headerlink" title="请批量导入镜像"></a>请批量导入镜像</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">如下图所示，以oldboyedu开头的都是我提前打包好的镜像，请批量完成打包操作。</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEBc318f490aef27748b0be3970515c13c8?method=download&shareKey=52bf1d33ba0e9668d5f9254505cb768e" alt="image-20210610004039213"></p>
<h3 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]# <span class="keyword">for</span> <span class="keyword">image</span> <span class="keyword">in</span> <span class="string">`ls *.tar.gz`</span>; <span class="keyword">do</span> docker load -i $image; done</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB4bc9b0ac34f5e1893979ba4e6d8b29e5?method=download&shareKey=d32997c9e0e92f62c48a6903272c54c6" alt="image-20210610004612153"></p>
<h2 id="2-批量导出镜像"><a href="#2-批量导出镜像" class="headerlink" title="2.批量导出镜像"></a>2.批量导出镜像</h2><h3 id="请批量导出镜像"><a href="#请批量导出镜像" class="headerlink" title="请批量导出镜像"></a>请批量导出镜像</h3><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">请将上述案例的<span class="string">&quot;nginx:latest&quot;</span>和<span class="string">&quot;mysql:latest&quot;</span>两个软件包打包到同一个文件中。</span><br></pre></td></tr></table></figure>



<h3 id="参考案例-1"><a href="#参考案例-1" class="headerlink" title="参考案例"></a>参考案例</h3><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker save -o oldboyedu_docker_demo.tar.gz nginx:latest mysql:latest</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB0ff6f2fc014e3a2bc9392b49102d81d5?method=download&shareKey=6869c3f127ec541ab17f846906f263a4" alt="image-20210610005328968"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令详解</title>
    <url>/2021/08/06/find%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p><em>find命令</em></p>
<span id="more"></span>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">一般格式： find  +  目录名称  +  参数</span><br></pre></td></tr></table></figure>



<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">参数的含义：</span><br><span class="line"></span><br><span class="line">-name           #文件名称</span><br><span class="line">-not            #非，取反</span><br><span class="line">-user           #文件所有人</span><br><span class="line">-group          #文件所有组</span><br><span class="line">-a              #并且关系</span><br><span class="line">-o              #或者关系</span><br><span class="line">-maxdepth       #最大深度</span><br><span class="line">-mindepth       #最小深度</span><br><span class="line"></span><br><span class="line">-size 表示文件大小</span><br><span class="line">     -size  20K      # 查找大小为20K的文件</span><br><span class="line">     -size  -20K     # -表示小于；查找比20K小的文件</span><br><span class="line">     -size  +20k     # +表示大于；查看比20K大的文件</span><br><span class="line"></span><br><span class="line">-type           #文件类型</span><br><span class="line"> 主要的文件类型：</span><br><span class="line">     f     #普通文件</span><br><span class="line">     d     #目录</span><br><span class="line">     b     #块设备</span><br><span class="line">     s     #套接字</span><br><span class="line">     c     #字符设备</span><br><span class="line">     l     #链接</span><br><span class="line">     p     #管道</span><br><span class="line">     </span><br><span class="line">-perm   表示权限</span><br><span class="line">   -perm  444       #查找文件权限</span><br><span class="line">   -perm  -444      # -表示并且；查找文件权限中u位有r权限，并且g位有r权限，并且o位有r权限的文件</span><br><span class="line">   -perm  /444      # /表示或者；查找文件权限中u位有r权限，或者g位有r权限，或者o位有r权限的文件</span><br><span class="line">   -perm  /777      # 777=rwx rwx rwx 即9个条件中满足任意一个即可</span><br><span class="line">   </span><br><span class="line">ctime 与 cmin 都表示按照时间查找被篡改的文件</span><br><span class="line">ctime   ##以天为单位</span><br><span class="line">cmin    ##以分钟为单位 </span><br><span class="line">   -cmin  10         #查找文件更新距离现在10分钟的文件</span><br><span class="line">   -cmin  +10        #查找文件更新距离现在超过10分钟的文件</span><br><span class="line">   -cmin  -10        #查找文件更新距离现在10分钟以内的文件</span><br><span class="line">   -ctime  +/-10     #查找文件更新距离现在超过10天/10天以内的文件</span><br><span class="line"></span><br><span class="line">-exec   命令  &#123;&#125;   \;      #对查找到的文件执行某命令；-exec表示开始执行动作  &#123;&#125; 表示用find命令查找出的所有文件</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h4 id="实例1：按照文件名查找"><a href="#实例1：按照文件名查找" class="headerlink" title="实例1：按照文件名查找"></a><em><strong>实例1：按照文件名查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查找/etc目录中文件名为passwd的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##查找/etc目录中文件名以.conf文件结尾的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /etc/ -name *.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="实例2：按文件所有人和文件所有组查找"><a href="#实例2：按文件所有人和文件所有组查找" class="headerlink" title="实例2：按文件所有人和文件所有组查找"></a><em><strong>实例2：按文件所有人和文件所有组查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##按文件的所有人查找</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user student </span></span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##按文件的所有组查找</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##默认表示并且</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">## -a表示并且</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -a -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">## -o表示或者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -o -group westos</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line">/mnt/file4</span><br><span class="line">/mnt/file5</span><br><span class="line"><span class="comment">## -not表示非；即反向选择</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -not -user student </span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file4</span><br><span class="line">/mnt/file5</span><br></pre></td></tr></table></figure>

<h4 id="实例3：按文件所在的深度（层次）查找"><a href="#实例3：按文件所在的深度（层次）查找" class="headerlink" title="实例3：按文件所在的深度（层次）查找"></a><em><strong>实例3：按文件所在的深度（层次）查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##-maxdepth表示最大深度，即最多层次</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -maxdepth 1 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -maxdepth 2 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##-mindepth表示最小深度，即最少层次</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 2 -name passwd</span></span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 1 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##查找/etc目录下最少层次为1最多层次为2的以.conf结尾的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 1 -maxdepth 2 -name *.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="实例4：按文件的大小查找"><a href="#实例4：按文件的大小查找" class="headerlink" title="实例4：按文件的大小查找"></a><em><strong>实例4：按文件的大小查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost mnt]<span class="comment"># ll -l</span></span><br><span class="line">total 72</span><br><span class="line">-rw-r--r--. 1 root root 10240 Nov 11 04:06 file1</span><br><span class="line">-rw-r--r--. 1 root root 20480 Nov 11 04:06 file2</span><br><span class="line">-rw-r--r--. 1 root root 40960 Nov 11 04:06 file3</span><br><span class="line"><span class="comment">##查找/mnt目录下文件大小为20k的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size 20k</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查找/mnt目录下比20k小的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size -20k</span></span><br><span class="line">/mnt/</span><br><span class="line">/mnt/file1</span><br><span class="line"><span class="comment">##查找/mnt目录下比20k大的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size +20k</span></span><br><span class="line">/mnt/file3</span><br></pre></td></tr></table></figure>

<h4 id="实例5：按文件类型查找"><a href="#实例5：按文件类型查找" class="headerlink" title="实例5：按文件类型查找"></a><em><strong>实例5：按文件类型查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##f表示普通文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type f</span></span><br><span class="line">/dev/shm/pulse-shm-620843697</span><br><span class="line">/dev/shm/pulse-shm-1247103260</span><br><span class="line">/dev/shm/pulse-shm-2690706600</span><br><span class="line">/dev/shm/pulse-shm-368331657</span><br><span class="line"><span class="comment">##b表示块设备</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type b</span></span><br><span class="line">/dev/dm-0</span><br><span class="line">/dev/sr0</span><br><span class="line">/dev/vdb1</span><br><span class="line">/dev/vdb</span><br><span class="line">/dev/vda1</span><br><span class="line">/dev/vda</span><br><span class="line"><span class="comment">##s表示套接字</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type s</span></span><br><span class="line">/dev/<span class="built_in">log</span></span><br><span class="line"><span class="comment">##p表示管道</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type p</span></span><br><span class="line">/dev/initctl</span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -type f</span></span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file3</span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##d表示目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -type d</span></span><br><span class="line">/mnt</span><br></pre></td></tr></table></figure>

<h4 id="实例6：按文件权限查找"><a href="#实例6：按文件权限查找" class="headerlink" title="实例6：按文件权限查找"></a><em><strong>实例6：按文件权限查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查找文件权限为404的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm 404</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查看文件权限中u位有r权限，并且o位有r权限的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm -404</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查看文件权限中u位有r权限，或者o位有r权限的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm /404</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line">[root@localhost mnt]<span class="comment"># ll -d /mnt/</span></span><br><span class="line">drwxr-xr-x. 2 root root 42 Nov 14 09:41 /mnt/</span><br></pre></td></tr></table></figure>

<h4 id="实例7：按文件更新的时间"><a href="#实例7：按文件更新的时间" class="headerlink" title="实例7：按文件更新的时间"></a><em><strong>实例7：按文件更新的时间</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /mnt</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># rm -rf *</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ls</span></span><br><span class="line"><span class="comment">##建立文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment">##查找文件更新距离现在为1分钟的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime 1</span></span><br><span class="line"><span class="comment">##查找文件更新距离现在为1分钟以内的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime -1</span></span><br><span class="line">/mnt/</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##查找文件更新距离现在超过1分钟的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime +1</span></span><br></pre></td></tr></table></figure>

<h4 id="实例8：对查找到的文件执行某些动作"><a href="#实例8：对查找到的文件执行某些动作" class="headerlink" title="实例8：对查找到的文件执行某些动作"></a><em><strong>实例8：对查找到的文件执行某些动作</strong></em></h4><h5 id="1-给-mnt下文件权限包含004的文件的g位加w的权限"><a href="#1-给-mnt下文件权限包含004的文件的g位加w的权限" class="headerlink" title="(1).给/mnt下文件权限包含004的文件的g位加w的权限"></a><strong>(1).给/mnt下文件权限包含004的文件的g位加w的权限</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost mnt]<span class="comment"># pwd</span></span><br><span class="line">/mnt</span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##更改权限</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># chmod 404 /mnt/file2</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r-----r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##给/mnt下文件权限包含004的文件的g位加w的权限</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm 404 -exec chmod g+w &#123;&#125; \;</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br></pre></td></tr></table></figure>

<h5 id="2-将系统中属于mail组的文件备份到-mnt下"><a href="#2-将系统中属于mail组的文件备份到-mnt下" class="headerlink" title="(2).将系统中属于mail组的文件备份到/mnt下"></a><em><strong>(2).将系统中属于mail组的文件备份到/mnt下</strong></em></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ll /mnt</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##将系统中属于mail组的文件备份到/mnt下</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find / -group mail -exec cp &#123;&#125; /mnt \;</span></span><br><span class="line">find: ‘/proc/6812/task/6812/fd/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/task/6812/fdinfo/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/fd/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/fdinfo/6’: No such file or directory</span><br><span class="line">cp: omitting directory ‘/var/spool/mail’</span><br><span class="line">[root@localhost ~]<span class="comment"># ll /mnt</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 rpc</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 student</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 westos</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>命令 -</tag>
      </tags>
  </entry>
  <entry>
    <title>yum仓库</title>
    <url>/2021/08/12/yum%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>


<h1 id="搭建公司内部的yum源，搭建yum仓库"><a href="#搭建公司内部的yum源，搭建yum仓库" class="headerlink" title="搭建公司内部的yum源，搭建yum仓库"></a>搭建公司内部的yum源，搭建yum仓库</h1><span id="more"></span>

<h3 id="1，基础环境准备"><a href="#1，基础环境准备" class="headerlink" title="1，基础环境准备"></a>1，基础环境准备</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭selinux，方式1</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s#SELINUX=enforcing#SELINUX=disabled#g&#x27;</span><br><span class="line">/etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭selinux的，方式2</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">修改为SELINUX=disabled</span><br></pre></td></tr></table></figure>

<h3 id="2，安装ftp服务，并设置开机启动"><a href="#2，安装ftp服务，并设置开机启动" class="headerlink" title="2，安装ftp服务，并设置开机启动"></a>2，安装ftp服务，并设置开机启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装ftp服务</span></span><br><span class="line">yum install -y vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash">启动ftp服务</span></span><br><span class="line">systemctl start vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash">设置为开机启动</span></span><br><span class="line">systemctl enable vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="3，开启yum缓存功能"><a href="#3，开启yum缓存功能" class="headerlink" title="3，开启yum缓存功能"></a>3，开启yum缓存功能</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启yum缓存功能</span></span><br><span class="line">vim /etc/yum.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改为</span></span><br><span class="line">vim /etc/yum.conf</span><br><span class="line">[main] </span><br><span class="line">cachedir=/var/cache/yum/$basearch/$releasever</span><br><span class="line">keepcache=1</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存</span></span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure>

<h3 id="4，提供基础base源-epel源"><a href="#4，提供基础base源-epel源" class="headerlink" title="4，提供基础base源/epel源"></a>4，提供基础base源/epel源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建base源仓库</span></span><br><span class="line">mkdir -p /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">挂载光盘镜像</span></span><br><span class="line">mount /dev/cdrom /mnt/</span><br><span class="line"><span class="meta">#</span><span class="bash">将光盘中的rpm包复制到源仓库</span></span><br><span class="line">cp -a /mnt/Packages/*.rpm /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">创建epel源仓库</span></span><br><span class="line">mkdir -p /var/ftp/epel</span><br><span class="line"><span class="meta">#</span><span class="bash">下载elep源中的服务</span></span><br><span class="line">yum install -y nginx sl docker</span><br><span class="line"><span class="meta">#</span><span class="bash">复制epel源服务到epel源仓库</span></span><br><span class="line">find /var/cache/yum/ -type f -name &quot;*.rpm&quot; |xargs cp -t /var/ftp/epel</span><br></pre></td></tr></table></figure>

<h3 id="5，安装createrepo并创建reopdata仓库"><a href="#5，安装createrepo并创建reopdata仓库" class="headerlink" title="5，安装createrepo并创建reopdata仓库"></a>5，安装createrepo并创建reopdata仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装 createrepo</span></span><br><span class="line">yum install -y createrepo</span><br><span class="line"><span class="meta">#</span><span class="bash">生成base源仓库信息</span></span><br><span class="line">createrepo /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">生成elep源仓库信息</span></span><br><span class="line">createrepo /var/ftp/epel</span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果此仓库每新增一次软件，需要重新生成一次</span></span><br></pre></td></tr></table></figure>

<h3 id="6，客户端yum源设置"><a href="#6，客户端yum源设置" class="headerlink" title="6，客户端yum源设置"></a>6，客户端yum源设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将原有的yum源压缩</span></span><br><span class="line">gzip /etc/yum.repos.d/*</span><br><span class="line"><span class="meta">#</span><span class="bash">·</span>	</span><br><span class="line">vim /etc/yum.repo.d/CentOS7</span><br><span class="line">i</span><br><span class="line"><span class="meta">#</span><span class="bash">新建epel源</span></span><br><span class="line">vim /etc/yum.repo.d/epel.repo</span><br><span class="line">[epel]</span><br><span class="line">name=local ftpserver</span><br><span class="line">baseurl=ftp://10.0.0.105/epel</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">rsync  nfs-utils mariadb-<span class="keyword">server</span>  MySQL-python redis  nginx GeoIP-devel ncurses-devel keepalived </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mkdir</span> <span class="string">/opt/yum</span></span><br><span class="line">  <span class="attr">file:</span> </span><br><span class="line">    <span class="attr">path:</span> <span class="string">/opt/yum</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">移动原有源</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">&quot;mv -f /etc/yum.repos.d/* /opt/yum&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Centos7.repo</span></span><br><span class="line">  <span class="attr">yum_repository:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">centos7</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">Centos7.repo</span></span><br><span class="line">    <span class="attr">baseurl:</span> <span class="string">ftp://10.0.0.61/CentOS7</span> </span><br><span class="line">    <span class="attr">gpgcheck:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">repo</span></span><br><span class="line">  <span class="attr">yum_repository:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">repo</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">epel</span> <span class="string">repo</span></span><br><span class="line">    <span class="attr">baseurl:</span> <span class="string">ftp://10.0.0.61/epel</span></span><br><span class="line">    <span class="attr">gpgcheck:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>yum仓库 -</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化和云计算的区别</title>
    <url>/2021/08/16/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%92%8C%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一-Docker架构分析"><a href="#一-Docker架构分析" class="headerlink" title="一.Docker架构分析"></a>一.Docker架构分析</h1><span id="more"></span>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">如下图所示，Docker采用的是 Client/Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。</span><br><span class="line"></span><br><span class="line">　　客户端和服务器可以运行在同一个 Host 上，客户端也可以通过socket或 REST API与远程的服务器通信。</span><br><span class="line">　　</span><br><span class="line">　　推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/get-started/</span>overview/</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB3031069c14b2641550ed11dbcbbc4fc1?method=download&shareKey=983cfe4b6cdf65ec627e1c390c4e6932" alt="img"></p>
<h2 id="1-Client"><a href="#1-Client" class="headerlink" title="1.Client"></a>1.Client</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">　　Docker客户端，最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</span><br><span class="line">　　    </span><br><span class="line">　　docker支持很多操作(docker命令行工具)，用户也可以通过REST API与服务器通信。</span><br><span class="line">　　    </span><br><span class="line">　　Client和Docker daemon通信可使用<span class="keyword">https</span>/<span class="keyword">http</span>协议进行通信，为了安全起见，默认使用的就是<span class="keyword">https</span>协议。</span><br></pre></td></tr></table></figure>



<h2 id="2-Docker-Host"><a href="#2-Docker-Host" class="headerlink" title="2.Docker-Host"></a>2.Docker-Host</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Docker daemon： 　</span><br><span class="line">　　　　Docker daemon是服务器组件，即Docker守护进程服务器，以Linux后台服务的方式运行。</span><br><span class="line">　　　　Docker daemon运行在Docker host上，负责创建、运行、监控容器，构建、存储镜像。默认配置下，Docker daemon只能响应来自本地Host的客户端请求。如果要允许远程客户端请求，需要在配置文件中打开TCP监听（支持IPV4和IPV6）。</span><br><span class="line">       </span><br><span class="line">　　Containers： 　　</span><br><span class="line">　　　　Docker容器，用于加载Docker镜像。换句话说，Docker容器就是Docker镜像的运行实例。我们知道镜像(Image)是只读的，在启动一个Container时，其实就是基于Image来新建一个专用的可写仓供用户使用。</span><br><span class="line">       </span><br><span class="line">　　Image： 　　</span><br><span class="line">　　　　可将Docker镜像看成只读模板(它类似于虚拟机使用的ISO镜像文件)，通过它可以创建Docker容器。例如某个镜像可能包含一个Ubuntu操作系统、一个Apache HTTP Server以及用户开发的Web应用。</span><br><span class="line">　　　　镜像有多种生成方法：</span><br><span class="line">　　　　　　(<span class="number">1</span>)可以从无到有开始创建镜像；</span><br><span class="line">　　　　　　(<span class="number">2</span>)也可以下载并使用别人创建好的现成的镜像</span><br><span class="line">　　　　　　(<span class="number">3</span>)还可以在现有镜像上创建新的镜像</span><br><span class="line">　　　　　　(<span class="number">4</span>)我们可以将镜像的内容和创建步骤描述在一个文本文件中，这个文件被称作Dockerfile，通过执行docker build &lt;docker-file&gt;命令可以构建出Docker镜像。</span><br><span class="line">　　　　公开的镜像仓库有很多种，如下所示: </span><br><span class="line">　　　　　　Docker官方镜像地址：</span><br><span class="line">　　　　　　　　https:<span class="regexp">//</span>hub.docker.com/。</span><br><span class="line">　　　　　　阿里的docker镜像地址：</span><br><span class="line">　　　　　　　　https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux/</span><br><span class="line">　　　　　　清华大学docker镜像地址：</span><br><span class="line">　　　　　　 https:<span class="regexp">//mi</span>rrors.tuna.tsinghua.edu.cn<span class="regexp">/docker-ce/</span></span><br><span class="line"></span><br><span class="line">　　温馨提示:</span><br><span class="line">　　　　生产环境中，我们通常在公司内部部署有私有镜像仓库。如使用Harbor，Docker Registry等等。在后续的文章我们会逐一对其进行讲解。</span><br></pre></td></tr></table></figure>



<h2 id="3-Registry"><a href="#3-Registry" class="headerlink" title="3.Registry"></a>3.Registry</h2><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">我们去构建镜像时，镜像做好之后应该有一个统一存放位置，我们称之为Docker仓库，Registry是存放Docker镜像的仓库（官方默认仓库在<span class="string">&quot;https://hub.docker.com&quot;</span>），Registry分私有和公有两种。</span><br><span class="line"></span><br><span class="line">Images和Registry之间默认使用的时https协议，当然如果你非要指定为<span class="keyword">http</span>协议也是可以的。</span><br><span class="line"></span><br><span class="line">启动容器时，docker daemon会试图从本地获取相关的镜像；本地镜像不存在时，其将从Registry中下载该镜像并保存到本地。　　</span><br><span class="line"></span><br><span class="line">Registry用于保存docker镜像，包括镜像的层次结构和元数据。用户可自建Registry，也可使用官方的Docker Hub。　　</span><br><span class="line"></span><br><span class="line">Docker Registry中的镜像通常由开发人员制作，而后推送至<span class="string">&quot;公共&quot;</span>或<span class="string">&quot;私有&quot;</span>Registry上保存，供其它人员使用，例如<span class="string">&quot;部署&quot;</span>到生产环境。</span><br><span class="line"></span><br><span class="line">Docker Registry可分为以下几类:　　　　</span><br><span class="line">　　　　Sponsor Registry:</span><br><span class="line">　　　　　　第三方的<span class="keyword">registry</span>，供客户端和Docker社区使用。　　　　</span><br><span class="line">　　　　Mirror Registry:</span><br><span class="line">　　　　　　第三方的<span class="keyword">registry</span>，只让客户使用。　　　　</span><br><span class="line">　　　　Vendor Registry:</span><br><span class="line">　　　　　　由发布Docker镜像的供应商提供的<span class="keyword">registry</span>。　　　　</span><br><span class="line">　　　　Private Registry:</span><br><span class="line">　　　　　　通过设有防火墙和额外的安全层的私有实体提供的<span class="keyword">registry</span>。　　</span><br><span class="line"></span><br><span class="line">Registry包括Repository和Index，详细说明如下：　　　　</span><br><span class="line">	Repository:　　　　　　</span><br><span class="line">		由某特定的docker镜像的所有迭代版本组成的镜像仓库；</span><br><span class="line">		一个Registry中可以存在多个Repository：　　　　　　　　</span><br><span class="line">		Repository可分为<span class="string">&quot;顶层仓库&quot;</span>和<span class="string">&quot;用户仓库&quot;</span>；　　　　　　　　</span><br><span class="line">		用户仓库名称格式为<span class="string">&quot;用户名/仓库名&quot;</span>。　　　　　　</span><br><span class="line">		每个仓库可以包含多个Tag(标签)，每个标签对应一个镜像；　　　　</span><br><span class="line">	Index：　　　　　　</span><br><span class="line">		维护用户账户，镜像的校验以及公共命名空间的信息；　　　　　　</span><br><span class="line">		相当于为Registry提供了一个完成用户认证等功能的检索接口。</span><br></pre></td></tr></table></figure>



<h2 id="4-镜像名称判断"><a href="#4-镜像名称判断" class="headerlink" title="4.镜像名称判断"></a>4.镜像名称判断</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">官方仓库:</span><br><span class="line">	官方镜像:</span><br><span class="line">       	nginx:<span class="number">1.20</span>.<span class="number">1</span></span><br><span class="line">       用户上传镜像:</span><br><span class="line">       	jasonyin2020/oldboyedu_birds:v1</span><br><span class="line">       	</span><br><span class="line">第三方仓库:</span><br><span class="line">	用户上传镜像:</span><br><span class="line">		tuv7rqqq.mirror.aliyuncs.com<span class="regexp">/library/</span>nginx:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB619ede23fe543e8ad87fc3167b989033?method=download&shareKey=50ed40d4e7be6b8498105cdff2e8fc4d" alt="image-20210609221448005"></p>
<h2 id="5-docker、containerd的关系"><a href="#5-docker、containerd的关系" class="headerlink" title="5.docker、containerd的关系"></a>5.docker、containerd的关系</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">为了防止docker一家独大，docker当年的实现被拆分出了几个标准化的模块，标准化的目的是模块是可被其他实现替换的，不由任何一个厂商控制。</span><br><span class="line"></span><br><span class="line">docker由docker-client,dockerd,containerd,docker-shim,runc组成，所以containerd是docker的基础组件之一，下面是从containerd引过来的一张图。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">推荐阅读:</span><br><span class="line">	https:<span class="regexp">//</span>containerd.io/</span><br><span class="line">	https:<span class="regexp">//</span>cloud.tencent.com<span class="regexp">/document/</span>product<span class="regexp">/457/</span><span class="number">35747</span></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB9ae043893800198f4cfd20c83d42606e?method=download&shareKey=4d6e228352542fb79aaf6d93dfa1b491" alt="image-20210624151140220"></p>
<h1 id="二-部署docker环境"><a href="#二-部署docker环境" class="headerlink" title="二.部署docker环境"></a>二.部署docker环境</h1><h2 id="1-关闭并禁用防火墙"><a href="#1-关闭并禁用防火墙" class="headerlink" title="1.关闭并禁用防火墙"></a>1.关闭并禁用防火墙</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># </span></span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line">Removed symlink <span class="regexp">/etc/</span>systemd<span class="regexp">/system/mu</span>lti-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink <span class="regexp">/etc/</span>systemd<span class="regexp">/system/</span>dbus-org.fedoraproject.FirewallD1.service.</span><br><span class="line">[root@docker201.oldboyedu.com ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>



<h2 id="2-停用并禁用selinux"><a href="#2-停用并禁用selinux" class="headerlink" title="2.停用并禁用selinux"></a>2.停用并禁用selinux</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># getenforce </span></span><br><span class="line">Enforcing</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># setenforce 0</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># grep ^SELINUX= /etc/selinux/config</span></span><br><span class="line">SELINUX=enforcing</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># sed -ri s<span class="string">&#x27;#(SELINUX=)enforcing#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># grep ^SELINUX= /etc/selinux/config</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤"><a href="#3-卸载docker较旧的依赖项-如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤" class="headerlink" title="3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)"></a>3.卸载docker较旧的依赖项(如果您的操作系统是刚刚安装完成的状态，或者当前服务器没有安装过docker环境，则可以跳过该步骤)</h2><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">yum -y remove docker docker-<span class="keyword">client</span> docker-<span class="keyword">client</span>-latest docker-<span class="keyword">common</span> docker-lastest docker-lastest-logrotate docker-logrotate  docker-engine</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　(<span class="number">1</span>)现在将Docker Engine软件包称为docker-ce，较旧的Docker Engine版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项，因为新老docker版本并不相互兼容哟;</span><br><span class="line">　　(<span class="number">2</span>)如果您在之前没有安装过docker环境，则无需做当前步骤，如果您非要做该步骤，可能会出现如下图所示的情况，属于正常现象！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7a08da595901182122b042d0086d7216?method=download&shareKey=65d6999a105b014572ad817c35e72072" alt="image-20210608230633881"></p>
<h2 id="4-Docker-engine常见的安装方法概述"><a href="#4-Docker-engine常见的安装方法概述" class="headerlink" title="4.Docker engine常见的安装方法概述"></a>4.Docker engine常见的安装方法概述</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">您可以根据需要以不同的方式安装<span class="selector-tag">Docker</span> <span class="selector-tag">Engine</span>：</span><br><span class="line">　　　　(<span class="number">1</span>)大多数用户会 设置<span class="selector-tag">Docker</span>的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法。</span><br><span class="line">　　　　(<span class="number">2</span>)一些用户下载并手动安装<span class="selector-tag">RPM</span>软件包，并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装<span class="selector-tag">Docker</span>的情况下非常有用。</span><br><span class="line">　　　　(<span class="number">3</span>)在测试和开发环境中，一些用户选择使用自动便利脚本来安装<span class="selector-tag">Docker</span>。　　</span><br><span class="line">　　　　</span><br><span class="line">　　　　温馨提示:　　　　</span><br><span class="line">　　　　	本篇博客是基于存储库(需要配置软件源)的方式进行安装，即在新主机上首次安装<span class="selector-tag">Docker</span> <span class="selector-tag">Engine</span>之前，需要设置<span class="selector-tag">Docker</span>存储库。之后，您可以从存储库安装和更新<span class="selector-tag">Docker</span>。</span><br></pre></td></tr></table></figure>



<h2 id="5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟"><a href="#5-切换国内的软件源-本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟" class="headerlink" title="5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)"></a>5.切换国内的软件源(本案例切换的是阿里源，当然，您也可以考虑使用其它的公网软件源哟)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)备份CentOS官网的软件源</span><br><span class="line">mv <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Base.repo /</span>etc<span class="regexp">/yum.repos.d/</span>CentOS-Base.repo.backup</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)下载阿里云的软件源</span><br><span class="line">curl -o <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Base.repo https:/</span><span class="regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="number">7</span>.repo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)非阿里云ESC产品推荐操作该步骤</span><br><span class="line">sed -i -e <span class="string">&#x27;/mirrors.cloud.aliyuncs.com/d&#x27;</span> -e <span class="string">&#x27;/mirrors.aliyuncs.com/d&#x27;</span> <span class="regexp">/etc/yum</span>.repos.d/CentOS-Base.repo</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)生成本地缓存</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">温馨提示:</span><br><span class="line">　　上述的sed命令是可选操作，因为非阿里云ECS用户会出现<span class="string">&quot;Could not resolve host: mirrors.cloud.aliyuncs.com; Unknown error&quot;</span>信息，不影响使用。</span><br><span class="line"></span><br><span class="line">参考链接: 　　</span><br><span class="line">　　https:<span class="regexp">//</span>developer.aliyun.com<span class="regexp">/mirror/</span>centos</span><br></pre></td></tr></table></figure>



<h2 id="6-配置docker-ce的软件源-也称为”存储库”"><a href="#6-配置docker-ce的软件源-也称为”存储库”" class="headerlink" title="6.配置docker-ce的软件源(也称为”存储库”)"></a>6.配置docker-ce的软件源(也称为”存储库”)</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)添加docker-ce的软件源</span><br><span class="line">	yum -y install yum-utils</span><br><span class="line">	yum-config-manager --add-repo https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/centos/</span>docker-ce.repo</span><br><span class="line">	</span><br><span class="line">(<span class="number">2</span>)官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line">	yum-config-manager --enable docker-ce-test  <span class="comment"># 可选操作，若不启用并不影响安装docker-ce。</span></span><br><span class="line">	yum-config-manager --enable docker-ce-nightly  <span class="comment"># 可选操作</span></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)如果您启用了多个Docker存储库，则在未在yum installor yum update命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求，这个时候我们也可以来禁用最新的软件源哟~</span><br><span class="line">	yum-config-manager --disable docker-ce-test</span><br><span class="line">	yum-config-manager --disable docker-ce-nightly</span><br><span class="line">	</span><br><span class="line">参考链接:</span><br><span class="line">　　https:<span class="regexp">//</span>developer.aliyun.com<span class="regexp">/mirror/</span>docker-ce</span><br><span class="line">　　https:<span class="regexp">//</span>docs.docker.com<span class="regexp">/engine/i</span>nstall<span class="regexp">/centos/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="7-安装Docker-Engine和容器"><a href="#7-安装Docker-Engine和容器" class="headerlink" title="7.安装Docker Engine和容器"></a>7.安装Docker Engine和容器</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)若不指定安装的docker版本，则默认安装最新版本的Docker Engine和容器</span><br><span class="line">	yum -<span class="keyword">y</span> install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)要安装特定版本的Docker Engine，请在存储库中列出可用版本，然后选择并安装。返回的列表取决于启用的存储库，并且特定于您的CentOS版本（.el7此示例中的后缀表示）</span><br><span class="line">	yum <span class="keyword">list</span> docker-<span class="keyword">ce</span> --showduplicates | <span class="keyword">sort</span> -r</span><br><span class="line">	</span><br><span class="line">(<span class="number">3</span>)通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（docker-<span class="keyword">ce</span>）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。其语法格式如下所示。</span><br><span class="line">	yum install docker-<span class="keyword">ce</span>-<span class="symbol">&lt;VERSION_STRING&gt;</span> docker-<span class="keyword">ce</span>-cli-<span class="symbol">&lt;VERSION_STRING&gt;</span> containerd.io  # 安装特定docker版本的语法格式，下面有对应的案例哟~</span><br><span class="line">	yum install docker-<span class="keyword">ce</span>-<span class="number">20.10</span>.<span class="number">7</span> docker-<span class="keyword">ce</span>-cli-<span class="number">20.10</span>.<span class="number">7</span> containerd.io</span><br><span class="line">	</span><br><span class="line">温馨提示:</span><br><span class="line">	(<span class="number">1</span>)此处我安装了指定的版本，我们可以将<span class="string">&quot;/etc/yum.conf&quot;</span>的<span class="string">&quot;keepcache&quot;</span>进行缓存即可。</span><br><span class="line">	(<span class="number">2</span>)将rpm包进行打包下发到其他节点</span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="built_in">mkdir</span> docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="keyword">find</span> /var/cache/yum/ -<span class="built_in">type</span> <span class="keyword">f</span> -name <span class="string">&quot;*.rpm&quot;</span> | xargs mv -t docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# tar zcf docker_rpm_20.<span class="number">10</span>.tar.gz docker_rpm_20.<span class="number">10</span></span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="keyword">ll</span> -h</span><br><span class="line">        总用量 <span class="number">109</span>M</span><br><span class="line">        drwxr-xr-<span class="keyword">x</span>. <span class="number">2</span> root root <span class="number">4.0</span>K <span class="number">6</span>月   <span class="number">9</span> <span class="number">21</span>:<span class="number">00</span> docker_rpm_20.<span class="number">10</span></span><br><span class="line">        -rw-r--r--. <span class="number">1</span> root root <span class="number">109</span>M <span class="number">6</span>月   <span class="number">9</span> <span class="number">21</span>:<span class="number">01</span> docker_rpm_20.<span class="number">10</span>.tar.gz</span><br><span class="line">        [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="8-启动docker守护进程并设置开机自启动"><a href="#8-启动docker守护进程并设置开机自启动" class="headerlink" title="8.启动docker守护进程并设置开机自启动"></a>8.启动docker守护进程并设置开机自启动</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl start docker</span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># </span></span><br><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># systemctl enable docker</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="9-查看docker的概要信息"><a href="#9-查看docker的概要信息" class="headerlink" title="9.查看docker的概要信息"></a>9.查看docker的概要信息</h2><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@docker201</span>.oldboyedu.com ~]<span class="meta"># docker info</span></span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609004903141.png" alt="image-20210609004903141"></p>
<h2 id="10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"><a href="#10-修改docker-engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大" class="headerlink" title="10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大"></a>10.修改docker engine的默认Registry，建议使用国内的镜像仓库，国外的源网络会延迟较大</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[root@docker201.oldboyedu.<span class="keyword">com</span> ~]# tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span>&gt; &#123;&gt; <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]&gt; &#125;&gt; EOF&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]&#125;[root@docker201.oldboyedu.<span class="keyword">com</span> ~]# [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# <span class="keyword">cat</span> /etc/docker/daemon.json &#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://tuv7rqqq.mirror.aliyuncs.com&quot;</span>]&#125;[root@docker201.oldboyedu.<span class="keyword">com</span> ~]# [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# systemctl daemon-reload[root@docker201.oldboyedu.<span class="keyword">com</span> ~]# [root@docker201.oldboyedu.<span class="keyword">com</span> ~]# systemctl restart docker[root@docker201.oldboyedu.<span class="keyword">com</span> ~]# 参考链接:　　http<span class="variable">s:</span>//<span class="keyword">cr</span>.console.aliyun.<span class="keyword">com</span>/<span class="keyword">cn</span>-hangzhou/instances/mirrors</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609005632041.png" alt="image-20210609005632041"></p>
<h1 id="三-dockers命令自动补全-新手必备"><a href="#三-dockers命令自动补全-新手必备" class="headerlink" title="三.dockers命令自动补全(新手必备)"></a>三.dockers命令自动补全(新手必备)</h1><h2 id="1-为啥能自动补全"><a href="#1-为啥能自动补全" class="headerlink" title="1.为啥能自动补全"></a>1.为啥能自动补全</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Linux系统许多命令都会提供该命令自身的命令补齐脚本，在安装命令时会自动安装自动补齐脚本，如果有的话，该机制在Linux中被称为bash-complete。	如下图所示，在<span class="regexp">/usr/</span>share<span class="regexp">/bash-completion/</span>completions/ 目录下有许多命令自动补齐的脚本，我们已经安装了docker环境。	</span><br></pre></td></tr></table></figure>

<p><img src="%25E7%25AC%2594%25E8%25AE%25B0/04-%25E8%2580%2581%25E7%2594%25B7%25E5%25AD%25A9%25E6%2595%2599%25E8%2582%25B2-Docker%25E7%259A%2584%25E6%259E%25B6%25E6%259E%2584%25E4%25BB%258B%25E7%25BB%258D%25E5%258F%258A%25E9%2583%25A8%25E7%25BD%25B2%25E5%25AE%259E%25E6%2588%2598.assets/image-20210609230730489.png" alt="image-20210609230730489"></p>
<h2 id="2-安装相关依赖包"><a href="#2-安装相关依赖包" class="headerlink" title="2.安装相关依赖包"></a>2.安装相关依赖包</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">yum -y install bash-completionsource <span class="regexp">/usr/</span>share<span class="regexp">/bash-completion/</span>bash_completion</span><br></pre></td></tr></table></figure>



<h2 id="3-验证补全功能"><a href="#3-验证补全功能" class="headerlink" title="3.验证补全功能"></a>3.验证补全功能</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">如下图所示，当我们输入子命令不知道该如何是好的时候，就可以连续按两下<span class="string">&quot;tab&quot;</span>键即可。</span><br></pre></td></tr></table></figure>

<p><img src="04-%E8%80%81%E7%94%B7%E5%AD%A9%E6%95%99%E8%82%B2-Docker%E7%9A%84%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E9%83%A8%E7%BD%B2%E5%AE%9E%E6%88%98.assets/image-20210609231114594.png" alt="image-20210609231114594"></p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
</search>
