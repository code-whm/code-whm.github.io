<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash概述</title>
    <url>/2021/07/28/Bash%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.Bash Shell初步认识 2.Bash Shell基本特性 3.Bash Shell获取帮助 4.Bash Shell命令流程</p>
<span id="more"></span>
<h1 id="1-Bash-Shell初步认识"><a href="#1-Bash-Shell初步认识" class="headerlink" title="1.Bash Shell初步认识"></a>1.Bash Shell初步认识</h1><h2 id="1-什么是Bash-shell-壳"><a href="#1-什么是Bash-shell-壳" class="headerlink" title="1.什么是Bash shell(壳)"></a>1.什么是Bash shell(壳)</h2><p><em>Bash Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。</em></p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210727093855.png" alt="imageTitle"></p>
<p><em>当我们使用远程连接工具连接linux服务，系统则会给打开一个默认的shell，我们可在这个界面执行命令、比如：获取系统当前时间，创建一个用户等等….</em></p>
<h2 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么"></a>2.Bash Shell能干什么</h2><p><em>使用Shell实现对Linux系统的大部分管理，例如:<br> 1.文件管理<br> 2.权限管理<br> 3.用户管理<br> 4.磁盘管理<br> 5.网络管理<br> 6.软件管理<br> .等等.</em></p>
<h2 id="3-平时我们如何使用Shell？"><a href="#3-平时我们如何使用Shell？" class="headerlink" title="3.平时我们如何使用Shell？"></a>3.平时我们如何使用Shell？</h2><p><em>输入命令 –&gt; 效率低 –&gt; 适合少量的工作</em></p>
<p><em>Shell Script(脚本) –&gt; 效率高 –&gt; 适合复杂的重复性高的工作</em></p>
<p><em>例如:创建100个用户，单纯输入命令需要执行100次，而Shell脚本只需要几行命令即可完成100个用户的创建</em></p>
<h2 id="4-Shell提示符"><a href="#4-Shell提示符" class="headerlink" title="4.Shell提示符"></a>4.Shell提示符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ = 普通用户, # = root用户(超级管理员)</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">[root@web01 ~]<span class="comment"># useradd jack</span></span><br><span class="line">[root@web01 ~]<span class="comment"># passwd jack</span></span><br><span class="line">Changing password <span class="keyword">for</span> user jack.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is a palindrome</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-Shell基础语法"><a href="#5-Shell基础语法" class="headerlink" title="5.Shell基础语法"></a>5.Shell基础语法</h2><p><em>命令行bash shell，为用户提供输入，执行命令的界面</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令  选项  参数</span></span><br><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令: 整条shell命令的主体</span></span><br><span class="line"><span class="comment">#选项: 用于调节命令的具体功能</span></span><br><span class="line">    <span class="comment">#以 “-”引导短格式选项（单个字符），例如“-l”</span></span><br><span class="line">    <span class="comment">#以“--”引导长格式选项（多个字符），例如“--color”</span></span><br><span class="line">    <span class="comment">#多个短格式选项可以写在一起，只用一个“-”引导，例如“-al”</span></span><br><span class="line"><span class="comment">#参数: 命令操作的对象，如文件、目录名等</span></span><br><span class="line"><span class="comment"># 命令必须开头， 选项和参数位置可以发生变化</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Bash-Shell基本特性"><a href="#2-Bash-Shell基本特性" class="headerlink" title="2.Bash Shell基本特性"></a>2.Bash Shell基本特性</h1><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a><em>1.命令补全</em></h3><p><em>当时用windows查找一个目录层级特别多的文件时，打开的效率会非常慢，但如果使用linux查找一个目录层级特别多的文件时，可以通过tab键快速的补全</em></p>
<p><em>PS:tab键可以实现命令补全，路径补全，在实际生产中tab补全往往是我们使用的最多的, 因为可以减少执行命令以及路径出错率.</em></p>
<h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a><em>2.命令快捷键</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+a <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">ctrl+e <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">ctrl+c <span class="comment">#终止前台运行的程序</span></span><br><span class="line">ctrl+d <span class="comment">#在shell中，ctrl+d表示退出当前shell</span></span><br><span class="line">ctrl+z <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">ctrl+l <span class="comment">#清屏，和clear命令等效</span></span><br><span class="line">ctrl+k <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">ctrl+u <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">ctrl+r <span class="comment">#搜索历史命令，利用关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在命令行前加面加 &quot;#&quot; 则该命令不会被执行，一般用作注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-历史命令history"><a href="#3-历史命令history" class="headerlink" title="3.历史命令history"></a><em>3.历史命令history</em></h3><p><em>-w 保存命令历史到历史文件<br> -c 清空命令历史记录, 不会情况文件<br> -d 删除命令历史的第 N 条行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用双 !! 可执行上一条执行过的命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls</span></span><br><span class="line">lucifer.com</span><br><span class="line">[root@lucifer ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.输入!6, 执行history命令历史中第 6 行命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !6</span></span><br><span class="line">touch lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用!cat, 调用history命令历史最近一次执行过的cat命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line"><span class="comment">#调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 &quot;.&quot;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"><span class="comment">#第二种方式, 输入!$</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="4-历史别名"><a href="#4-历史别名" class="headerlink" title="4.历史别名"></a><em>4.历史别名</em></h3><p><em>命令别名将用户经常使用的复杂命令简单化, 可以用<code>&quot;alias 别名名称=命令&quot;</code>命令创建属于自己的命令别名, 若要取消一个命令别名，则是用<code>unalias 别名名称</code>命令。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.定义临时别名, wk为查看eth0网卡别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias wk=&#x27;ifconfig&#x27;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># wk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.如果定义命令本身, 会执行什么?</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias ifconfig=&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">    <span class="comment">#绝对路径执行, 调用命令本身</span></span><br><span class="line">    [root@lucifer ~]<span class="comment"># /sbin/ifconfig</span></span><br><span class="line">    <span class="comment">#通过\转义字符, 调用命令本身</span></span><br><span class="line">    [root@WebServer ~]<span class="comment"># \ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.取消别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># unalias ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.永久生效，/etc/bashrc</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;alias ifconfig=&#x27;ifconfig eth0&#x27;&quot; &gt;&gt; /etc/bashrc</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Bash-Shell获取帮助"><a href="#3-Bash-Shell获取帮助" class="headerlink" title="3.Bash Shell获取帮助"></a>3.Bash Shell获取帮助</h1><h3 id="1-命令-–help帮助"><a href="#1-命令-–help帮助" class="headerlink" title="1.命令 –help帮助"></a><em>1.命令 –help帮助</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@lucifer ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@lucifer ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@web01 ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@web01 ~]<span class="comment"># ls</span></span><br><span class="line">2019-03-28_file.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-命令man手册"><a href="#2-命令man手册" class="headerlink" title="2.命令man手册"></a><em>2.命令man手册</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#man ls #查看ls命令手册</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Linux命令大全传送门"><a href="#3-Linux命令大全传送门" class="headerlink" title="3.Linux命令大全传送门"></a><em>3.Linux命令大全传送门</em></h3><p><em>linux命令大全： <a href="https://man.linuxde.net/">https://man.linuxde.net/</a></em></p>
<p><em>linux命令手册：<a href="http://linux.51yip.com/">http://linux.51yip.com/</a></em></p>
<h1 id="4-Bash-Shell命令流程"><a href="#4-Bash-Shell命令流程" class="headerlink" title="4.Bash Shell命令流程"></a>4.Bash Shell命令流程</h1><h3 id="1-当我们执行一个命令-整个命令执行流程如下"><a href="#1-当我们执行一个命令-整个命令执行流程如下" class="headerlink" title="*1.当我们执行一个命令, 整个命令执行流程如下:"></a>*1.当我们执行一个命令, 整个命令执行流程如下:</h3><ol>
<li>判断命令是否通过绝对路径执行</li>
<li>判断命令是否存在alias别名</li>
<li>判断用户输入的是内部命令还是外部命令</li>
<li>Bash内部命令直接执行，外部命令检测是否存在缓存</li>
<li>通过PATH路径查找命令，有执行，无报错*</li>
</ol>
<h3 id="2-什么是内部命令，什么是外部命令"><a href="#2-什么是内部命令，什么是外部命令" class="headerlink" title="2.什么是内部命令，什么是外部命令"></a><em>2.什么是内部命令，什么是外部命令</em></h3><p> <em>内部命令: shell程序自带的命令。<br> 外部命令: 在系统PATH变量的某个路径下的可执行程序。</em></p>
<h3 id="3-如何检查用户输入的命令是内部命令还是外部命令"><a href="#3-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="3.如何检查用户输入的命令是内部命令还是外部命令"></a><em>3.如何检查用户输入的命令是内部命令还是外部命令</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line">[root@linux-node1 ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br></pre></td></tr></table></figure>

<p><em>4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p><em>PS: PATH由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找</em></p>
<p><em>5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意: 命令缓存hash需要注意如下情况:</span></span><br><span class="line">1.只要执行外部命令1次就会对该命令进行缓存</span><br><span class="line">2.如果将命令移动了位置，该如何执行</span><br><span class="line">    a.使用绝对路径执行</span><br><span class="line">    b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<h3 id="命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下"><a href="#命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下" class="headerlink" title="命令执行流程总结: 当我们执行了一个ping命令之后, 整个命令执行的流程步骤如下:"></a><em>命令执行流程总结: 当我们执行了一个<code>ping</code>命令之后, 整个命令执行的流程步骤如下:</em></h3><p><em>1) 检查执行的命令是否使用的是绝对路径执行的。<br> 2) 检查ping命令是否存在alias别名<br> 3) 检查ping命令是内部命令还是外部命令<br> 4) 如果是内部命令Bash直接执行，如果是外部命令，首先检查Hash缓存，存在则直接调取<br> 5) 如果该命令不存在Hash缓存，则通过PATH路径进行逐行查找该命令所在的位置<br> 6) 如果PATH路径没有查找到该命令所在的路径，则返回错误码。command not found</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>Bash -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/2021/07/28/Linuxuser/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.用户基本概述 2.用户相关命令 3.用户扩展知识 3.用户组的管理 4.用户如何提权</p>
<span id="more"></span>
<h1 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h1><p><em><strong>1.什么是用户?</strong></em></p>
<p><em>用户指的是能够正常登录Linux或Windows系统(可以理解为你租了房子，能够正常入驻)<br>F:那Linux与Windows系统的用户有什么区别? Q:本质都是登陆系统，只不过Linux支持多个用户同时登陆。<br>F:难道Windows就不算多用户操作系统吗? Q:其实不是，在Windows系统中可以创建多个用户，但不允许同一时刻多个用户登陆系统，但Linux系统则允许同一时刻多个用户同时登陆，登陆后相互之间操作并不影响。</em></p>
<p><em><strong>2.Linux下的用户有什么用，或者说我们为什么要创建用户？</strong></em></p>
<p><em>1.系统上的每一个进程(运行的程序)，都需要一个特定的用户运行<br>2.通常在公司是使用普通用户管理服务器，因为root权限过大，容易造成故障。</em></p>
<p><em><strong>3.如何查看系统中所存在的用户</strong></em></p>
<p><em>1.查看当前登录的用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@bgx ~]<span class="comment"># id oldboy #查看其它用户的信息</span></span><br><span class="line">uid=1000(oldboy) gid=1000(oldboy) groups=1000(oldboy)</span><br></pre></td></tr></table></figure>

<p><em>2.每一个进程都会由一个用户身份运行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ps aux|less #简单使用一下，不用理解</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure>

<p><em><strong>4.那我们的用户存在哪呢?</strong></em></p>
<p><em>Linux系统会将用户的信息存放在/etc/passwd，记录了用户的信息，但没有密码信息，密码被存放在/etc/shadow中。也就是说这两个文件非常的重要，不要轻易删除与修改。</em></p>
<p><em>1./etc/passwd 配置文件解释如下图，或者man 5 passwd</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/shadow 配置文件解释如下图，或者man 5 shadow</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728213756.png" alt="imageTitle"></p>
<p><em><strong>4.最后我们需要了解下系统对用户的一个约定？(约定娶你，就真的会娶吗？)</strong></em></p>
<table>
<thead>
<tr>
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>超级管理员，最高权限，有着极强的破坏能力</td>
</tr>
<tr>
<td>1~200</td>
<td>系统用户，用来运行系统自带的进程，默认已创建</td>
</tr>
<tr>
<td>201~999</td>
<td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td>
</tr>
<tr>
<td>1000+</td>
<td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td>
</tr>
</tbody></table>
<p><em>PS:在CentOS7系统之前, UID1-499用于系统用户, 而UID 500+则用于普通用户</em></p>
<h1 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h1><p><em>下面我们就围绕着用户的创建、变更、删除等来讲讲涉及到的命令: useradd、usermod、userdel</em></p>
<p><em>1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要创建用户的UID,不允许冲突</span></span><br><span class="line"><span class="comment"># -g 指定要创建用户默认组</span></span><br><span class="line"><span class="comment"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span></span><br><span class="line"><span class="comment"># -d 指定要创建用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要创建用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要创建用户注释信息</span></span><br><span class="line"><span class="comment"># -M 给创建的用户不创建家目录</span></span><br><span class="line"><span class="comment"># -r 创建系统账户，默认无家目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建bgx用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure>

<p><em>2.如何使用usermod命令修改用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要修改用户的UID</span></span><br><span class="line"><span class="comment"># -g 指定要修改用户基本组</span></span><br><span class="line"><span class="comment"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></span><br><span class="line"><span class="comment"># -d 指定要修改用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要修改用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要修改用户注释信息</span></span><br><span class="line"><span class="comment"># -l 指定要修改用户的登陆名</span></span><br><span class="line"><span class="comment"># -L 指定要锁定的用户</span></span><br><span class="line"><span class="comment"># -U 指定要解锁的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.检查此前创建的用户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx:x:5001:503:2019 new student:/home/bgx:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.修改bgx用户uid、gid，附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改bgx用户的注释信息, 用户家目录, 登录shell, 登录名</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /bgx -s /bin/sh -l change_bgx bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否修改成功</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx_xuliangwei:x:6001:5008:2019 new student:/bgx:/bin/sh</span><br><span class="line">[root@bgx ~]<span class="comment"># id change_bgx</span></span><br><span class="line">uid=6001(change_bgx) gid=5008(network_sa) groups=5008(network_sa),503(sa),5009(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /bgx</span></span><br><span class="line">drwx------. 2 bgx_xuliangwei network_sa 4096 2014-09-23 00:13 /bgx</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.锁定用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin change_bgx</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -L change_bgx  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解锁用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -U change_bgx</span></span><br></pre></td></tr></table></figure>

<p>*S: 当然还有很多命令可以查看用户的信息，以下简单列举一些，但都是我们常用，所以了解即可</p>
<ol>
<li>使用finger命名查询用户信息以及登录信息，示例: finger UserName</li>
<li>使用chfn命令修改用户信息，示例: chfn UserName</li>
<li>使用chsh命令修改用户登录Bash Shell，示例: chsh UserName</li>
<li>使用who、whoami、w检查用户登陆情况*</li>
</ol>
<p><em>3.使用userdel命令删除账户</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项 -r 删除用户同时删除它的家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.删除user1用户，但不删除用户家目录和 mail spool</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.-r参数可以连同用户家目录一起删除(慎用)</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure>

<h1 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h1><p><em><strong>1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？</strong></em></p>
<p><em>1.useradd创建用户时，系统会以/etc/login.defs、/etc/defaults/useradd两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖/etc/login.defs、/etc/defaults/useradd文件默认配置，如未指定则使用默认。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@bgx ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      <span class="comment">#把用户的家目录建在/home中。</span></span><br><span class="line">INACTIVE=-1     <span class="comment">#是否启用账号过期停权,-1表示不启用。</span></span><br><span class="line">EXPIRE=         <span class="comment">#账号终止日期,不设置表示不启用。</span></span><br><span class="line">SHELL=/bin/bash <span class="comment">#新用户默认所有的shell类型。</span></span><br><span class="line">SKEL=/etc/skel  <span class="comment">#配置新用户家目录的默认文件存放路径。</span></span><br><span class="line">CREATE_MAIL_SPOOL=yes   <span class="comment">#创建mail文件。</span></span><br></pre></td></tr></table></figure>

<p><em>2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<p><em>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用passwd命令。建议密码复杂度高一些、长度大于10、出现各种特殊字符、无任何规律(不要出现名字，电话，生日等)<br> PS: 注意事项<br> 1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须8位字符<br> 2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用passwd命令修改用户密码</span></span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd oldboy #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.验证如下几项指标</span></span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd Lucifer        #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin xuliangwei    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.系统内置变量生成随机字符串</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@bgx ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span></span><br><span class="line">[root@bgx ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure>

<p><em>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件<a href="https://www.lastpass.com/zh">Lastpass官方网站</a></em></p>
<h1 id="3-用户组的管理"><a href="#3-用户组的管理" class="headerlink" title="3.用户组的管理"></a>3.用户组的管理</h1><p><em><strong>1.什么是用户组？</strong></em></p>
<p><em>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</em></p>
<p><em><strong>2.对于用户来说，组有几种类别？</strong></em></p>
<p><em>基本组，用户只能有一个基本组，创建时可通过-g指定，如未指定则创建一个默认的组(与用户同名)</em></p>
<p><em>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组</em></p>
<p><em><strong>3.那组的信息保存在哪呢？</strong></em></p>
<p><em>组账户信息保存在/etc/group和/etc/gshadow两个文件中。重点关注group</em></p>
<p><em>1./etc/group 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/gshadow 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728211204.png" alt="imageTitle"><br><em>1.使用groupadd命令新增组，groupadd [-g GID] groupname</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建基本组, 不指定gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建基本组, 指定gid为5555</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建系统组，gid从201-999</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure>

<p><em>2.使用groupmod命令新增组</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-g 修改组gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line"><span class="comment">#-n 修改组名称</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure>

<p><em>3.groupdel删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除用户附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无法删除用户基本组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line"><span class="comment">#只有删除用户或者用户变更基本后,方可删除该组</span></span><br></pre></td></tr></table></figure>

<p><em>4.使用gpasswd设置组密码[扩展，可以不会]</em></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># groupadd devops</span></span><br><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> <span class="keyword">group</span> devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter <span class="keyword">new</span> password:</span><br></pre></td></tr></table></figure>

<p><em>5.使用newgrp命令切换基本组身份[扩展，可以不会]</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.检查账户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd xuliangwei</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建新文件,查看文件的属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_roots</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用newgrp切换到devops组</span></span><br><span class="line">[xuliangwei@bgx ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.创建文件，检查属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_test</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 xuliangwei devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure>

<h1 id="4-用户如何提权"><a href="#4-用户如何提权" class="headerlink" title="4.用户如何提权"></a>4.用户如何提权</h1><p><em>往往公司的服务器对外都是禁止root用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？<br> 当我们使用普通用户执行/sbin目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用root用户直接登录系统，同时又保证普通用户能完成日常工作？<br> PS: 我们可以使用如下两种方式: su、sudo<br> 1.su切换用户，使用普通用户登录，然后使用su命令切换到root。优点:简单 缺点:需要知道root密码<br> 2.sudo提权，当需要使用root权限时进行提权，而无需切换至root用户，优点:安全、方便 缺点:复杂</em></p>
<p><em><strong>1.su身份切换</strong></em></p>
<p><em>在使用su切换前，我们需要了解一些预备知识，比如shell分类、环境变量配置文件有哪些</em></p>
<p><em>1.Linux Shell主要分为如下几类<br>交互式shell，等待用户输入执行的命令(终端操作,需要不断提示)<br>非交互式shell，执行shell脚本, 脚本执行结束后shell自动退出<br>登陆shell，需要输入用户名和密码才能进入Shell，日常接触的最多的一种<br>非登陆shell，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</em></p>
<p><em>2.bash shell配置文件介绍(文件主要保存用户的工作环境)<br>个人配置文件：~/.bash_profile ~/.bashrc 。全局配置文件：/etc/profile /etc/profile.d/*.sh /etc/bashrc<br>profile类文件, 设定环境变量, 登陆前运行的脚本和命令。bashrc 类文件, 设定本地变量, 定义命令别名<br>PS: 如果全局配置和个人配置产生冲突，以个人配置为准。</em></p>
<p><em>3.登陆系统后，环境变量配置文件的应用顺序是?</em><br> <em>登录式shell配置文件执行顺序: /etc/profile-&gt;/etc/profile.d/*.sh-&gt;<del>/.bash_profile-&gt;</del>/.bashrc-&gt;/etc/bashrc<br> 非登陆式shell配置文件执行顺序: ~/.bashrc-&gt;/etc/bashrc-&gt;/etc/profile.d/*.sh<br> PS: 验证使用echo在每行添加一个输出即可</em></p>
<p><em>4.说了这么多预备知识，那这些和su命令切换用户有什么关系?<br> su - username属于登陆式shell，su username属于非登陆式shell，区别在于加载的环境变量不一样。<br>普通用户<code>su -</code>可以直接切换至root用户，但需要输入root用户的密码。<br>超级管理员root用户使用<code>su - username</code>切换普通用户不需要输入任何密码。</em> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[xuliangwei@node1 ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@node1 xuliangwei]<span class="comment"># pwd</span></span><br><span class="line">/home/xuliangwei</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[xuliangwei@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.sudo提权</strong></em></p>
<p><em>su命令在切换用户身份时，如果每个普通用户都能拿到root用户的密码，当其中某个用户不小心泄漏了root的密码，那系统会变得非常不安全。为了改进这个问题，从而产生了sudo这个命令。</em></p>
<p><em>其实sudo就相当于给某个普通用户埋下了浩克(hulk)的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</em></p>
<p><em>1.如何快速埋下hulk的种子呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式[先睹为快]</span></span><br><span class="line">[root@node1 ~]<span class="comment"># usermod bgx -G wheel</span></span><br><span class="line">[root@node1 ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@www ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名）       4.命令名</span></span><br><span class="line">bgx       ALL=(ALL)         /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">oldboy   ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure>

<p><em>2.埋下了hulk种子后又如何提权使用呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo -l</span><br><span class="line">User xuliangwei may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure>

<p><em>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</em></p>
<p><em>第一种方式:使用sudo中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># visudo  #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个系统group没什么关系</span></span><br><span class="line">User_Alias OPS = oldboy,alex</span><br><span class="line">User_Alias DEV = bgx,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure>

<p><em>第二种方式:使用groupadd添加组,然后给组分配sudo的权限,如果有新用户加入,直接将用户添加到该组.</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure>

<p><em>4.sudo命令的执行流程:</em><br> <em>1) 普通用户执行sudo命令时, 会检查/var/db/sudo是否存在时间戳缓存<br> 2) 如果存在则不需要输入密码, 否则需要输入用户与密码<br> 3) 输入密码会检测是否该用户是否拥有该权限<br> 4) 如果有则执行，否则报错退出</em></p>
<p><em>下图为sudo执行流程</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728212235.png" alt="imageTitle"></p>
<p><a href="https://www.jianshu.com/p/d172a92475f1">sudo不支持系统内置命令</a></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>用户 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件管理</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.文件管理概述 2.系统目录结构 3.文件路径定位 4.系统文件管理 5.系统文件属性 6.系统文件类型  7.系统链接文件</p>
<span id="more"></span>
<h1 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h1><p><em><strong>1.Bash Shell对文件进行管理</strong></em></p>
<p><em>谈到Linux文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？<br> 其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等<br> 例如: 当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</em></p>
<h1 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h1><p><em>几乎所有的计算机操作系统都是使用目录结构组织文件。具体来说就是在一个目录中存放子目录和文件, 而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支, 所以该结构又被称为“目录树”。<br> Windows: 以多根的方式组织文件 C:\ D:<br> Linux:以单根的方式组织文件   /</em></p>
<p><em><strong>1.存放命令相关的目录</strong></em></p>
<p><em>/bin， 普通用户使用的命令 /bin/ls, /bin/date</em><br><em>/sbin，管理员使用的命令 /sbin/service</em></p>
<p><em><strong>2.存放用户相关数据的家目录</strong></em></p>
<p><em>/home，普通用户的家目录, 默认为/home/username<br>/root，超级管理员root的家目录, 普通用户无权操作</em></p>
<p><em><strong>3.系统文件目录</strong></em></p>
<p><em>/usr，相当于C:\Windows<br>/usr/local，软件安装的目录，相当于C:\Program<br>/usr/bin/，普通用户使用的应用程序(重要)<br>/usr/sbin，管理员使用的应用程序(重要)<br>/usr/lib，库文件Glibc 32bit<br>/usr/lib64，库文件Glibc 64bit</em></p>
<p><em><strong>4.启动目录</strong></em></p>
<p>/boot 存放的系统启动相关的文件，例如:kernel，grub(引导装载程序)*</p>
<p><em><strong>5.配置文件目录</strong></em></p>
<p><em>/etc，极其重要，后续所有服务的配置都在这个目录中<br>/etc/sysconfig/network-script/ifcfg-，网络配置文件<br>/etc/hostname，系统主机名配置文件<br>/etc/resolv.conf，dns客户端配置文件<br>/etc/hosts，本地域名解析配置文件</em></p>
<p><em><strong>6.可变的目录与临时目录</strong></em></p>
<p><em>/var，存放一些变化文件，比如/var/log/下的日志文件<br>/var/tmp，进程产生的临时文件<br>/tmp，系统临时目录(类似于公共厕所)</em></p>
<p><em><strong>7.设备目录文件</strong></em></p>
<p><em>/dev，存放设备文件，比如硬盘，硬盘分区，光驱，等等<br>/dev/null，黑洞设备，只进不出。类似于垃圾回收站<br>/dev/random，生成随机数的设备<br>/dev/zero，能远远不断的产生数据，类似于取款机，随时随地取钱</em></p>
<p><em><strong>8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)</strong></em></p>
<p><em>/proc，反映系统当前进程的实时状态<br>PS：类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了。</em></p>
<p><em><strong>9.PS: 在Linux7系统中, /bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下</strong></em></p>
<p><em>/bin  –&gt; /usr/bin<br>/sbin –&gt; /usr/sbin<br>lib -&gt; usr/lib<br>lib64 -&gt; usr/lib64</em></p>
<h1 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h1><p><em>在我们开始操作文件前，首先需要对文件进行定位，比如:<br>你要在哪创建什么文件? 你要将文件复制到什么地方? 或者你要删除的文件在什么地方?<br>那什么是定位: 比如/etc/hostname，整个文件中包含文件名称以及文件所在的位置，我们将这个叫做路径，那么路径就是对文件进行定位的一种方式.</em></p>
<p><em><strong>1.每个目录下都有一个.和..的目录是干啥的?</strong></em><br> <em>一个点代表当的是当前目录, 两个点代表的是当前目录的上层目录。<br>假设当前目录在<code>/usr/</code>下, 那么它的上层(/)目录用<code>../</code>表示, 而<code>/usr/</code>的下层(local)目录则用<code>./local</code>表示。</em></p>
<p><em><strong>2.那什么是绝对路径，什么又是相对路径呢?</strong></em><br> <em>绝对路径: 只要从/开始的路径，比如/home/alice/file<br>相对路径: 相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3 [加入: 此时在目录/home/alice]<br>小结: 所谓的(.)和(..)目录实际上属于相对路径的一种表示形式。</em></p>
<p><em><strong>3.绝对路径与相对路径示例</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch file4</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure>

<p><em>cd改变目录，常见的使用方法</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>改变目录，常见的使用方法<span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure>

<h1 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h1><h2 id="1-文件管理之-创建-复制-移动-删除"><a href="#1-文件管理之-创建-复制-移动-删除" class="headerlink" title="1.文件管理之: 创建/复制/移动/删除"></a><em><strong>1.文件管理之: 创建/复制/移动/删除</strong></em></h2><p><em><strong>—————————————-创建—————————————-</strong></em></p>
<p><em>1.文件创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch file                    #无则创建,有则修改时间</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>2.目录创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>3.以树状显示目录结构命令tree</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cp复制—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-mv移动—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rm删除—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)"></a><em><strong>2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)</strong></em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure>

<h2 id="3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)"></a><em><strong>3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)</strong></em></h2><p><em><strong>—————————————-wget、curl联网下载文件—————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rzsz上传下载文件—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rz            #只能上传文件文件上传</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件管理之：文件或命令查找-locate、which、whereis、find"><a href="#4-文件管理之：文件或命令查找-locate、which、whereis、find" class="headerlink" title="4.文件管理之：文件或命令查找(locate、which、whereis、find)"></a><em><strong>4.文件管理之：文件或命令查找(locate、which、whereis、find)</strong></em></h2><p><em><strong>—————————————-文件查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-命令查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       //查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    //仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls        #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、"><a href="#5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、" class="headerlink" title="5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)"></a><em><strong>5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)</strong></em></h2><p><em><strong>—————————————-sort排序—————————————-</strong></em></p>
<p><em>在有些情况下，需要对应一个无序的文本文件进行数据的排序，这时就需要使用sort进行排序了。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例，下载文件http://fj.lucifer.com/public/ip.txt，对该文件进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-uniq去重—————————————</strong></em></p>
<p><em>如果文件中有多行完全相同的内容，当前是希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数, 那么就可以使用<code>uniq</code>命令解决这个问题(但是必须配合<code>sort</code>使用)。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cut截取字段—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-wc统计行号—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure>

<h1 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h1><p><em>当我们使用ls -l列目录下所有文件时，通常会以长格式的方式显示，其实长格式显示就是我们Windows下看到的文件详细信息，我们也将其称为文件属性，那整个文件的属性分为十列。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls -l ks.cfg</span></span><br><span class="line">-rw-------. 1 root root 4434 May 30 13:58 ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">4434        ⑤:文件大小</span><br><span class="line">May30 13:58 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure>

<h1 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h1><p><em>1.通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过ls -l以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure>

<p><em>2.但有些情况下，我们无法通过ls -l文件的类型，比如: 一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@lucifer ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure>

<p><em>PS: Linux文件扩展名不代表任何含义，仅为了我们能更好的识别该文件是什么类型。</em></p>
<h1 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h1><p><em>文件有文件名与数据，在Linux上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。<br>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方，我们将其称为Block<br>元数据，即文件的附加属性，如文件大小、创建时间、所有者等信息。我们称其为Inode<br>在Linux中，inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）<br>文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</em></p>
<h2 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)"></a><em><strong>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)</strong></em></h2><h3 id="1-什么是软链接"><a href="#1-什么是软链接" class="headerlink" title="1.什么是软链接"></a><em><strong>1.什么是软链接</strong></em></h3><p><em>软链接相当于Windows的快捷方式，软链接文件会将inode指向源文件的block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个inode指向同一个block。当我们删除软链接文件时，其实只是删除了一个inode指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。</em></p>
<h3 id="2-什么是硬链接"><a href="#2-什么是硬链接" class="headerlink" title="2.什么是硬链接"></a><em><strong>2.什么是硬链接</strong></em></h3><p><em>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，如下图hard link 就是 file 的一个别名，他们有共同的 inode。</em></p>
<p><em>软链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak</span><br><span class="line">ll /tmp/file_bak  //root下file链接到/tmp下并重命名为file_bak</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx</span><br><span class="line">ll /soft/nginx   //查看链接指向</span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure>

<p><em>硬链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">4.硬链接实践<span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard</span><br><span class="line">ll /tmp/file_hard</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS：目录不能创建硬链接，硬链接文件可以用rm命令删除</span></span><br></pre></td></tr></table></figure>

<h3 id="3-硬链接与软链接区别"><a href="#3-硬链接与软链接区别" class="headerlink" title="3.硬链接与软链接区别"></a><em>3.硬链接与软链接区别</em></h3><p> <em>1)ln命令创建硬链接，ln -s命令创建软链接。<br> 2)目录不能创建硬链接，并且硬链接不可以跨越分区系统。<br> 3)目录软链接特别常用,并且软链接支持跨越分区系统。<br> 4)硬链接文件与源文件的inode相同，软链接文件与源文件inode不同。<br> 5)删除软链接文件，对源文件及硬链接文件无任何影响。<br> 6)删除文件的硬链接文件，对源文件及链接文件无任何影响。<br> 7)删除链接文件的源文件，对硬链接无影响，会导致软链接失效。<br> 8)删除源文件及其硬链接文件，整个文件会被真正的删除。</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件编辑(vim)</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%EF%BC%88vim%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.VIM基本概述 2.VIM模式使用 3.VIM扩展知识 4.VIM练习示例</p>
<span id="more"></span>
<h1 id="1-vim基本概述"><a href="#1-vim基本概述" class="headerlink" title="1.vim基本概述"></a>1.vim基本概述</h1><p><em><strong>1.什么是vim</strong></em></p>
<p><em>vi和vim是Linux下的一个文本编辑工具。(可以理解为windows的记事本，或word文档)</em></p>
<p><em><strong>2.为什么要使用VIM?</strong></em></p>
<p><em>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</em></p>
<p><em><strong>3.VI与VIM有什么区别?</strong></em></p>
<p><em>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于window</em>s<em>系统下的文本编辑软件“记事本”与”notepad++”的区别)</em><br>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y安装*</p>
<p><em><strong>4.如何使用VIM编辑器?</strong></em></p>
<p><em>在使用VIM之前，我们需要先介绍下VIM的三种模式: 普通模式、编辑模式、命令模式，每种模式分别支持多种不同的快捷键，要想高效率地操作文本，那就必须先搞清这三种模式的操作区别以及模式之间的切换方法。</em></p>
<p><em><strong>5.VIM模式三种模式介绍</strong></em></p>
<p><em>1.普通模式: 主要是控制光标移动，可对文本进行复制、粘贴、删除等工作。<br> 使用vim filename 编辑一个文件时，一进入该文件就是普通模式了。<br> 在这个模式下，可以进行光标移动、复制、删除、粘贴操作。</em></p>
<p><em>2.编辑模式: 主要进行文本内容编辑和修改<br> 从普通模式进入编辑模式，只需你按一个键即可（i, I, a, A, o, O）<br> 当进入编辑模式时，会在屏幕的最下一行会出现 “INSERT”标记<br> 从编辑模式回到普通模式只需要按键盘左上方的 ESC 键即可。</em></p>
<p><em>3.末行模式: 主要用于保存或退出文本。<br> 在普通模式下，输入 “:” 或者 “/“ 即可进入命令模式。<br> 在命令该模式下，可进行的操作有，显示行号、搜索、替换、保存、退出。</em></p>
<p><em>小结: vim编辑打开文件整体流程如下:<br> 1.默认打开文件处于普通模式<br> 2.从普通模式切换至编辑模式需要使用a、i、o<br> 3.编辑模式修改完毕后需要先使用ECS返回普通模式<br> 4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br> PS: 在vim中，无法直接从编辑模式切换到命令模式。</em></p>
<h1 id="2-VIM模式使用"><a href="#2-VIM模式使用" class="headerlink" title="2.VIM模式使用"></a>2.VIM模式使用</h1><h2 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1.普通模式"></a><em>1.普通模式</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G       <span class="comment">#光标跳转至末端</span></span><br><span class="line">gg      <span class="comment">#光标跳转至顶端</span></span><br><span class="line">Ngg     <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$       <span class="comment">#光标跳转至当前光标所在行的尾部</span></span><br><span class="line">^|0     <span class="comment">#光标跳转至当前光标所在行的首部</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容较多</span></span><br><span class="line">ctrl+f  <span class="comment">#往下翻页(行比较多)</span></span><br><span class="line">ctrl+b  <span class="comment">#往上翻页</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.复制与粘贴</span></span><br><span class="line">yy      <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">5yy     <span class="comment">#复制当前光标以及光标向下4行</span></span><br><span class="line"> </span><br><span class="line">p(小写)   <span class="comment">#粘贴至当前光标下一行   </span></span><br><span class="line">P(大写)   <span class="comment">#粘贴至当前光标上一行</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.删除、剪贴、撤销  </span></span><br><span class="line">dd      <span class="comment">#删除当前光标所在的行   </span></span><br><span class="line">4dd     <span class="comment">#删除当前光标所在的行以及往下的3行</span></span><br><span class="line">dG      <span class="comment">#删除当前光标以后的所有行</span></span><br><span class="line">D       <span class="comment">#删除当前光标及光标以后的内容  </span></span><br><span class="line">x       <span class="comment">#删除当前光标标记往后的字符</span></span><br><span class="line">X       <span class="comment">#删除当前光标标记往前的字符</span></span><br><span class="line">dd &amp; p  <span class="comment">#剪贴、先删除dd(number dd)，后粘贴p</span></span><br><span class="line">u       <span class="comment">#撤销上一次的操作</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.替换</span></span><br><span class="line">r       <span class="comment">#替换当前光标标记的单个字符</span></span><br><span class="line">R       <span class="comment">#进入REPLACE模式, 连续替换，ESC结束</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编辑模式-从普通模式进入到编辑模式"><a href="#2-编辑模式-从普通模式进入到编辑模式" class="headerlink" title="2.编辑模式(从普通模式进入到编辑模式)"></a><em>2.编辑模式(从普通模式进入到编辑模式)</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i   <span class="comment">#进入编辑模式，光标不做任何操作</span></span><br><span class="line">a   <span class="comment">#进入编辑模式，将当前光标往后一位</span></span><br><span class="line">o   <span class="comment">#进入编辑模式，并在当前光标下添加一行空白内容</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">I   <span class="comment">#进入编辑模式，并且光标会跳转至本行的头部</span></span><br><span class="line">A   <span class="comment">#进入编辑模式，将光标移动至本行的尾部</span></span><br><span class="line">O   <span class="comment">#进入编辑模式，并在当前光标上添加一行空白内容</span></span><br></pre></td></tr></table></figure>

<h2 id="3-命令模式，主要用于搜索-保存-退出文件。"><a href="#3-命令模式，主要用于搜索-保存-退出文件。" class="headerlink" title="3.命令模式，主要用于搜索, 保存, 退出文件。"></a><em>3.命令模式，主要用于搜索, 保存, 退出文件。</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.文件保存与退出</span></span><br><span class="line">:w      保存当前状态</span><br><span class="line">:w!     强制保存当前状态</span><br><span class="line">:q      退出当前文档(文档必须保存才能退出)</span><br><span class="line">:q!     强制退出文档不会修改当前内容</span><br><span class="line">:wq     先保存，在退出</span><br><span class="line">:wq!    强制保存并退出</span><br><span class="line">:x      先保存，在退出</span><br><span class="line">ZZ      保存退出, shfit+zz</span><br><span class="line">:number 跳转至对应的行号</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容查找</span></span><br><span class="line">/string <span class="comment">#需要搜索的内容（查找）</span></span><br><span class="line">n       <span class="comment">#按搜索到的内容依次往下进行查找</span></span><br><span class="line">N       <span class="comment">#按搜索到的内容依次往上进行查找</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.文件内容替换</span></span><br><span class="line">:1,5s<span class="comment">#sbin#test#g   #替换1-5行中包含sbin的内容为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#g     #替换整个文本文件中包含sbin的替换为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#gc    #替换内容时时提示是否需要替换</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.文件内容另存</span></span><br><span class="line">:w /root/test.txt  <span class="comment">#将所有内容另存为/root/test.txt文件中</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.文件内容读入</span></span><br><span class="line">:r  /etc/hosts  <span class="comment">#读入/etc/hosts文件至当前光标下面</span></span><br><span class="line">:5r /etc/hosts  <span class="comment">#指定插入/etc/hosts文件至当前文件的第五行下面</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视图模式-从普通模式进入视图模式-，主要进行批量操作"><a href="#4-视图模式-从普通模式进入视图模式-，主要进行批量操作" class="headerlink" title="4.视图模式(从普通模式进入视图模式)，主要进行批量操作"></a><em>4.视图模式(从普通模式进入视图模式)，主要进行批量操作</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<h1 id="3-VIM扩展知识"><a href="#3-VIM扩展知识" class="headerlink" title="3.VIM扩展知识"></a>3.VIM扩展知识</h1><h2 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1.环境变量临时生效"></a><em>1.环境变量临时生效</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure>

<h2 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量"></a><em>2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3.如何同时编辑多个文件"></a><em>3.如何同时编辑多个文件</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure>

<h2 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4.相同文件之间差异对比，通常用于对比修改前后差异"></a><em>4.相同文件之间差异对比，通常用于对比修改前后差异</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后"><a href="#5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后" class="headerlink" title="5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后"></a><em>5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
</search>
