<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bash概述</title>
    <url>/2021/07/28/Bash%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.Bash Shell初步认识 2.Bash Shell基本特性 3.Bash Shell获取帮助 4.Bash Shell命令流程</p>
<span id="more"></span>
<h1 id="1-Bash-Shell初步认识"><a href="#1-Bash-Shell初步认识" class="headerlink" title="1.Bash Shell初步认识"></a>1.Bash Shell初步认识</h1><h2 id="1-什么是Bash-shell-壳"><a href="#1-什么是Bash-shell-壳" class="headerlink" title="1.什么是Bash shell(壳)"></a>1.什么是Bash shell(壳)</h2><p><em>Bash Shell 是一个命令解释器，它在操作系统的最外层，负责用户程序与内核进行交互操作的一种接口，将用户输入的命令翻译给操作系统，并将处理后的结果输出至屏幕。</em></p>
<p><img src="/images/QQ%E6%88%AA%E5%9B%BE20210727093855.png" alt="imageTitle"></p>
<p><em>当我们使用远程连接工具连接linux服务，系统则会给打开一个默认的shell，我们可在这个界面执行命令、比如：获取系统当前时间，创建一个用户等等….</em></p>
<h2 id="2-Bash-Shell能干什么"><a href="#2-Bash-Shell能干什么" class="headerlink" title="2.Bash Shell能干什么"></a>2.Bash Shell能干什么</h2><p><em>使用Shell实现对Linux系统的大部分管理，例如:<br> 1.文件管理<br> 2.权限管理<br> 3.用户管理<br> 4.磁盘管理<br> 5.网络管理<br> 6.软件管理<br> .等等.</em></p>
<h2 id="3-平时我们如何使用Shell？"><a href="#3-平时我们如何使用Shell？" class="headerlink" title="3.平时我们如何使用Shell？"></a>3.平时我们如何使用Shell？</h2><p><em>输入命令 –&gt; 效率低 –&gt; 适合少量的工作</em></p>
<p><em>Shell Script(脚本) –&gt; 效率高 –&gt; 适合复杂的重复性高的工作</em></p>
<p><em>例如:创建100个用户，单纯输入命令需要执行100次，而Shell脚本只需要几行命令即可完成100个用户的创建</em></p>
<h2 id="4-Shell提示符"><a href="#4-Shell提示符" class="headerlink" title="4.Shell提示符"></a>4.Shell提示符</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $ = 普通用户, # = root用户(超级管理员)</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># whoami</span></span><br><span class="line">root</span><br><span class="line"></span><br><span class="line">[root@web01 ~]<span class="comment"># useradd jack</span></span><br><span class="line">[root@web01 ~]<span class="comment"># passwd jack</span></span><br><span class="line">Changing password <span class="keyword">for</span> user jack.</span><br><span class="line">New password:</span><br><span class="line">BAD PASSWORD: The password is a palindrome</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-Shell基础语法"><a href="#5-Shell基础语法" class="headerlink" title="5.Shell基础语法"></a>5.Shell基础语法</h2><p><em>命令行bash shell，为用户提供输入，执行命令的界面</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令  选项  参数</span></span><br><span class="line"><span class="built_in">command</span> [-options] [arguments]</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls             #命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a          #命令+选项</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls -a /home/   #命令+选项+参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令: 整条shell命令的主体</span></span><br><span class="line"><span class="comment">#选项: 用于调节命令的具体功能</span></span><br><span class="line">    <span class="comment">#以 “-”引导短格式选项（单个字符），例如“-l”</span></span><br><span class="line">    <span class="comment">#以“--”引导长格式选项（多个字符），例如“--color”</span></span><br><span class="line">    <span class="comment">#多个短格式选项可以写在一起，只用一个“-”引导，例如“-al”</span></span><br><span class="line"><span class="comment">#参数: 命令操作的对象，如文件、目录名等</span></span><br><span class="line"><span class="comment"># 命令必须开头， 选项和参数位置可以发生变化</span></span><br></pre></td></tr></table></figure>

<h1 id="2-Bash-Shell基本特性"><a href="#2-Bash-Shell基本特性" class="headerlink" title="2.Bash Shell基本特性"></a>2.Bash Shell基本特性</h1><h3 id="1-命令补全"><a href="#1-命令补全" class="headerlink" title="1.命令补全"></a><em>1.命令补全</em></h3><p><em>当时用windows查找一个目录层级特别多的文件时，打开的效率会非常慢，但如果使用linux查找一个目录层级特别多的文件时，可以通过tab键快速的补全</em></p>
<p><em>PS:tab键可以实现命令补全，路径补全，在实际生产中tab补全往往是我们使用的最多的, 因为可以减少执行命令以及路径出错率.</em></p>
<h3 id="2-命令快捷键"><a href="#2-命令快捷键" class="headerlink" title="2.命令快捷键"></a><em>2.命令快捷键</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+a <span class="comment">#光标跳转至正在输入的命令行的首部</span></span><br><span class="line">ctrl+e <span class="comment">#光标跳转至正在输入的命令行的尾部</span></span><br><span class="line">ctrl+c <span class="comment">#终止前台运行的程序</span></span><br><span class="line">ctrl+d <span class="comment">#在shell中，ctrl+d表示退出当前shell</span></span><br><span class="line">ctrl+z <span class="comment">#将任务暂停，挂至后台</span></span><br><span class="line">ctrl+l <span class="comment">#清屏，和clear命令等效</span></span><br><span class="line">ctrl+k <span class="comment">#删除从光标到行末的所有字符</span></span><br><span class="line">ctrl+u <span class="comment">#删除从光标到行首的所有字符</span></span><br><span class="line">ctrl+r <span class="comment">#搜索历史命令，利用关键字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在命令行前加面加 &quot;#&quot; 则该命令不会被执行，一般用作注释</span></span><br></pre></td></tr></table></figure>

<h3 id="3-历史命令history"><a href="#3-历史命令history" class="headerlink" title="3.历史命令history"></a><em>3.历史命令history</em></h3><p><em>-w 保存命令历史到历史文件<br> -c 清空命令历史记录, 不会情况文件<br> -d 删除命令历史的第 N 条行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用双 !! 可执行上一条执行过的命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls</span></span><br><span class="line">lucifer.com</span><br><span class="line">[root@lucifer ~]<span class="comment"># !!</span></span><br><span class="line">ls</span><br><span class="line">lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.输入!6, 执行history命令历史中第 6 行命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !6</span></span><br><span class="line">touch lucifer.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用!cat, 调用history命令历史最近一次执行过的cat命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># !cat</span></span><br><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls /etc/passwd</span></span><br><span class="line"><span class="comment">#调用上一条命令的最后参数或选项, 按下ESC松开, 然后按下 &quot;.&quot;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"><span class="comment">#第二种方式, 输入!$</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ls !$</span></span><br><span class="line">ls /etc/passwd</span><br><span class="line">/etc/passwd</span><br></pre></td></tr></table></figure>

<h3 id="4-历史别名"><a href="#4-历史别名" class="headerlink" title="4.历史别名"></a><em>4.历史别名</em></h3><p><em>命令别名将用户经常使用的复杂命令简单化, 可以用<code>&quot;alias 别名名称=命令&quot;</code>命令创建属于自己的命令别名, 若要取消一个命令别名，则是用<code>unalias 别名名称</code>命令。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.定义临时别名, wk为查看eth0网卡别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias wk=&#x27;ifconfig&#x27;</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># wk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.如果定义命令本身, 会执行什么?</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># alias ifconfig=&#x27;ifconfig eth0&#x27;</span></span><br><span class="line">    <span class="comment">#绝对路径执行, 调用命令本身</span></span><br><span class="line">    [root@lucifer ~]<span class="comment"># /sbin/ifconfig</span></span><br><span class="line">    <span class="comment">#通过\转义字符, 调用命令本身</span></span><br><span class="line">    [root@WebServer ~]<span class="comment"># \ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.取消别名</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># unalias ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.永久生效，/etc/bashrc</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;alias ifconfig=&#x27;ifconfig eth0&#x27;&quot; &gt;&gt; /etc/bashrc</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Bash-Shell获取帮助"><a href="#3-Bash-Shell获取帮助" class="headerlink" title="3.Bash Shell获取帮助"></a>3.Bash Shell获取帮助</h1><h3 id="1-命令-–help帮助"><a href="#1-命令-–help帮助" class="headerlink" title="1.命令 –help帮助"></a><em>1.命令 –help帮助</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls --help</span></span><br><span class="line">用法: ls [选项]...[文件]...</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 常见选项</span></span><br><span class="line">-a  <span class="comment">#查看目录下的所有文件，包括隐藏文件</span></span><br><span class="line">-l  <span class="comment">#以长格式的方式显示文件的详细内容</span></span><br><span class="line">-h  <span class="comment">#以人性化的方式显示内容，配合-l使用</span></span><br><span class="line">-d  <span class="comment">#只列出目录名，不列出目录以下的内容</span></span><br><span class="line">-t  <span class="comment">#按修改时间进行排序</span></span><br><span class="line">-i  <span class="comment">#显示文件的inode(该文件在该分区的一个编号)</span></span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># date --help</span></span><br><span class="line">Usage: date [OPTION]... [+FORMAT]</span><br><span class="line">  or:  date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line">  </span><br><span class="line">[root@lucifer ~]<span class="comment"># date +%F   #查看日期</span></span><br><span class="line">2019-03-28</span><br><span class="line">[root@lucifer ~]<span class="comment"># date -s 12:00  #修改时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#时间不是用来查看，而是有其他的用途</span></span><br><span class="line">[root@web01 ~]<span class="comment"># touch `date +%F`_file.txt</span></span><br><span class="line">[root@web01 ~]<span class="comment"># ls</span></span><br><span class="line">2019-03-28_file.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-命令man手册"><a href="#2-命令man手册" class="headerlink" title="2.命令man手册"></a><em>2.命令man手册</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#man ls #查看ls命令手册</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Linux命令大全传送门"><a href="#3-Linux命令大全传送门" class="headerlink" title="3.Linux命令大全传送门"></a><em>3.Linux命令大全传送门</em></h3><p><em>linux命令大全： <a href="https://man.linuxde.net/">https://man.linuxde.net/</a></em></p>
<p><em>linux命令手册：<a href="http://linux.51yip.com/">http://linux.51yip.com/</a></em></p>
<h1 id="4-Bash-Shell命令流程"><a href="#4-Bash-Shell命令流程" class="headerlink" title="4.Bash Shell命令流程"></a>4.Bash Shell命令流程</h1><h3 id="1-当我们执行一个命令-整个命令执行流程如下"><a href="#1-当我们执行一个命令-整个命令执行流程如下" class="headerlink" title="*1.当我们执行一个命令, 整个命令执行流程如下:"></a>*1.当我们执行一个命令, 整个命令执行流程如下:</h3><ol>
<li>判断命令是否通过绝对路径执行</li>
<li>判断命令是否存在alias别名</li>
<li>判断用户输入的是内部命令还是外部命令</li>
<li>Bash内部命令直接执行，外部命令检测是否存在缓存</li>
<li>通过PATH路径查找命令，有执行，无报错*</li>
</ol>
<h3 id="2-什么是内部命令，什么是外部命令"><a href="#2-什么是内部命令，什么是外部命令" class="headerlink" title="2.什么是内部命令，什么是外部命令"></a><em>2.什么是内部命令，什么是外部命令</em></h3><p> <em>内部命令: shell程序自带的命令。<br> 外部命令: 在系统PATH变量的某个路径下的可执行程序。</em></p>
<h3 id="3-如何检查用户输入的命令是内部命令还是外部命令"><a href="#3-如何检查用户输入的命令是内部命令还是外部命令" class="headerlink" title="3.如何检查用户输入的命令是内部命令还是外部命令"></a><em>3.如何检查用户输入的命令是内部命令还是外部命令</em></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd命令属于shell内部命令</span></span><br><span class="line">[root@linux-node1 ~]<span class="comment"># type -a cd</span></span><br><span class="line"><span class="built_in">cd</span> is a shell <span class="built_in">builtin</span></span><br><span class="line"><span class="built_in">cd</span> is /usr/bin/<span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ping属于外部命令, 同时会打印当前命令路径</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># type -a  ping</span></span><br><span class="line">ping is /bin/ping</span><br></pre></td></tr></table></figure>

<p><em>4.如果是外置命令，Bash可以通过查找PATH变量，获取该命令的绝对路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打印当前环境变量目录</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br></pre></td></tr></table></figure>

<p><em>PS: PATH由多个路径组成，每个路径值之间用冒号间隔，对这些路径的增加和删除操作都将影响到Bash解释器对Linux命令的查找</em></p>
<p><em>5.如果是外置命令还会涉及到一个内存缓存，也就是说，当我们出现重复执行相同的命令，会通过缓存调取执行，也就意味着不会搜索PATH路径。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#表缓存命令所在位置</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash</span></span><br><span class="line">hits    <span class="built_in">command</span></span><br><span class="line">   1    /usr/bin/tty</span><br><span class="line">   3    /sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment">#已缓存命令,如果移动位置会导致无法找到该命令</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mv /sbin/ifconfig /bin/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line">-bash: /sbin/ifconfig: No such file or directory</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除缓存过的ifconfig命令, 即可执行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -d ifconfig</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当然可以清空缓存表</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># hash -r</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意: 命令缓存hash需要注意如下情况:</span></span><br><span class="line">1.只要执行外部命令1次就会对该命令进行缓存</span><br><span class="line">2.如果将命令移动了位置，该如何执行</span><br><span class="line">    a.使用绝对路径执行</span><br><span class="line">    b.删除<span class="built_in">hash</span>表的缓存指令</span><br></pre></td></tr></table></figure>

<h3 id="命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下"><a href="#命令执行流程总结-当我们执行了一个ping命令之后-整个命令执行的流程步骤如下" class="headerlink" title="命令执行流程总结: 当我们执行了一个ping命令之后, 整个命令执行的流程步骤如下:"></a><em>命令执行流程总结: 当我们执行了一个<code>ping</code>命令之后, 整个命令执行的流程步骤如下:</em></h3><p><em>1) 检查执行的命令是否使用的是绝对路径执行的。<br> 2) 检查ping命令是否存在alias别名<br> 3) 检查ping命令是内部命令还是外部命令<br> 4) 如果是内部命令Bash直接执行，如果是外部命令，首先检查Hash缓存，存在则直接调取<br> 5) 如果该命令不存在Hash缓存，则通过PATH路径进行逐行查找该命令所在的位置<br> 6) 如果PATH路径没有查找到该命令所在的路径，则返回错误码。command not found</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>Bash -</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/08/12/ELK/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<h1 id="第1章-Elasticsearch介绍"><a href="#第1章-Elasticsearch介绍" class="headerlink" title="第1章 Elasticsearch介绍"></a>第1章 Elasticsearch介绍</h1><h2 id="1-什么是Lucene"><a href="#1-什么是Lucene" class="headerlink" title="1.什么是Lucene"></a>1.什么是Lucene</h2><p><em>Lucene是一个高性能的java搜索引擎库,操作非常繁琐，需要具备java开发经验。</em><br><em>Elasticsearch是基于Lucene之上包装一层外壳，屏蔽了Lucene的复杂操作，即使不会java语言也可以快速上手</em></p>
<span id="more"></span>

<h2 id="2-什么是全文检索和倒排索引"><a href="#2-什么是全文检索和倒排索引" class="headerlink" title="2.什么是全文检索和倒排索引"></a>2.什么是全文检索和倒排索引</h2><p><strong>索引就好比书的目录，</strong><br><em>如果我们想快速查看某个章节，只需要找到目录里相应章节对应的页数即可。<br>通过目录找到章节，通过章节找到页码这个过程就是索引的过程。</em></p>
<p><em>索引的目的就是加快数据搜索的效率。</em></p>
<p><a href="http://note.youdao.com/noteshare?id=28a29c863323153e8696c846c0be7a17">http://note.youdao.com/noteshare?id=28a29c863323153e8696c846c0be7a17</a></p>
]]></content>
      <categories>
        <category>ELK -</category>
      </categories>
      <tags>
        <tag>ELK -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/2021/07/28/Linuxuser/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.用户基本概述 2.用户相关命令 3.用户扩展知识 3.用户组的管理 4.用户如何提权</p>
<span id="more"></span>
<h1 id="1-用户基本概述"><a href="#1-用户基本概述" class="headerlink" title="1.用户基本概述"></a>1.用户基本概述</h1><p><em><strong>1.什么是用户?</strong></em></p>
<p><em>用户指的是能够正常登录Linux或Windows系统(可以理解为你租了房子，能够正常入驻)<br>F:那Linux与Windows系统的用户有什么区别? Q:本质都是登陆系统，只不过Linux支持多个用户同时登陆。<br>F:难道Windows就不算多用户操作系统吗? Q:其实不是，在Windows系统中可以创建多个用户，但不允许同一时刻多个用户登陆系统，但Linux系统则允许同一时刻多个用户同时登陆，登陆后相互之间操作并不影响。</em></p>
<p><em><strong>2.Linux下的用户有什么用，或者说我们为什么要创建用户？</strong></em></p>
<p><em>1.系统上的每一个进程(运行的程序)，都需要一个特定的用户运行<br>2.通常在公司是使用普通用户管理服务器，因为root权限过大，容易造成故障。</em></p>
<p><em><strong>3.如何查看系统中所存在的用户</strong></em></p>
<p><em>1.查看当前登录的用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># id    #查看当前所登陆的用户信息</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@bgx ~]<span class="comment"># id oldboy #查看其它用户的信息</span></span><br><span class="line">uid=1000(oldboy) gid=1000(oldboy) groups=1000(oldboy)</span><br></pre></td></tr></table></figure>

<p><em>2.每一个进程都会由一个用户身份运行</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ps aux|less #简单使用一下，不用理解</span></span><br><span class="line">root      33782  0.0  0.0      0     0 ?        R    02:46   0:00 [kworker/u256:0]</span><br><span class="line">root      35637  0.0  0.0      0     0 ?        R    05:11   0:03 [kworker/0:2]</span><br></pre></td></tr></table></figure>

<p><em><strong>4.那我们的用户存在哪呢?</strong></em></p>
<p><em>Linux系统会将用户的信息存放在/etc/passwd，记录了用户的信息，但没有密码信息，密码被存放在/etc/shadow中。也就是说这两个文件非常的重要，不要轻易删除与修改。</em></p>
<p><em>1./etc/passwd 配置文件解释如下图，或者man 5 passwd</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/shadow 配置文件解释如下图，或者man 5 shadow</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728213756.png" alt="imageTitle"></p>
<p><em><strong>4.最后我们需要了解下系统对用户的一个约定？(约定娶你，就真的会娶吗？)</strong></em></p>
<table>
<thead>
<tr>
<th>用户UID</th>
<th>系统中约定的含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>超级管理员，最高权限，有着极强的破坏能力</td>
</tr>
<tr>
<td>1~200</td>
<td>系统用户，用来运行系统自带的进程，默认已创建</td>
</tr>
<tr>
<td>201~999</td>
<td>系统用户，用来运行用户安装的程序，所以此类用户无需登录系统</td>
</tr>
<tr>
<td>1000+</td>
<td>普通用户，正常可以登陆系统的用户，权限比较小，能执行的任务有限</td>
</tr>
</tbody></table>
<p><em>PS:在CentOS7系统之前, UID1-499用于系统用户, 而UID 500+则用于普通用户</em></p>
<h1 id="2-用户相关命令"><a href="#2-用户相关命令" class="headerlink" title="2.用户相关命令"></a>2.用户相关命令</h1><p><em>下面我们就围绕着用户的创建、变更、删除等来讲讲涉及到的命令: useradd、usermod、userdel</em></p>
<p><em>1.使用useradd命令新增用户，注意: adduser命令软链接指向useradd命令</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要创建用户的UID,不允许冲突</span></span><br><span class="line"><span class="comment"># -g 指定要创建用户默认组</span></span><br><span class="line"><span class="comment"># -G 指定要创建用户附加组,逗号隔开可添加多个附加组</span></span><br><span class="line"><span class="comment"># -d 指定要创建用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要创建用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要创建用户注释信息</span></span><br><span class="line"><span class="comment"># -M 给创建的用户不创建家目录</span></span><br><span class="line"><span class="comment"># -r 创建系统账户，默认无家目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建bgx用户，UID5001,基本组students，附加组sa 注释信息:2019 new student,登陆shell:/bin/bash</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd students</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -u 5001 -g students -G sa -c &quot;2019 new student&quot; -s /bin/bash bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建mysql系统用户，-M不建立用户家目录 -s指定nologin使其用户无法登陆系统</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd mysql -M -s /sbin/nologin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd -r dba -s /sbin/nologin</span></span><br></pre></td></tr></table></figure>

<p><em>2.如何使用usermod命令修改用户信息</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="comment"># -u 指定要修改用户的UID</span></span><br><span class="line"><span class="comment"># -g 指定要修改用户基本组</span></span><br><span class="line"><span class="comment"># -G 指定要修改用户附加组，使用逗号隔开多个附加组, 覆盖原有的附加组</span></span><br><span class="line"><span class="comment"># -d 指定要修改用户家目录</span></span><br><span class="line"><span class="comment"># -s 指定要修改用户的bash shell</span></span><br><span class="line"><span class="comment"># -c 指定要修改用户注释信息</span></span><br><span class="line"><span class="comment"># -l 指定要修改用户的登陆名</span></span><br><span class="line"><span class="comment"># -L 指定要锁定的用户</span></span><br><span class="line"><span class="comment"># -U 指定要解锁的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.检查此前创建的用户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx:x:5001:503:2019 new student:/home/bgx:/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.修改bgx用户uid、gid，附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5008 network_sa</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5009 devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -u 6001 -g5008 -a -G 5009 bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.修改bgx用户的注释信息, 用户家目录, 登录shell, 登录名</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -c &quot;2019 new student&quot; -md /bgx -s /bin/sh -l change_bgx bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否修改成功</span></span><br><span class="line">[root@bgx ~]<span class="comment"># grep &quot;bgx&quot; /etc/passwd</span></span><br><span class="line">bgx_xuliangwei:x:6001:5008:2019 new student:/bgx:/bin/sh</span><br><span class="line">[root@bgx ~]<span class="comment"># id change_bgx</span></span><br><span class="line">uid=6001(change_bgx) gid=5008(network_sa) groups=5008(network_sa),503(sa),5009(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /bgx</span></span><br><span class="line">drwx------. 2 bgx_xuliangwei network_sa 4096 2014-09-23 00:13 /bgx</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.锁定用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo &quot;123&quot; |passwd --stdin change_bgx</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -L change_bgx  #锁定后会无法登陆系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解锁用户[扩展]</span></span><br><span class="line">[root@bgx ~]<span class="comment"># usermod -U change_bgx</span></span><br></pre></td></tr></table></figure>

<p>*S: 当然还有很多命令可以查看用户的信息，以下简单列举一些，但都是我们常用，所以了解即可</p>
<ol>
<li>使用finger命名查询用户信息以及登录信息，示例: finger UserName</li>
<li>使用chfn命令修改用户信息，示例: chfn UserName</li>
<li>使用chsh命令修改用户登录Bash Shell，示例: chsh UserName</li>
<li>使用who、whoami、w检查用户登陆情况*</li>
</ol>
<p><em>3.使用userdel命令删除账户</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项 -r 删除用户同时删除它的家目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.删除user1用户，但不删除用户家目录和 mail spool</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel user1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.-r参数可以连同用户家目录一起删除(慎用)</span></span><br><span class="line">[root@bgx ~]<span class="comment"># userdel -r user1</span></span><br></pre></td></tr></table></figure>

<h1 id="3-用户扩展知识"><a href="#3-用户扩展知识" class="headerlink" title="3.用户扩展知识"></a>3.用户扩展知识</h1><p><em><strong>1.前面我们学习如何创建、修改、删除用户，接下来了解下用户的创建流程？</strong></em></p>
<p><em>1.useradd创建用户时，系统会以/etc/login.defs、/etc/defaults/useradd两个配置文件作为参照物，如果在创建用户时指定了参数则会覆盖/etc/login.defs、/etc/defaults/useradd文件默认配置，如未指定则使用默认。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/login.defs</span></span><br><span class="line">MAIL_DIR    /var/spool/mail</span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DAYS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line">UID_MIN                  1000</span><br><span class="line">UID_MAX                 60000</span><br><span class="line">SYS_UID_MIN               201</span><br><span class="line">SYS_UID_MAX               999</span><br><span class="line">GID_MIN                  1000</span><br><span class="line">GID_MAX                 60000</span><br><span class="line">SYS_GID_MIN               201</span><br><span class="line">SYS_GID_MAX               999</span><br><span class="line">CREATE_HOME yes</span><br><span class="line">UMASK           077</span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line">ENCRYPT_METHOD SHA512</span><br><span class="line"></span><br><span class="line">[root@bgx ~]<span class="comment"># cat /etc/default/useradd</span></span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home      <span class="comment">#把用户的家目录建在/home中。</span></span><br><span class="line">INACTIVE=-1     <span class="comment">#是否启用账号过期停权,-1表示不启用。</span></span><br><span class="line">EXPIRE=         <span class="comment">#账号终止日期,不设置表示不启用。</span></span><br><span class="line">SHELL=/bin/bash <span class="comment">#新用户默认所有的shell类型。</span></span><br><span class="line">SKEL=/etc/skel  <span class="comment">#配置新用户家目录的默认文件存放路径。</span></span><br><span class="line">CREATE_MAIL_SPOOL=yes   <span class="comment">#创建mail文件。</span></span><br></pre></td></tr></table></figure>

<p><em>2.当使用useradd创建用户时，创建的用户家目录下会存在 .bash_* 环境变量相关的文件，这些环境变量文件默认从/etc/skel目录中拷贝。这个默认拷贝环境变量位置是由/etc/defaults/useradd配置文件中定义的。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#故障案例，在当前用户家目录执行了rm -rf .*，下次登录系统时出现-bash-4.1$，如何解决！</span></span><br><span class="line">-bash-4.1$ cp -a /etc/skel/.bash* ./</span><br><span class="line">-bash-4.1$ <span class="built_in">exit</span></span><br><span class="line">[root@bgx ~]<span class="comment">#   #重新连接即可恢复</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.如何为新用户设定密码，又如何变更用户密码</strong></em></p>
<p><em>创建用户后，如需要使用该用户登陆系统则需要为用户设定密码，设定密码使用passwd命令。建议密码复杂度高一些、长度大于10、出现各种特殊字符、无任何规律(不要出现名字，电话，生日等)<br> PS: 注意事项<br> 1.普通用户只允许变更自己的密码，无法修改其他人密码，并且密码长度必须8位字符<br> 2.管理员用户允许修改任何人的密码，无论密码长度多长或多短。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用passwd命令修改用户密码</span></span><br><span class="line"><span class="comment"># passwd        #给当前用户修改密码</span></span><br><span class="line"><span class="comment"># passwd root   #给root用户修改密码</span></span><br><span class="line"><span class="comment"># passwd oldboy #给oldboy用户修改密码，普通用户只能自己修改自己</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.验证如下几项指标</span></span><br><span class="line"><span class="comment"># passwd                #root管理员用户登陆，修改root用户密码</span></span><br><span class="line"><span class="comment"># passwd Lucifer        #root用户登陆，修改其他用户的密码</span></span><br><span class="line">$ passwd root           <span class="comment">#普通用户修改root管理员密码</span></span><br><span class="line"><span class="comment"># echo &quot;123&quot; | passwd --stdin xuliangwei    #非交互式修改密码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.系统内置变量生成随机字符串</span></span><br><span class="line">[root@bgx ~]<span class="comment"># echo $RANDOM|md5sum|cut -c 1-10</span></span><br><span class="line">d09fe9b1xs</span><br><span class="line">[root@bgx ~]<span class="comment"># echo $(echo $RANDOM|md5sum |cut -c 5-14) |tee pass.txt| passwd --stdin xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.mkpasswd生成随机字符串, -l设定密码长度,-d数子,-c小写字母,-C大写字母,-s特殊字符</span></span><br><span class="line">[root@bgx ~]<span class="comment"># yum install -y expect   //需要安装扩展包</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkpasswd -l 10 -d 2 -c 2 -C 2 -s 4</span></span><br><span class="line">|K&amp;13bR)i/</span><br></pre></td></tr></table></figure>

<p><em>PS: 推荐密码保存套件工具，支持windows、MacOS、Iphone以及浏览器插件<a href="https://www.lastpass.com/zh">Lastpass官方网站</a></em></p>
<h1 id="3-用户组的管理"><a href="#3-用户组的管理" class="headerlink" title="3.用户组的管理"></a>3.用户组的管理</h1><p><em><strong>1.什么是用户组？</strong></em></p>
<p><em>其实就是一种逻辑层面的定义，逻辑上将多个用户归纳至一个组，当我们对组操作，其实就相当于对组中的所有用户操作。</em></p>
<p><em><strong>2.对于用户来说，组有几种类别？</strong></em></p>
<p><em>基本组，用户只能有一个基本组，创建时可通过-g指定，如未指定则创建一个默认的组(与用户同名)</em></p>
<p><em>附加组，基本组不能满足授权要求，创建附加组，将用户加入该组，用户可以属于多个附加组</em></p>
<p><em><strong>3.那组的信息保存在哪呢？</strong></em></p>
<p><em>组账户信息保存在/etc/group和/etc/gshadow两个文件中。重点关注group</em></p>
<p><em>1./etc/group 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728205403.png" alt="imageTitle"></p>
<p><em>2./etc/gshadow 配置文件解释如下图</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728211204.png" alt="imageTitle"><br><em>1.使用groupadd命令新增组，groupadd [-g GID] groupname</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建基本组, 不指定gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">no_gid:x:1000:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建基本组, 指定gid为5555</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -g 5555 yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">yes_gid:x:5555:</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建系统组，gid从201-999</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupadd -r sys_group</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -n1 /etc/group</span></span><br><span class="line">sys_group:x:990:</span><br></pre></td></tr></table></figure>

<p><em>2.使用groupmod命令新增组</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-g 修改组gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -g 1111 no_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">no_gid:x:1111:</span><br><span class="line"></span><br><span class="line"><span class="comment">#-n 修改组名称</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupmod -n active_group yes_gid</span></span><br><span class="line">[root@bgx ~]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">active_group:x:5555:</span><br></pre></td></tr></table></figure>

<p><em>3.groupdel删除组，删除时需要注意，如果用户存在基本组则无法直接删除该组，如果删除用户则会移除默认的私有组，而不会移除基本组。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel active_group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除用户附加组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei),5004(devops)</span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel devops</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id Lucifer</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#无法删除用户基本组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># groupdel network_sa</span></span><br><span class="line">groupdel: cannot remove the primary group of user <span class="string">&#x27;bgx_xuliangwei&#x27;</span></span><br><span class="line"><span class="comment">#只有删除用户或者用户变更基本后,方可删除该组</span></span><br></pre></td></tr></table></figure>

<p><em>4.使用gpasswd设置组密码[扩展，可以不会]</em></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># groupadd devops</span></span><br><span class="line">[<span class="meta">root@bgx ~</span>]<span class="meta"># gpasswd devops</span></span><br><span class="line">Changing the password <span class="keyword">for</span> <span class="keyword">group</span> devops</span><br><span class="line">New Password:</span><br><span class="line">Re-enter <span class="keyword">new</span> password:</span><br></pre></td></tr></table></figure>

<p><em>5.使用newgrp命令切换基本组身份[扩展，可以不会]</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.检查账户信息</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd xuliangwei</span></span><br><span class="line">[root@bgx ~]<span class="comment"># id xuliangwei</span></span><br><span class="line">uid=1069(xuliangwei) gid=5005(xuliangwei) groups=5005(xuliangwei)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建新文件,查看文件的属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_roots</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用newgrp切换到devops组</span></span><br><span class="line">[xuliangwei@bgx ~]$ newgrp devops</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.创建文件，检查属主和属组</span></span><br><span class="line">[xuliangwei@bgx ~]$ touch file_test</span><br><span class="line">[xuliangwei@bgx ~]$ ll</span><br><span class="line">-rw-rw-r-- 1 xuliangwei xuliangwei 0 Jun 13 10:06 file_roots</span><br><span class="line">-rw-r--r-- 1 xuliangwei devops     0 Jun 13 10:08 file_test</span><br></pre></td></tr></table></figure>

<h1 id="4-用户如何提权"><a href="#4-用户如何提权" class="headerlink" title="4.用户如何提权"></a>4.用户如何提权</h1><p><em>往往公司的服务器对外都是禁止root用户直接登录，所以我们通常使用的都是普通用户，那么问题来了？<br> 当我们使用普通用户执行/sbin目录下的命令时，会发现没有权限运行，这种情况下我们无法正常的管理服务器，那如何才能不使用root用户直接登录系统，同时又保证普通用户能完成日常工作？<br> PS: 我们可以使用如下两种方式: su、sudo<br> 1.su切换用户，使用普通用户登录，然后使用su命令切换到root。优点:简单 缺点:需要知道root密码<br> 2.sudo提权，当需要使用root权限时进行提权，而无需切换至root用户，优点:安全、方便 缺点:复杂</em></p>
<p><em><strong>1.su身份切换</strong></em></p>
<p><em>在使用su切换前，我们需要了解一些预备知识，比如shell分类、环境变量配置文件有哪些</em></p>
<p><em>1.Linux Shell主要分为如下几类<br>交互式shell，等待用户输入执行的命令(终端操作,需要不断提示)<br>非交互式shell，执行shell脚本, 脚本执行结束后shell自动退出<br>登陆shell，需要输入用户名和密码才能进入Shell，日常接触的最多的一种<br>非登陆shell，不需要输入用户和密码就能进入Shell,比如运行bash会开启一个新的会话窗口</em></p>
<p><em>2.bash shell配置文件介绍(文件主要保存用户的工作环境)<br>个人配置文件：~/.bash_profile ~/.bashrc 。全局配置文件：/etc/profile /etc/profile.d/*.sh /etc/bashrc<br>profile类文件, 设定环境变量, 登陆前运行的脚本和命令。bashrc 类文件, 设定本地变量, 定义命令别名<br>PS: 如果全局配置和个人配置产生冲突，以个人配置为准。</em></p>
<p><em>3.登陆系统后，环境变量配置文件的应用顺序是?</em><br> <em>登录式shell配置文件执行顺序: /etc/profile-&gt;/etc/profile.d/*.sh-&gt;<del>/.bash_profile-&gt;</del>/.bashrc-&gt;/etc/bashrc<br> 非登陆式shell配置文件执行顺序: ~/.bashrc-&gt;/etc/bashrc-&gt;/etc/profile.d/*.sh<br> PS: 验证使用echo在每行添加一个输出即可</em></p>
<p><em>4.说了这么多预备知识，那这些和su命令切换用户有什么关系?<br> su - username属于登陆式shell，su username属于非登陆式shell，区别在于加载的环境变量不一样。<br>普通用户<code>su -</code>可以直接切换至root用户，但需要输入root用户的密码。<br>超级管理员root用户使用<code>su - username</code>切换普通用户不需要输入任何密码。</em> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.普通用户使用su切换root</span></span><br><span class="line">[xuliangwei@node1 ~]$ su</span><br><span class="line">密码：         <span class="comment">#输入root的密码</span></span><br><span class="line">[root@node1 xuliangwei]<span class="comment"># pwd</span></span><br><span class="line">/home/xuliangwei</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.普通用户使用su -切换到root，会加载root的环境变量</span></span><br><span class="line">[xuliangwei@node1 ~]$ su -</span><br><span class="line">密码：</span><br><span class="line">[root@node1 ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.以某个用户的身份执行某个服务，使用命令su -c username</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ifconfig&#x27;</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - lucifer -c &#x27;ls ~&#x27;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>2.sudo提权</strong></em></p>
<p><em>su命令在切换用户身份时，如果每个普通用户都能拿到root用户的密码，当其中某个用户不小心泄漏了root的密码，那系统会变得非常不安全。为了改进这个问题，从而产生了sudo这个命令。</em></p>
<p><em>其实sudo就相当于给某个普通用户埋下了浩克(hulk)的种子，当需要执行一些高级操作时，进行发怒，但正常情况下还是普通人，还是会受到限制。</em></p>
<p><em>1.如何快速埋下hulk的种子呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.快速配置sudo方式[先睹为快]</span></span><br><span class="line">[root@node1 ~]<span class="comment"># usermod bgx -G wheel</span></span><br><span class="line">[root@node1 ~]$ sudo tail -f /var/<span class="built_in">log</span>/secure    <span class="comment">#sudo审计日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.一般正常配置sudo方式</span></span><br><span class="line">[root@www ~]<span class="comment"># #visudo =&gt; vim /etc/sudoers</span></span><br><span class="line"><span class="comment">#1.用户名  2.主机名=(角色名）       4.命令名</span></span><br><span class="line">bgx       ALL=(ALL)         /usr/bin/yum,/usr/sbin/useradd   <span class="comment">#允许使用sudo执行命令</span></span><br><span class="line">oldboy   ALL=(ALL)          NOPASSWD:/bin/cp, /bin/rm   <span class="comment">#NOPASSWD不需要使用密码</span></span><br></pre></td></tr></table></figure>

<p><em>2.埋下了hulk种子后又如何提权使用呢？</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.切换普通用户</span></span><br><span class="line">[root@bgx ~]<span class="comment"># su - xuliangwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.检查普通用户能提权的命令</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo -l</span><br><span class="line">User xuliangwei may run the following commands on this host:</span><br><span class="line">    (ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.普通用户正常情况下是无法删除opt目录的</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ rm -rf /opt/</span><br><span class="line">rm: cannot remove `/opt: Permission denied</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用sudo提权，需要输入普通用户的密码。</span></span><br><span class="line">[xuliangwei@xuliangwei ~]$ sudo rm -rf /opt</span><br></pre></td></tr></table></figure>

<p><em>3.提升的权限太大，能否有办法限制仅开启某个命令的使用权限？其他命令不允许？</em></p>
<p><em>第一种方式:使用sudo中自带的别名操作,将多个用户定义成一个组,这个组只有sudo认可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># visudo  #也可以使用vi /etc/sudoers来配置</span></span><br><span class="line"><span class="comment"># 1.使用sudo定义分组,这个系统group没什么关系</span></span><br><span class="line">User_Alias OPS = oldboy,alex</span><br><span class="line">User_Alias DEV = bgx,py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.定义可执行的命令组,便于后续调用</span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用sudo开始分配权限</span></span><br><span class="line">OPS  ALL=(ALL) NETWORKING,SOFTWARE,SERVICES,STORAGE,DELEGATING,PROCESSES</span><br><span class="line">DEV  ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.登陆对应的用户使用 sudo -l 验证权限</span></span><br></pre></td></tr></table></figure>

<p><em>第二种方式:使用groupadd添加组,然后给组分配sudo的权限,如果有新用户加入,直接将用户添加到该组.</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.添加两个真实的系统组,  group_dev group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># groupadd group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.添加两个用户,      group_dev(user_a  user_b)   group_op(user_c  user_d)</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_a -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_b -G group_dev</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_c -G group_op</span></span><br><span class="line">[root@www ~]<span class="comment"># useradd user_d -G group_op</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.记得添加密码</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_a</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_b</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_c</span></span><br><span class="line">[root@www ~]<span class="comment"># echo &quot;1&quot; | passwd --stdin user_d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.在sudo中配置规则</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo</span></span><br><span class="line">    Cmnd_Alias NETWORKING = /sbin/ifconfig, /bin/ping</span><br><span class="line">    Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/yum</span><br><span class="line">    Cmnd_Alias SERVICES = /sbin/service, /usr/bin/systemctl start</span><br><span class="line">    Cmnd_Alias STORAGE = /bin/mount, /bin/umount</span><br><span class="line">    Cmnd_Alias DELEGATING = /bin/chown, /bin/chmod, /bin/chgrp</span><br><span class="line">    Cmnd_Alias PROCESSES = /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br><span class="line"></span><br><span class="line">    %group_dev ALL=(ALL) SOFTWARE</span><br><span class="line">    %group_op ALL=(ALL) SOFTWARE,PROCESSES</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.检查sudo是否配置有错</span></span><br><span class="line">[root@www ~]<span class="comment"># visudo -c</span></span><br><span class="line">/etc/sudoers: parsed OK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#6.检查user_a,和user_d的sudo权限</span></span><br><span class="line">[user_a@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_a may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum</span><br><span class="line"></span><br><span class="line">[user_d@www.oldboyedu.com ~]$ sudo -l</span><br><span class="line">User user_d may run the following commands on www:</span><br><span class="line">    (ALL) /bin/rpm, /usr/bin/yum, /bin/nice, /bin/<span class="built_in">kill</span>, /usr/bin/<span class="built_in">kill</span>, /usr/bin/killall</span><br></pre></td></tr></table></figure>

<p><em>4.sudo命令的执行流程:</em><br> <em>1) 普通用户执行sudo命令时, 会检查/var/db/sudo是否存在时间戳缓存<br> 2) 如果存在则不需要输入密码, 否则需要输入用户与密码<br> 3) 输入密码会检测是否该用户是否拥有该权限<br> 4) 如果有则执行，否则报错退出</em></p>
<p><em>下图为sudo执行流程</em><br><img src="/images/QQ%E6%88%AA%E5%9B%BE20210728212235.png" alt="imageTitle"></p>
<p><a href="https://www.jianshu.com/p/d172a92475f1">sudo不支持系统内置命令</a></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>用户 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基本权限</title>
    <url>/2021/08/02/Linux%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.权限基本概述  2.权限设置示例  3.权限设置案例  4.属主属组设置</p>
<span id="more"></span>

<h1 id="1-权限基本概述"><a href="#1-权限基本概述" class="headerlink" title="1.权限基本概述"></a>1.权限基本概述</h1><p><em><strong>1.什么是权限？</strong></em></p>
<p><em>我们可以把它理解为操作系统对用户能够执行的功能所设立的限制，主要用于约束用户能对系统所做的操作，以及内容访问的范围，或者说，权限是指某个特定的用户具有特定的系统资源使用权力。</em></p>
<p><em><strong>2.为什么要有权限</strong></em></p>
<p><em>因为系统中不可能只存在一个root用户，一定会存在多个用户，为了保护每个登陆用户的隐私和工作环境，所以就有了权限。(比如三个租客合租同一个房子，a租客要使用b租客的肥皂，那这个事情？？</em></p>
<p><em><strong>3.权限与用户之间的关系？</strong></em></p>
<p><em>在Linux系统中，针对文件定义了三种身份，分别是属主(owner)、属组(group)、其他人(others)，每一种身份又对应三种权限(rwx)，分别是可读(readable)、可写(writable)、可执行(excutable)。</em></p>
<p>*用户对文件资源，有三种角色ugo，当一个用户访问文件流程如下</p>
<ol>
<li>判断用户是否为文件所有者，如果是则按所有者的权限进行访问</li>
<li>判断用户是否为文件所有组成员，如果是则按组的权限进行访问</li>
<li>如果不是所有者，也不是该文件所属组，则按匿名权限进行访问*</li>
</ol>
<p><em><strong>4.权限中的rwx分别代表什么含义？</strong></em></p>
<p><em>当我们使用ls -l查看一个文件的详细属性时，能看到每个文件都有一个9位基本权限位，比如: <code>rwxr-xr-x</code>其中每三位字符为一组，分别表示属主权限位，属组权限位，匿名权限位。<br>linux中基本权限位则是使用这9位字符来表示，主要控制文件属主(User)、属组(Group)、其他用户(Other)</em></p>
<table>
<thead>
<tr>
<th>字母</th>
<th>含义</th>
<th>对应权限</th>
</tr>
</thead>
<tbody><tr>
<td>r（read）</td>
<td>读取权限</td>
<td>4</td>
</tr>
<tr>
<td>w（write）</td>
<td>写入权限</td>
<td>2</td>
</tr>
<tr>
<td>x（execute）</td>
<td>执行权限</td>
<td>1</td>
</tr>
<tr>
<td>-（没有权限）</td>
<td>没有权限</td>
<td>0</td>
</tr>
</tbody></table>
<p><em>PS: 如果权限位不可读、不可写、不可执行，则全部使用-作为占位符表示。</em></p>
<h1 id="2-权限设置示例"><a href="#2-权限设置示例" class="headerlink" title="2.权限设置示例"></a>2.权限设置示例</h1><p><em>文件示例: rwxrw-r– alice hr file1.txt<br> Q1: alice对file1文件拥有什么权限?<br> Q2: jack 对 file1.txt 文件有什么权限? 前提:jack 属于 hr 组<br> Q3: tom 对 file1.txt 文件有什么权限?</em></p>
<p><em><strong>1.为什么要设定权限，我们又如何修改一个文件的权限?</strong></em></p>
<p><em>Q1: 为什么要设定权限，可以赋于某个用户或组 – 能够以何种方式 – 访问某个文件<br>Q2: Linux下使用chmod命令来变更权限，root用户可以变更所有文件的权限，而普通用户仅能变更属于自己的文件。</em></p>
<p><em><strong>2.使用chmod设定权限示例</strong></em></p>
<p><em>方式一: ugo</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># touch file                    #创建文件</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=rwx file              #给所有人添加读写执行权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod a=-rwx file             #取消所有的权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod u=rwx,g=rw,o=- file     #属主读写执行，属组读写，其他人无权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod ug=rwx,o=r file         #属主属组读写执行，其他人读权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rwxrw-r-- 1 root root 0 Apr 13 03:29 file</span><br></pre></td></tr></table></figure>

<p><em>方式二、number</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项:  -R递归修改</span></span><br><span class="line">[root@bgx ~]<span class="comment"># touch file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 644 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 600 file</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll file</span></span><br><span class="line">-rw------- 1 root root 0 Apr 13 03:29 file</span><br><span class="line"></span><br><span class="line"><span class="comment">#针对目录设定权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 777 dir/    #修改目录允许所有人访问</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod -R 755 dir/ #修改目录及子目录权限</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d dir/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Apr 13 03:34 dir/</span><br></pre></td></tr></table></figure>

<p><em><strong>3.权限设置案例</strong></em></p>
<p><em>针对 hr 部门的访问目录/home/hr 设置权限，要求如下:<br>1.root 用户和 hr 组的员工可以读、写、执行<br>2.其他用户没有任何权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># groupadd hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr01 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># useradd hr02 -G hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chgrp hr /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chmod 770 /home/hr</span></span><br><span class="line">[root@bgx ~]<span class="comment"># ll -d /home/hr</span></span><br><span class="line">drwxrwx--- 2 root hr 6 Apr 13 03:26 /home/hr</span><br></pre></td></tr></table></figure>

<h1 id="3-权限设置案例"><a href="#3-权限设置案例" class="headerlink" title="3.权限设置案例"></a>3.权限设置案例</h1><p><em>在Linux中权限对文件和对目录的影响是有不同区别的。</em></p>
<table>
<thead>
<tr>
<th>权限</th>
<th>对文件的影响</th>
<th>对目录的影响</th>
</tr>
</thead>
<tbody><tr>
<td>读取权限（r）</td>
<td>具有读取\阅读文件内容权限</td>
<td>具有浏览目录及子目录</td>
</tr>
<tr>
<td>写入权限（w）</td>
<td>具有新增、修改文件内容的权限</td>
<td>具有增加和删除目录内文件</td>
</tr>
<tr>
<td>执行权限（x）</td>
<td>具有执行文件的权限</td>
<td>具有访问目录的内容(取决于目录中文件权限)</td>
</tr>
</tbody></table>
<p><em>文件权限实验案例:</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.新建文件，并添加内容至文件中，默认文件匿名用户仅有读权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;date&quot; &gt; filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll filename</span></span><br><span class="line">-rw-r--r-- 1 root root 5 Jan 24 08:24 filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.切换bgx普通用户</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># su - bgx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.对文件拥有读取的权限，但bgx用户对文件没有执行和删除的权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat  /root/filename</span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.使用root增加x执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+x /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--r-x 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.测试x权限是否真的能执行该文件</span></span><br><span class="line">[bgx@lucifer ~]$ /root/filename</span><br><span class="line">Wed Jan 24 08:28:34 EST 2018</span><br><span class="line"></span><br><span class="line"><span class="comment">#6.增加w执行权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod o+w /root/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll /root/filename</span></span><br><span class="line">-rw-r--rwx 1 root root 5 Jan 24 08:24 /root/filename</span><br><span class="line"></span><br><span class="line"><span class="comment">#7.测试执行权限</span></span><br><span class="line">[bgx@lucifer ~]$ vim /root/filename</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对文件的影响</em><br> <em>读取权限（r）具有读取\阅读文件内容权限<br> 1.只能使用查看类命令cat、head、tail、less、more</em></p>
<p><em>写入权限（w）具有新增、修改文件内容的权限<br>1.使用vim编辑会提示权限拒绝, 但可强制保存,会覆盖文件的所有内容<br>2.使用echo命令重定向的方式可以往文件内写入数据,&gt;&gt;可以进行追加<br>3.不能删除文件,因为删除文件看的不是文件的属性,需要看上级目录是否有w的权限</em></p>
<p><em>执行权限（x）具有执行文件的权限<br>1.执行权限什么用都没有<br>2.如果普通用户需要执行文件,需要配合r权限</em></p>
<p><strong>目录权限实验案例:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#示例1: 创建目录，并在该目录下创建文件，匿名用户对目录没有w权限，对文件有777权限 </span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir /dirname</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;test&quot; &gt;&gt; /dirname/filename</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限，能正常查看，但无法删除[奇怪]</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">rm: cannot remove ‘/dirname/filename’: Permission denied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 设置目录777权限，相当于匿名用户对目录有w权限，对文件没有任何权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 777 /dirname/</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chmod 000 /dirname/filename</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#普通用户验证权限</span></span><br><span class="line">[bgx@lucifer ~]$ cat /dirname/filename</span><br><span class="line">cat: /dirname/filename: Permission denied</span><br><span class="line">[bgx@lucifer ~]$ rm -f /dirname/filename</span><br><span class="line">[bgx@lucifer ~]$ touch /dirname/filename_2</span><br></pre></td></tr></table></figure>

<p><em>PS: 总结rwx对目录的影响</em></p>
<p><em>读取权限（r），如果目录只有r权限: 具有浏览目录及子目录权限<br>1.可以使用ls命令浏览目录及子目录， 但同时也会提示权限拒绝<br>2.使用ls -l命令浏览目录及子目录，文件属性会带问号，并且只能看到文件名<br>总结: 目录只有r权限，仅仅只能浏览内的文件名，无其他操作权限</em></p>
<p><em>写入权限（w），如果目录只有w权限: 具有增加、删除或修改目录内文件名权限(需要x权限配合)<br>PS: 如果目录有w权限, 可以在目录内创建文件, 删除文件(跟文件本身权限无关)<br>不能进入目录、不能复制目录、不能删除目录、不能移动目录</em></p>
<p><em>执行权限（x），如果目录只有x权限<br>1.只能进入目录<br>2.不能浏览、复制、移动、删除</em></p>
<p><em><strong>Linux权限总结与注意事项</strong></em></p>
<p><em>文件r权限,  只给用户查看,无其他操作<br>文件rw权限, 可以查看和编辑文件内容<br>文件rx权限, 允许查看和执行文件、但不能修改文件—–&gt;PASS<br>文件rwx权限, 能读,能写,能执行,但不能删除,因为删除需要看上级目录的权限有没有w—–&gt;PASS<br>目录rx权限, 允许浏览目录内文件以及子目录、并允许在目录内新建文件, 不允许创建、删除文件和目录<br>目录wx权限, 能进入目录,能删除内容,能写入内容,但就是无法使用ls cat这样的命令—–&gt;PASS<br>目录rw权限, 能看,能写,但无法进入目录—–&gt;PASS<br>PS: 文件的 x权限小心给予，目录的 w权限小心给予。<br>PS: 文件通常设定的权限是644,目录设定的权限是755<br>PS: 控制目录权限755, 如果有普通用户需要操作目录里面的文件，在来看文件的权限</em></p>
<h1 id="4-属主属组设置变更文件属主和属组的意义？"><a href="#4-属主属组设置变更文件属主和属组的意义？" class="headerlink" title="4.属主属组设置变更文件属主和属组的意义？"></a>4.属主属组设置<em>变更文件属主和属组的意义？</em></h1><p><em>变更文件属主和属组的意义？</em><br> <em>比如: 我现在手里有多套房，希望出售其中的A房进行变现，那么我会考虑将A房过户给金主，过户成功后A房就属于金主了，那么此时A房的拥有者就属于金主而不再属于我。</em></p>
<p><em>在Linux中如何变更一个文件或者一个资源的属主和属组呢，可以使用chown、chgrp命令实现。<br>chown能设置属主和属组，chgrp仅能设置属组。（所以用哪个你懂的）</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#chown 更改属主以及属组 -R：递归修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#准备环境，创建文件和目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># mkdir dir/test1 &amp;&amp; touch dir/file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例1: 修改所属主为bin</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown bin dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: 修改所属组为adm</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown .adm dir/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 递归修改目录及目录下的所有文件属主和属组</span></span><br><span class="line">[root@bgx ~]<span class="comment"># chown -R root.root dir/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件管理</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.文件管理概述 2.系统目录结构 3.文件路径定位 4.系统文件管理 5.系统文件属性 6.系统文件类型  7.系统链接文件</p>
<span id="more"></span>
<h1 id="1-文件管理概述"><a href="#1-文件管理概述" class="headerlink" title="1.文件管理概述"></a>1.文件管理概述</h1><p><em><strong>1.Bash Shell对文件进行管理</strong></em></p>
<p><em>谈到Linux文件管理，首先我们需要了解的就是，我们要对文件做些什么事情？<br> 其实无非就是对一个文件进行、创建、复制、移动、查看、编辑、压缩、查找、删除、等等<br> 例如: 当我们想修改系统的主机名称，是否应该知道文件在哪，才能去做对应的修改？</em></p>
<h1 id="2-系统目录结构"><a href="#2-系统目录结构" class="headerlink" title="2.系统目录结构"></a>2.系统目录结构</h1><p><em>几乎所有的计算机操作系统都是使用目录结构组织文件。具体来说就是在一个目录中存放子目录和文件, 而在子目录中又会进一步存放子目录和文件，以此类推形成一个树状的文件结构，由于其结构很像一棵树的分支, 所以该结构又被称为“目录树”。<br> Windows: 以多根的方式组织文件 C:\ D:<br> Linux:以单根的方式组织文件   /</em></p>
<p><em><strong>1.存放命令相关的目录</strong></em></p>
<p><em>/bin， 普通用户使用的命令 /bin/ls, /bin/date</em><br><em>/sbin，管理员使用的命令 /sbin/service</em></p>
<p><em><strong>2.存放用户相关数据的家目录</strong></em></p>
<p><em>/home，普通用户的家目录, 默认为/home/username<br>/root，超级管理员root的家目录, 普通用户无权操作</em></p>
<p><em><strong>3.系统文件目录</strong></em></p>
<p><em>/usr，相当于C:\Windows<br>/usr/local，软件安装的目录，相当于C:\Program<br>/usr/bin/，普通用户使用的应用程序(重要)<br>/usr/sbin，管理员使用的应用程序(重要)<br>/usr/lib，库文件Glibc 32bit<br>/usr/lib64，库文件Glibc 64bit</em></p>
<p><em><strong>4.启动目录</strong></em></p>
<p>/boot 存放的系统启动相关的文件，例如:kernel，grub(引导装载程序)*</p>
<p><em><strong>5.配置文件目录</strong></em></p>
<p><em>/etc，极其重要，后续所有服务的配置都在这个目录中<br>/etc/sysconfig/network-script/ifcfg-，网络配置文件<br>/etc/hostname，系统主机名配置文件<br>/etc/resolv.conf，dns客户端配置文件<br>/etc/hosts，本地域名解析配置文件</em></p>
<p><em><strong>6.可变的目录与临时目录</strong></em></p>
<p><em>/var，存放一些变化文件，比如/var/log/下的日志文件<br>/var/tmp，进程产生的临时文件<br>/tmp，系统临时目录(类似于公共厕所)</em></p>
<p><em><strong>7.设备目录文件</strong></em></p>
<p><em>/dev，存放设备文件，比如硬盘，硬盘分区，光驱，等等<br>/dev/null，黑洞设备，只进不出。类似于垃圾回收站<br>/dev/random，生成随机数的设备<br>/dev/zero，能远远不断的产生数据，类似于取款机，随时随地取钱</em></p>
<p><em><strong>8.虚拟的文件系统(如对应的进程停止则/proc下对应目录则会被删除)</strong></em></p>
<p><em>/proc，反映系统当前进程的实时状态<br>PS：类似于小汽车的仪表板，能够看到汽车是否有故障，或者是否缺油了。</em></p>
<p><em><strong>9.PS: 在Linux7系统中, /bin, /sbin, /lib, /lib64都以软链接的形式链接到/usr/目录下</strong></em></p>
<p><em>/bin  –&gt; /usr/bin<br>/sbin –&gt; /usr/sbin<br>lib -&gt; usr/lib<br>lib64 -&gt; usr/lib64</em></p>
<h1 id="3-文件路径定位"><a href="#3-文件路径定位" class="headerlink" title="3.文件路径定位"></a>3.文件路径定位</h1><p><em>在我们开始操作文件前，首先需要对文件进行定位，比如:<br>你要在哪创建什么文件? 你要将文件复制到什么地方? 或者你要删除的文件在什么地方?<br>那什么是定位: 比如/etc/hostname，整个文件中包含文件名称以及文件所在的位置，我们将这个叫做路径，那么路径就是对文件进行定位的一种方式.</em></p>
<p><em><strong>1.每个目录下都有一个.和..的目录是干啥的?</strong></em><br> <em>一个点代表当的是当前目录, 两个点代表的是当前目录的上层目录。<br>假设当前目录在<code>/usr/</code>下, 那么它的上层(/)目录用<code>../</code>表示, 而<code>/usr/</code>的下层(local)目录则用<code>./local</code>表示。</em></p>
<p><em><strong>2.那什么是绝对路径，什么又是相对路径呢?</strong></em><br> <em>绝对路径: 只要从/开始的路径，比如/home/alice/file<br>相对路径: 相对于当前目录来说，比如 a.txt ./a.txt ../bob/a.mp3 [加入: 此时在目录/home/alice]<br>小结: 所谓的(.)和(..)目录实际上属于相对路径的一种表示形式。</em></p>
<p><em><strong>3.绝对路径与相对路径示例</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># useradd alice</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch /home/alice/file1</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~/file2</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ~alice/file3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对路径</span></span><br><span class="line">[root@bgx /]<span class="comment"># mkdir abc</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch ../file3</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch file4</span></span><br><span class="line">[root@bgx /]<span class="comment"># touch abc/file5</span></span><br></pre></td></tr></table></figure>

<p><em>cd改变目录，常见的使用方法</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>改变目录，常见的使用方法<span class="comment"># cd 绝对路径 cd /etc/hostname</span></span><br><span class="line"><span class="comment"># cd 相对路径 cd test/abc cd . cd ..</span></span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="comment"># cd      #切换目录，例: cd /etc</span></span><br><span class="line"><span class="comment"># cd -    #切换回上一次所在的目录</span></span><br><span class="line"><span class="comment"># cd ~    #切换回当前用户的家目录,注意:root和普通用户是否有所不同吗？</span></span><br><span class="line"><span class="comment"># cd .    #代表当前目录，一般在拷贝、移动等情况下使用 cp /etc/hostname ./</span></span><br><span class="line"><span class="comment"># cd ..   #切换回当前目录的上级目录</span></span><br></pre></td></tr></table></figure>

<h1 id="4-系统文件管理"><a href="#4-系统文件管理" class="headerlink" title="4.系统文件管理"></a>4.系统文件管理</h1><h2 id="1-文件管理之-创建-复制-移动-删除"><a href="#1-文件管理之-创建-复制-移动-删除" class="headerlink" title="1.文件管理之: 创建/复制/移动/删除"></a><em><strong>1.文件管理之: 创建/复制/移动/删除</strong></em></h2><p><em><strong>—————————————-创建—————————————-</strong></em></p>
<p><em>1.文件创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># touch file                    #无则创建,有则修改时间</span></span><br><span class="line"><span class="comment"># touch file2 file3</span></span><br><span class="line"><span class="comment"># touch /home/od/file4 file5</span></span><br><span class="line"><span class="comment"># touch file&#123;a,b,c&#125;             #&#123;&#125;集合，等价 touch a b c</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch file&#123;a..z&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>2.目录创建命令touch</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项：-v 显示详细信息  -p 递归创建目录</span></span><br><span class="line"><span class="comment"># mkdir dir1</span></span><br><span class="line"><span class="comment"># mkdir /home/od/dir1 /home/od/dir2</span></span><br><span class="line"><span class="comment"># mkdir -v /home/od/&#123;dir3,dir4&#125; </span></span><br><span class="line"><span class="comment"># mkdir -pv /home/od/dir5/dir6</span></span><br><span class="line"><span class="comment"># mkdir -pv /home/&#123;od/&#123;diu,but&#125;,boy&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>3.以树状显示目录结构命令tree</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项: -L: 显示目录树的层级</span></span><br><span class="line"><span class="comment"># tree /home/od/    #显示当前目录下的结构</span></span><br><span class="line">/home/od/</span><br><span class="line">├── but</span><br><span class="line">├── dir1</span><br><span class="line">├── dir2</span><br><span class="line">├── dir3</span><br><span class="line">├── dir4</span><br><span class="line">├── dir5</span><br><span class="line">│   └── dir6</span><br><span class="line">└── diu</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cp复制—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项： -v:详细显示命令执行的操作 -r: 递归处理目录与子目录 -p: 保留源文件或目录的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cp file /tmp/file_copy</span></span><br><span class="line"><span class="comment"># cp name /tmp/name         #不修改名称</span></span><br><span class="line"><span class="comment"># cp file /tmp/             #不修改名称</span></span><br><span class="line"><span class="comment"># cp -p file /tmp/file_p    #-p保持原文件或目录的属性</span></span><br><span class="line"><span class="comment"># cp -r  /etc/ /tmp/        #复制目录需要使用-r参数, 递归复制</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts /etc/hostname /tmp  #拷贝多个文件至一个目录</span></span><br><span class="line"><span class="comment"># cp -rv /etc/&#123;hosts,hosts.bak&#125;</span></span><br><span class="line"><span class="comment"># cp -rv /etc/hosts&#123;,-org&#125;</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-mv移动—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mv file file1             #原地移动算改名</span></span><br><span class="line"><span class="comment"># mv file1 /tmp/            #移动文件至tmp目录</span></span><br><span class="line"><span class="comment"># mv /tmp/file1 ./          #移动tmp目录的文件至当前目录</span></span><br><span class="line"><span class="comment"># mv dir/ /tmp/             #移动目录至/tmp目录下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv file1 file2 file3 /opt/    #移动多个文件或至同一个目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir dir&#123;1..3&#125;</span></span><br><span class="line"><span class="comment"># mv dir1/ dir2/ dir3/ /opt     #移动多个目录至同一个目录</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rm删除—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项：-r: 递归 -f: 强制删除 -v: 详细过程</span></span><br><span class="line"><span class="comment"># rm  file.txt      #删除文件, 默认rm存在alias别名，rm -i所以会提醒是否删除文件</span></span><br><span class="line"><span class="comment"># rm -f file.txt    #删除文件, 不提醒</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment"># rm -r dir/        #递归删除目录，会提示</span></span><br><span class="line"><span class="comment"># rm -rf dir/       #强制删除目录,不提醒(慎用)</span></span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#1.rm删除示例</span></span><br><span class="line"><span class="comment"># mkdir /home/dir10</span></span><br><span class="line"><span class="comment"># touch /home/dir10/&#123;file2,file3,.file4&#125;</span></span><br><span class="line"><span class="comment"># rm -f /home/dir10/*  //不包括隐藏文件 </span></span><br><span class="line"><span class="comment"># ls /home/dir10/ -a</span></span><br><span class="line">. .. .file4</span><br><span class="line">--------------------------------</span><br><span class="line"><span class="comment">#2.rm删除示例2</span></span><br><span class="line"><span class="comment"># touch file&#123;1..10&#125;</span></span><br><span class="line"><span class="comment"># touch &#123;1..10&#125;.pdf</span></span><br><span class="line"><span class="comment"># rm -rf file* </span></span><br><span class="line"><span class="comment"># rm -rf *.pdf</span></span><br></pre></td></tr></table></figure>

<h2 id="2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…"><a href="#2-文件管理之：查看文件内容-cat-tac-less-more-head-tail-tailf-grep-…" class="headerlink" title="2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)"></a><em><strong>2.文件管理之：查看文件内容(cat tac less more head tail tailf grep …)</strong></em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#------cat</span></span><br><span class="line"><span class="comment"># cp /etc/passwd ./pass</span></span><br><span class="line"><span class="comment"># cat pass      #正常查看文件方式</span></span><br><span class="line"><span class="comment"># cat -n pass   #-n显示文件有多少行</span></span><br><span class="line"><span class="comment"># cat -A pass   #查看文件的特殊符号,比如文件中存在tab键</span></span><br><span class="line"><span class="comment"># tac pass      #倒序查看文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------less、more</span></span><br><span class="line"><span class="comment"># less /etc/services    #使用光标上下翻动，空格进行翻页，q退出</span></span><br><span class="line"><span class="comment"># more /etc/services    #使用回车上下翻动，空格进行翻页，q退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------head</span></span><br><span class="line"><span class="comment"># head pass     #查看头部内容，默认前十行</span></span><br><span class="line"><span class="comment"># head -n5 pass #查看头部5行，使用-n指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------tail</span></span><br><span class="line"><span class="comment"># tail pass</span></span><br><span class="line"><span class="comment"># tail -20 /var/log/secure</span></span><br><span class="line"><span class="comment"># tail -f /var/log/messages #-f查看文件尾部的变化</span></span><br><span class="line"><span class="comment"># tailf /var/log/messages   #查看文件尾部的变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------grep过滤文件内容</span></span><br><span class="line"><span class="comment"># grep &quot;^root&quot; pass     #匹配以root开头的行</span></span><br><span class="line"><span class="comment"># grep &quot;bash$&quot; pass     #匹配以bash结尾的行</span></span><br><span class="line"><span class="comment"># grep -i &quot;ftp&quot; pass    #忽略大小写匹配</span></span><br><span class="line"><span class="comment"># grep  -Ei &quot;sync$|ftp&quot; pass    #匹配文件中包含sync结尾或ftp字符串</span></span><br><span class="line"><span class="comment"># grep -n -A 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的下2行</span></span><br><span class="line"><span class="comment"># grep -n -B 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上2行</span></span><br><span class="line"><span class="comment"># grep -n -C 2 &quot;Failed&quot; /var/log/secure #匹配/var/log/secure文件中Failed字符串,并打印它的上下2行</span></span><br></pre></td></tr></table></figure>

<h2 id="3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz"><a href="#3-文件管理之：联网下载文件-wget、curl-、文件上传与下载-rz、sz" class="headerlink" title="3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)"></a><em><strong>3.文件管理之：联网下载文件(wget、curl)、文件上传与下载(rz、sz)</strong></em></h2><p><em><strong>—————————————-wget、curl联网下载文件—————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: -O: 指定下载地址</span></span><br><span class="line"><span class="comment"># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#选项: -o: 指定下载地址</span></span><br><span class="line"><span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-rzsz上传下载文件—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install lrzsz -y  #不安装软件则无法执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rz            #只能上传文件文件上传</span></span><br><span class="line"><span class="comment"># sz /path/file #只能下载文件</span></span><br></pre></td></tr></table></figure>

<h2 id="4-文件管理之：文件或命令查找-locate、which、whereis、find"><a href="#4-文件管理之：文件或命令查找-locate、which、whereis、find" class="headerlink" title="4.文件管理之：文件或命令查找(locate、which、whereis、find)"></a><em><strong>4.文件管理之：文件或命令查找(locate、which、whereis、find)</strong></em></h2><p><em><strong>—————————————-文件查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># locate /etc/sh       #搜索etc目录下所有以sh开头的文件</span></span><br><span class="line"><span class="comment"># locate -i /etc/sh    #搜索etc目录下，所有以sh开头的文件，忽略大小写</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-命令查找—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which ls  #查找ls命令的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># whereis ls       //查找命令的路径、帮助手册、等</span></span><br><span class="line"><span class="comment"># whereis -b ls    //仅显示命令所在的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># type -a ls        #查看命令的绝对路径(包括别名)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、"><a href="#5-文件管理之：字符处理命令-sort、uniq、cut、sed、awk、wc、" class="headerlink" title="5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)"></a><em><strong>5.文件管理之：字符处理命令(sort、uniq、cut、sed、awk、wc、)</strong></em></h2><p><em><strong>—————————————-sort排序—————————————-</strong></em></p>
<p><em>在有些情况下，需要对应一个无序的文本文件进行数据的排序，这时就需要使用sort进行排序了。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sort [OPTION]... [FILE]...</span><br><span class="line"><span class="comment"># -r：倒序 -n：按数字排序 -t：指定分隔符(默认空格) -k：指定第几列, 指定几列几字符（指定1,1  3.1,3.3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">d:1</span><br><span class="line">f:11</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort file.txt</span></span><br><span class="line">a:4</span><br><span class="line">b:3</span><br><span class="line">c:2</span><br><span class="line">d:1</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line">d:1</span><br><span class="line">f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line">d:1</span><br><span class="line">c:2</span><br><span class="line">b:3</span><br><span class="line">a:4</span><br><span class="line">e:5</span><br><span class="line">f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例，下载文件http://fj.lucifer.com/public/ip.txt，对该文件进行排序</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-uniq去重—————————————</strong></em></p>
<p><em>如果文件中有多行完全相同的内容，当前是希望能删除重复的行，同时还可以统计出完全相同的行出现的总次数, 那么就可以使用<code>uniq</code>命令解决这个问题(但是必须配合<code>sort</code>使用)。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">uniq [OPTION]... [INPUT [OUTPUT]]</span><br><span class="line"><span class="comment">#选项：-c  计算重复的行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建一个file.txt文件:</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt</span></span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">123</span><br><span class="line"><span class="comment">#2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort</span></span><br><span class="line">123</span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line">123</span><br><span class="line">abc</span><br><span class="line"><span class="comment">#4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">      2 123</span><br><span class="line">      2 abc</span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-cut截取字段—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cut OPTION... [FILE]...</span><br><span class="line"><span class="comment">#选项：-d 指定分隔符 -f 数字,取第几列 –f3,6三列和6列 -c 按字符取(空格也算)</span></span><br><span class="line"><span class="comment">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure>

<p><em><strong>—————————————-wc统计行号—————————————-</strong></em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wc [OPTION]... [FILE]...</span><br><span class="line"><span class="comment">#选项：-l显示文件行数 -c显示文件字节 -w显示文件单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure>

<h1 id="5-系统文件属性"><a href="#5-系统文件属性" class="headerlink" title="5.系统文件属性"></a>5.系统文件属性</h1><p><em>当我们使用ls -l列目录下所有文件时，通常会以长格式的方式显示，其实长格式显示就是我们Windows下看到的文件详细信息，我们也将其称为文件属性，那整个文件的属性分为十列。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ls -l ks.cfg</span></span><br><span class="line">-rw-------. 1 root root 4434 May 30 13:58 ks.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">-rw-------. ①:第一个字符是文件类型，其他则是权限</span><br><span class="line">1           ②:硬链接次数</span><br><span class="line">root        ③:文件属于哪个用户</span><br><span class="line">root        ④:文件属于哪个组</span><br><span class="line">4434        ⑤:文件大小</span><br><span class="line">May30 13:58 ⑥⑦⑧:最新修改的时间与日期</span><br><span class="line">ks.cfg      ⑨:文件或目录名称</span><br></pre></td></tr></table></figure>

<h1 id="6-系统文件类型"><a href="#6-系统文件类型" class="headerlink" title="6.系统文件类型"></a>6.系统文件类型</h1><p><em>1.通常我们使用颜色或者后缀名称来区分文件类型，但很多时候不是很准确，所以我们可以通过ls -l以长格式显示一个文件的属性，通过第一列的第一个字符来近一步的判断文件具体的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># ll -d /etc/hosts /tmp /bin/ls  /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client</span></span><br><span class="line">-rwxr-xr-x.  1 root root 117656 Jun 30  2016 /bin/ls</span><br><span class="line">srw-rw-rw-.  1 root root      0 Jan 20 10:35 /dev/<span class="built_in">log</span></span><br><span class="line">brw-rw----.  1 root disk   8, 0 Jan 20 10:36 /dev/sda</span><br><span class="line">crw--w----.  1 root tty    4, 1 Jan 20 10:36 /dev/tty1</span><br><span class="line">lrwxrwxrwx.  1 root root     22 Jan 13 11:31 /etc/grub2.cfg -&gt; ../boot/grub2/grub.cfg</span><br><span class="line">-rw-r--r--.  1 root root    199 Jan 20 11:03 /etc/hosts</span><br><span class="line">prw-------.  1 root root      0 Jan 20 10:36 /run/dmeventd-client</span><br><span class="line">drwxrwxrwt. 61 root root   8192 Jan 21 13:01 /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment">#说明</span></span><br><span class="line">-   <span class="comment">#普通文件(文本, 二进制, 压缩, 图片, 日志等) </span></span><br><span class="line">d   <span class="comment">#目录文件</span></span><br><span class="line">b   <span class="comment">#设备文件(块设备)存储设备硬盘 /dev/sda1, /dev/sda2</span></span><br><span class="line">c   <span class="comment">#设备文件(字符设备)，终端 /dev/tty1, /dev/zero</span></span><br><span class="line">s   <span class="comment">#套接字文件, 进程间通信(socket)</span></span><br><span class="line">p   <span class="comment">#管道文件</span></span><br><span class="line">l   <span class="comment">#链接文件</span></span><br></pre></td></tr></table></figure>

<p><em>2.但有些情况下，我们无法通过ls -l文件的类型，比如: 一个文件，它可能是普通文件、也可能是压缩文件、或者是命令文件等，那么此时就需要使用file来更加精准的判断这个文件的类型。</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># file /etc/hosts</span></span><br><span class="line">/etc/hosts: ASCII text</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /bin/ls</span></span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=aa7ff68f13de25936a098016243ce57c3c982e06, stripped</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/sda</span></span><br><span class="line">/dev/sda: block special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /dev/tty1</span></span><br><span class="line">/dev/tty1: character special</span><br><span class="line"></span><br><span class="line">[root@lucifer ~]<span class="comment"># file /etc/grub2.cfg</span></span><br><span class="line">/etc/grub2.cfg: broken symbolic link to `../boot/grub2/grub.cfg<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /home</span></span><br><span class="line"><span class="string">/home: directory</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# file /run/dmeventd-client</span></span><br><span class="line"><span class="string">/run/dmeventd-client: fifo (named pipe)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[root@lucifer ~]# ll but</span></span><br><span class="line"><span class="string">-rw-r--r-- 1 root root 42125 Apr  1 12:26 but</span></span><br><span class="line"><span class="string">[root@lucifer ~]# file but</span></span><br><span class="line"><span class="string">but: Zip archive data, at least v1.0 to extract</span></span><br></pre></td></tr></table></figure>

<p><em>PS: Linux文件扩展名不代表任何含义，仅为了我们能更好的识别该文件是什么类型。</em></p>
<h1 id="7-系统链接文件"><a href="#7-系统链接文件" class="headerlink" title="7.系统链接文件"></a>7.系统链接文件</h1><p><em>文件有文件名与数据，在Linux上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。<br>用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方，我们将其称为Block<br>元数据，即文件的附加属性，如文件大小、创建时间、所有者等信息。我们称其为Inode<br>在Linux中，inode是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）<br>文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</em></p>
<h2 id="1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link"><a href="#1-Linux-系统引入了两种链接：硬链接-hard-link-与软链接（又称符号链接，即-soft-link-或-symbolic-link" class="headerlink" title="1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)"></a><em><strong>1.Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link)</strong></em></h2><h3 id="1-什么是软链接"><a href="#1-什么是软链接" class="headerlink" title="1.什么是软链接"></a><em><strong>1.什么是软链接</strong></em></h3><p><em>软链接相当于Windows的快捷方式，软链接文件会将inode指向源文件的block，当我们访问这个软链接文件时，其实访问的是源文件本身。那么当我们对一个文件创建多个软链接，其实就是多个inode指向同一个block。当我们删除软链接文件时，其实只是删除了一个inode指向，并不会对源文件源文件造成影响，但如果删除的是源文件则会造成所有软链接文件失效。</em></p>
<h3 id="2-什么是硬链接"><a href="#2-什么是硬链接" class="headerlink" title="2.什么是硬链接"></a><em><strong>2.什么是硬链接</strong></em></h3><p><em>若一个inode号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名，如下图hard link 就是 file 的一个别名，他们有共同的 inode。</em></p>
<p><em>软链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件软链接示例</span></span><br><span class="line">touch /root/file</span><br><span class="line">ln -s /root/file /tmp/file_bak</span><br><span class="line">ll /tmp/file_bak  //root下file链接到/tmp下并重命名为file_bak</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">#目录软链接示例</span></span><br><span class="line">mkdir /soft/nginx1.1 -p</span><br><span class="line">ln -s /soft/nginx1.1/ /soft/nginx</span><br><span class="line">ll /soft/nginx   //查看链接指向</span><br><span class="line"></span><br><span class="line"><span class="comment">#软链接使用场景</span></span><br><span class="line">1.软件升级</span><br><span class="line">2.企业代码发布 </span><br><span class="line">3.不方便目录移动</span><br></pre></td></tr></table></figure>

<p><em>硬链接实践</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">4.硬链接实践<span class="comment">#文件硬链接示例</span></span><br><span class="line">ln  /root/file /tmp/file_hard</span><br><span class="line">ll /tmp/file_hard</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS：目录不能创建硬链接，硬链接文件可以用rm命令删除</span></span><br></pre></td></tr></table></figure>

<h3 id="3-硬链接与软链接区别"><a href="#3-硬链接与软链接区别" class="headerlink" title="3.硬链接与软链接区别"></a><em>3.硬链接与软链接区别</em></h3><p> <em>1)ln命令创建硬链接，ln -s命令创建软链接。<br> 2)目录不能创建硬链接，并且硬链接不可以跨越分区系统。<br> 3)目录软链接特别常用,并且软链接支持跨越分区系统。<br> 4)硬链接文件与源文件的inode相同，软链接文件与源文件inode不同。<br> 5)删除软链接文件，对源文件及硬链接文件无任何影响。<br> 6)删除文件的硬链接文件，对源文件及链接文件无任何影响。<br> 7)删除链接文件的源文件，对硬链接无影响，会导致软链接失效。<br> 8)删除源文件及其硬链接文件，整个文件会被真正的删除。</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件编辑(vim)</title>
    <url>/2021/07/28/Linux%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91%EF%BC%88vim%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>
<p>1.VIM基本概述 2.VIM模式使用 3.VIM扩展知识 4.VIM练习示例</p>
<span id="more"></span>
<h1 id="1-vim基本概述"><a href="#1-vim基本概述" class="headerlink" title="1.vim基本概述"></a>1.vim基本概述</h1><p><em><strong>1.什么是vim</strong></em></p>
<p><em>vi和vim是Linux下的一个文本编辑工具。(可以理解为windows的记事本，或word文档)</em></p>
<p><em><strong>2.为什么要使用VIM?</strong></em></p>
<p><em>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</em></p>
<p><em><strong>3.VI与VIM有什么区别?</strong></em></p>
<p><em>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于window</em>s<em>系统下的文本编辑软件“记事本”与”notepad++”的区别)</em><br>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y安装*</p>
<p><em><strong>4.如何使用VIM编辑器?</strong></em></p>
<p><em>在使用VIM之前，我们需要先介绍下VIM的三种模式: 普通模式、编辑模式、命令模式，每种模式分别支持多种不同的快捷键，要想高效率地操作文本，那就必须先搞清这三种模式的操作区别以及模式之间的切换方法。</em></p>
<p><em><strong>5.VIM模式三种模式介绍</strong></em></p>
<p><em>1.普通模式: 主要是控制光标移动，可对文本进行复制、粘贴、删除等工作。<br> 使用vim filename 编辑一个文件时，一进入该文件就是普通模式了。<br> 在这个模式下，可以进行光标移动、复制、删除、粘贴操作。</em></p>
<p><em>2.编辑模式: 主要进行文本内容编辑和修改<br> 从普通模式进入编辑模式，只需你按一个键即可（i, I, a, A, o, O）<br> 当进入编辑模式时，会在屏幕的最下一行会出现 “INSERT”标记<br> 从编辑模式回到普通模式只需要按键盘左上方的 ESC 键即可。</em></p>
<p><em>3.末行模式: 主要用于保存或退出文本。<br> 在普通模式下，输入 “:” 或者 “/“ 即可进入命令模式。<br> 在命令该模式下，可进行的操作有，显示行号、搜索、替换、保存、退出。</em></p>
<p><em>小结: vim编辑打开文件整体流程如下:<br> 1.默认打开文件处于普通模式<br> 2.从普通模式切换至编辑模式需要使用a、i、o<br> 3.编辑模式修改完毕后需要先使用ECS返回普通模式<br> 4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br> PS: 在vim中，无法直接从编辑模式切换到命令模式。</em></p>
<h1 id="2-VIM模式使用"><a href="#2-VIM模式使用" class="headerlink" title="2.VIM模式使用"></a>2.VIM模式使用</h1><h2 id="1-普通模式"><a href="#1-普通模式" class="headerlink" title="1.普通模式"></a><em>1.普通模式</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G       <span class="comment">#光标跳转至末端</span></span><br><span class="line">gg      <span class="comment">#光标跳转至顶端</span></span><br><span class="line">Ngg     <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$       <span class="comment">#光标跳转至当前光标所在行的尾部</span></span><br><span class="line">^|0     <span class="comment">#光标跳转至当前光标所在行的首部</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容较多</span></span><br><span class="line">ctrl+f  <span class="comment">#往下翻页(行比较多)</span></span><br><span class="line">ctrl+b  <span class="comment">#往上翻页</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.复制与粘贴</span></span><br><span class="line">yy      <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">5yy     <span class="comment">#复制当前光标以及光标向下4行</span></span><br><span class="line"> </span><br><span class="line">p(小写)   <span class="comment">#粘贴至当前光标下一行   </span></span><br><span class="line">P(大写)   <span class="comment">#粘贴至当前光标上一行</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.删除、剪贴、撤销  </span></span><br><span class="line">dd      <span class="comment">#删除当前光标所在的行   </span></span><br><span class="line">4dd     <span class="comment">#删除当前光标所在的行以及往下的3行</span></span><br><span class="line">dG      <span class="comment">#删除当前光标以后的所有行</span></span><br><span class="line">D       <span class="comment">#删除当前光标及光标以后的内容  </span></span><br><span class="line">x       <span class="comment">#删除当前光标标记往后的字符</span></span><br><span class="line">X       <span class="comment">#删除当前光标标记往前的字符</span></span><br><span class="line">dd &amp; p  <span class="comment">#剪贴、先删除dd(number dd)，后粘贴p</span></span><br><span class="line">u       <span class="comment">#撤销上一次的操作</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.替换</span></span><br><span class="line">r       <span class="comment">#替换当前光标标记的单个字符</span></span><br><span class="line">R       <span class="comment">#进入REPLACE模式, 连续替换，ESC结束</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编辑模式-从普通模式进入到编辑模式"><a href="#2-编辑模式-从普通模式进入到编辑模式" class="headerlink" title="2.编辑模式(从普通模式进入到编辑模式)"></a><em>2.编辑模式(从普通模式进入到编辑模式)</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">i   <span class="comment">#进入编辑模式，光标不做任何操作</span></span><br><span class="line">a   <span class="comment">#进入编辑模式，将当前光标往后一位</span></span><br><span class="line">o   <span class="comment">#进入编辑模式，并在当前光标下添加一行空白内容</span></span><br><span class="line">-------------------------------------------</span><br><span class="line">I   <span class="comment">#进入编辑模式，并且光标会跳转至本行的头部</span></span><br><span class="line">A   <span class="comment">#进入编辑模式，将光标移动至本行的尾部</span></span><br><span class="line">O   <span class="comment">#进入编辑模式，并在当前光标上添加一行空白内容</span></span><br></pre></td></tr></table></figure>

<h2 id="3-命令模式，主要用于搜索-保存-退出文件。"><a href="#3-命令模式，主要用于搜索-保存-退出文件。" class="headerlink" title="3.命令模式，主要用于搜索, 保存, 退出文件。"></a><em>3.命令模式，主要用于搜索, 保存, 退出文件。</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.文件保存与退出</span></span><br><span class="line">:w      保存当前状态</span><br><span class="line">:w!     强制保存当前状态</span><br><span class="line">:q      退出当前文档(文档必须保存才能退出)</span><br><span class="line">:q!     强制退出文档不会修改当前内容</span><br><span class="line">:wq     先保存，在退出</span><br><span class="line">:wq!    强制保存并退出</span><br><span class="line">:x      先保存，在退出</span><br><span class="line">ZZ      保存退出, shfit+zz</span><br><span class="line">:number 跳转至对应的行号</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#2.文件内容查找</span></span><br><span class="line">/string <span class="comment">#需要搜索的内容（查找）</span></span><br><span class="line">n       <span class="comment">#按搜索到的内容依次往下进行查找</span></span><br><span class="line">N       <span class="comment">#按搜索到的内容依次往上进行查找</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#3.文件内容替换</span></span><br><span class="line">:1,5s<span class="comment">#sbin#test#g   #替换1-5行中包含sbin的内容为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#g     #替换整个文本文件中包含sbin的替换为test</span></span><br><span class="line">:%s<span class="comment">#sbin#test#gc    #替换内容时时提示是否需要替换</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#4.文件内容另存</span></span><br><span class="line">:w /root/test.txt  <span class="comment">#将所有内容另存为/root/test.txt文件中</span></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="comment">#5.文件内容读入</span></span><br><span class="line">:r  /etc/hosts  <span class="comment">#读入/etc/hosts文件至当前光标下面</span></span><br><span class="line">:5r /etc/hosts  <span class="comment">#指定插入/etc/hosts文件至当前文件的第五行下面</span></span><br></pre></td></tr></table></figure>

<h2 id="4-视图模式-从普通模式进入视图模式-，主要进行批量操作"><a href="#4-视图模式-从普通模式进入视图模式-，主要进行批量操作" class="headerlink" title="4.视图模式(从普通模式进入视图模式)，主要进行批量操作"></a><em>4.视图模式(从普通模式进入视图模式)，主要进行批量操作</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按<span class="built_in">shift</span>+i进入编辑模式,输入<span class="comment">#,结束按ESC键</span></span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="built_in">shift</span>+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>进入可视块模式，选中需要注释的行</span></figcaption><table><tr><td class="code"><pre><span class="line">ctrl+v  进入可视块模式，选中需要注释的行</span><br><span class="line">    1.插入:按shift+i进入编辑模式,输入#,结束按ESC键</span><br><span class="line">    2.删除:选中内容后，按x或者d键删除</span><br><span class="line">    3.替换:选中需要替换的内容, 按下r键,然后输入替换后的内容</span><br><span class="line">-------------------------------------------</span><br><span class="line">shift+v 进入可视行模式，选中整行内容</span><br><span class="line">    1.复制:选中行内容后按y键及可复制。</span><br><span class="line">    2.删除:选中行内容后按d键删除。</span><br></pre></td></tr></table></figure>

<h1 id="3-VIM扩展知识"><a href="#3-VIM扩展知识" class="headerlink" title="3.VIM扩展知识"></a>3.VIM扩展知识</h1><h2 id="1-环境变量临时生效"><a href="#1-环境变量临时生效" class="headerlink" title="1.环境变量临时生效"></a><em>1.环境变量临时生效</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">set</span> nu             <span class="comment">#显示行号</span></span><br><span class="line">:<span class="built_in">set</span> ic             <span class="comment">#忽略大小写, 在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai             <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list           <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line">:<span class="built_in">set</span> no[nu|ic|ai…]  <span class="comment">#取消临时设定的变量</span></span><br></pre></td></tr></table></figure>

<h2 id="2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量"><a href="#2-环境变量永久生效。-vimrc-个人环境变量-优先级高-etc-vimrc-全局环境变量" class="headerlink" title="2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量"></a><em>2.环境变量永久生效。~/.vimrc 个人环境变量(优先级高) /etc/vimrc  全局环境变量</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim  ~/.vimrc #当下次再打开文件自动显示行号并忽略大小写</span></span><br><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果个人vim环境没有配置, 则使用全局vim环境变量配置。</span></span><br><span class="line"><span class="comment">#如果个人vim环境和全局环境变量产生冲突, 优先使用个人vim环境变量。</span></span><br></pre></td></tr></table></figure>

<h2 id="3-如何同时编辑多个文件"><a href="#3-如何同时编辑多个文件" class="headerlink" title="3.如何同时编辑多个文件"></a><em>3.如何同时编辑多个文件</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim -o file1 file2  <span class="comment">#水平分割</span></span><br><span class="line">vim -O file1 file2  <span class="comment">#垂直分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ctrl+ww 文件间切换</span></span><br></pre></td></tr></table></figure>

<h2 id="4-相同文件之间差异对比，通常用于对比修改前后差异"><a href="#4-相同文件之间差异对比，通常用于对比修改前后差异" class="headerlink" title="4.相同文件之间差异对比，通常用于对比修改前后差异"></a><em>4.相同文件之间差异对比，通常用于对比修改前后差异</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># diff      #文件对比   </span></span><br><span class="line"><span class="comment"># vimdiff   #以vim方式打开两个文件对比，高亮显示不同的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后"><a href="#5-如果VIM非正常退出-（ctrl-z）挂起或强制退出终端没关闭VIM后" class="headerlink" title="5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后"></a><em>5.如果VIM非正常退出 （ctrl+z）挂起或强制退出终端没关闭VIM后</em></h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#假设打开filename文件被以外关闭，需要删除同文件名的.swp文件即可解决</span></span><br><span class="line"><span class="comment"># rm -f .filename.swp</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>文件 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux特殊权限</title>
    <url>/2021/08/05/Linux%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.特殊权限概述  2.特殊权限SUID  3.特殊权限SGID  4.特殊权限SBIT  5.权限属性chattr  6.进程掩码umask</p>
<span id="more"></span>

<h1 id="1-特殊权限概述"><a href="#1-特殊权限概述" class="headerlink" title="1.特殊权限概述"></a>1.特殊权限概述</h1><p><em>前面我们已经学习过 r（读）、w（写）、 x（执行）这三种普通权限，但是我们在査询系统文件权限时会发现出现了一些其他权限字母，比如：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /usr/bin/passwd</span></span><br><span class="line">-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p><em>在属主本来应该是 x（执行）权限的位置出现了一个小写s，这是什么权限？我们把这种权限称作 SetUID 权限，也叫作 SUID 的特殊权限。这种权限有什么作用呢？或者说能干啥？别急，先往下看….</em></p>
<h1 id="2-特殊权限SUID"><a href="#2-特殊权限SUID" class="headerlink" title="2.特殊权限SUID"></a>2.特殊权限SUID</h1><p><em><strong>1.问题抛出</strong></em><br> <em>在 Linux 系统中，每个普通用户都可以更改自己的密码，这是合理的设置。问题是，普通用户的信息保存在 /etc/passwd  文件中，用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己的密码时修改了 /etc/shadow  文件中的加密密码，但是文件权限显示，普通用户对这两个文件其实都是没有写权限的，那为什么普通用户可以修改自己的权限呢？……(难道学了个假的权限)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx ~]<span class="comment"># ll /etc/passwd</span></span><br><span class="line">-rw-r--r-- 1 root root 6209 Apr 13 03:26 /etc/passwd</span><br><span class="line">[root@bgx ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">---------- 1 root root 11409 Apr 13 03:26 /etc/shadow</span><br></pre></td></tr></table></figure>

<p><em><strong>2.解决方案</strong></em></p>
<p><em>其实，普通用户可以修改自己的密码在于 passwd 命令。该命令拥有特殊权限 SetUID，也就是在属主的权限位的执行权限上是 s。可以这样来理解它：当一个具有执行权限的文件设置 SetUID 权限后，用户在执行这个文件时将以文件所有者的身份来执行。</em></p>
<p><em>PS: 当普通用户使用 passwd 命令更改自己的密码时，实际上是在用 passwd 命令所有者 root 的身份在执行  passwd 命令，root 当然可以将密码写入 /etc/shadow 文件，所以普通用户也可以修改 /etc/shadow  文件，命令执行完成后，该身份也随之消失。</em></p>
<p><em><strong>3.示例演示</strong></em></p>
<p><em>举个例子，有一个用户 lamp，她可以修改自己的密码，因为 passwd 命令拥有 SetUID 权限；但是她不能査看 /etc/shadow 文件的内容，因为査看文件的命令（如 cat）没有 SetUID 权限。命令如下：</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自己可以修改自己的密码，从而改变/etc/shadow中的数据</span></span><br><span class="line">[lamp@bgx ~]$ passwd</span><br><span class="line"></span><br><span class="line"><span class="comment">#但无法使用cat命令查看/etc/shadow</span></span><br><span class="line">[lamp@bgx ~]$ cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure>

<p><em><strong>4.例子解释</strong></em></p>
<p><em>passwd 是系统命令，可以执行，所以可以赋予 SetUID 权限。<br>lamp 用户对 passwd 命令拥有 x（执行）权限。<br>lamp 用户在执行 passwd 命令的过程中，会暂时切换为 root 身份，所以可以修改 /etc/shadow 文件。<br>命令结束，lamp 用户切换回自己的身份。<br>PS: cat命令没有 SetUID权限，所以使用 lamp 用户身份去访问 /etc/shadow 文件，当然没有相应权限了。<br>F: 但如果将passwd命令的suid去掉会发生什么？？？</em></p>
<p><em>2.suid授权方法4000 权限字符s(S),用户位置上的x位上设置</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 4755 passwd</span></span><br><span class="line"><span class="comment"># chmod  u+s  passwd</span></span><br></pre></td></tr></table></figure>

<p><em>3.suid的作用</em><br> <em>1.让普通用户对可执行的二进制文件，临时拥有二进制文件的所属主权限。<br>2.如果设置的二进制文件没有执行权限,那么suid的权限显示就是大S。<br>3.特殊权限suid仅对二进制可执行程序有效，其他文件或目录则无效。<br>注意: suid极度危险，不信可以尝试对vim或rm进行设定SetUID。</em></p>
<h1 id="3-特殊权限SGID"><a href="#3-特殊权限SGID" class="headerlink" title="3.特殊权限SGID"></a>3.特殊权限SGID</h1><p><em>将目录设置为sgid后，如果在该目录下创建文件，都将与该目录的所属组保持一致，演示如下</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.建立测试目录</span></span><br><span class="line">[root@bgx ~]<span class="comment"># cd /tmp/ &amp;&amp; mkdir dtest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.给测试目录赋予SetGID权限，检查SetGID是否生效</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod g+s dtest/ &amp;&amp; ll -d dtest/</span></span><br><span class="line">drwxr-sr-x 2 root root 6 Apr 13 05:21 dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.给测试目录赋予777权限，让普通用户可以写</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># chmod 777 dtest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.切换成普通用户lamp，并进入该目录</span></span><br><span class="line">[root@bgx tmp]<span class="comment"># su - lamp</span></span><br><span class="line">[lamp@bgx ~]$ <span class="built_in">cd</span> /tmp/dtest/</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.普通用户创建测试文件，检查文件的信息</span></span><br><span class="line">[lamp@bgx dtest]$ touch lamp_test</span><br><span class="line">[lamp@bgx dtest]$ ll</span><br><span class="line">-rw-rw-r-- 1 lamp root 0 Apr 13 05:21 lamp_test</span><br></pre></td></tr></table></figure>

<p><em>2.sgid授权方法: 2000权限字符s(S)，取决于属组位置上的x</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 2755  directory </span></span><br><span class="line"><span class="comment"># chmod  g+s  directory</span></span><br></pre></td></tr></table></figure>

<p><em>3.sgid作用<br>1.针对用户组权限位修改，用户创建的目录或文件所属组和该目录的所属组一致。<br>2.当某个目录设置了sgid后，在该目录中新建的文件不在是创建该文件的默认所属组<br>3.使用sgid可以使得多个用户之间共享一个目录的所有文件变得简单。</em></p>
<h1 id="4-特殊权限SBIT"><a href="#4-特殊权限SBIT" class="headerlink" title="4.特殊权限SBIT"></a>4.特殊权限SBIT</h1><p><em>Sticky(SI TI KI)粘滞位目前只对目录有效，作用如下：<br>普通用户对该目录拥有 w 和 x 权限，即普通用户可以在此目录中拥有写入权限。如果没有粘滞位，那么普通用户拥有 w  权限，就可以删除此目录下的所有文件，包括其他用户建立的文件。但是一旦被赋予了粘滞位，除了 root 可以删除所有文件，普通用户就算拥有 w  权限，也只能删除自己建立的文件，而不能删除其他用户建立的文件。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@bgx tmp]<span class="comment"># ll -d /tmp/</span></span><br><span class="line">drwxrwxrwt. 12 root root 4096 Apr 13 05:32 /tmp/</span><br></pre></td></tr></table></figure>

<p><em>sticky授权方法，1000 权限字符t(T),其他用户位的x位上设置。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chmod 1755  /tmp</span></span><br><span class="line"><span class="comment"># chmod o+t /tmp</span></span><br></pre></td></tr></table></figure>

<p><em>3.sticky作用</em><br> <em>1.让多个用户都具有写权限的目录，并让每个用户只能删自己的文件。<br> 2.特殊sticky目录表现在others的x位，用小t表示，如果没有执行权限是T<br> 3.一个目录即使它的权限为”777”如果是设置了粘滞位，除了目录的属主和”root”用户有权限删除，除此之外其他用户都不允许删除该目录。</em></p>
<h1 id="5-权限属性chattr"><a href="#5-权限属性chattr" class="headerlink" title="5.权限属性chattr"></a>5.权限属性chattr</h1><p><em>chatrr 只有 root 用户可以使用，用来修改文件系统的权限属性，建立凌驾于 rwx 基础权限之上的授权。<br>chatrr 命令格式：[root@bgx ~]# chattr [+-=] [选项] 文件或目录名</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: + 增加权限 -减少权限 =等于某个权限</span></span><br><span class="line"><span class="comment"># a：让文件或目录仅可追加内容</span></span><br><span class="line"><span class="comment"># i：不得任意更动文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.创建文件并设置属性</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file_a file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">---------------- file_a</span><br><span class="line">---------------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用chattr设置属性，lsattr查看权限限制</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +a file_a</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># chattr +i file_i</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># lsattr file_a file_i</span></span><br><span class="line">-----a---------- file_a</span><br><span class="line">----i----------- file_i</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.a权限，无法写入和删除文件，但可以追加数据，适合/etc/passwd这样的文件</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt; file_a</span></span><br><span class="line">bash: file_a: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f file_a</span></span><br><span class="line">rm: cannot remove ‘file_a’: Operation not permitted</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;aa&quot; &gt;&gt; file_a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.i权限, 无法写入，无法删除，适合不需要更改的重要文件加锁</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># echo &quot;i&quot; &gt;&gt; file_i</span></span><br><span class="line">bash: file_i: Permission denied</span><br><span class="line">[root@lucifer ~]<span class="comment"># rm -f  file_i</span></span><br><span class="line">rm: cannot remove ‘file_i’: Operation not permitted</span><br><span class="line"></span><br><span class="line"><span class="comment">#5.解除限制</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -a file_a	</span></span><br><span class="line">[root@tianyun ~]<span class="comment"># chattr -i file_i</span></span><br></pre></td></tr></table></figure>

<h1 id="6-进程掩码umask"><a href="#6-进程掩码umask" class="headerlink" title="6.进程掩码umask"></a>6.进程掩码umask</h1><p><em><strong>1.umask是什么?</strong></em><br> <em>当我们登录系统之后创建一个文件总是有一个默认权限的，比如: 目录755、文件644、那么这个权限是怎么来的呢？这就是umask干的事情。umask设置了用户创建文件的默认权限。</em></p>
<p><em><strong>2.umask是如何改变创建新文件的权限</strong></em><br><em>系统默认umask为022，那么当我们创建一个目录时，正常情况下目录的权限应该是777，但umask表示要减去的值，所以新目录文件的权限应该是777 - 022 =755。至于文件的权限也依次类推666 - 022 =644。</em></p>
<p><em><strong>3.umask涉及哪些配置文件</strong></em><br><em>umask涉及到的相关文件/etc/bashrc /etc/profile ~/.bashrc ~/.bash_profile<br> shell (vim,touch) –umask–&gt; 会影响创建的新文件或目录权限<br> vsftpd服务如果修改–umask–&gt; 会影响ftp服务中新创建文件或创建目录权限<br> useradd如果修改umask–&gt; 会影响用户HOME家目录权限</em></p>
<p><em><strong>4.umask演示示例</strong></em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.假设umask值为：022（所有位为偶数）</span></span><br><span class="line"><span class="comment">#文件的起始权限值</span></span><br><span class="line">6 6 6  -  0 2 2  = 6 4 4 </span><br><span class="line"></span><br><span class="line"><span class="comment">#2.假设umask值为：045（其他用户组位为奇数）</span></span><br><span class="line"><span class="comment">#计算出来的权限。由于umask的最后一位数字是5，所以，在其他用户组位再加1。</span></span><br><span class="line">6 6 6  -   0 4 5 = 6 2 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.默认目录权限计算方法</span></span><br><span class="line">7 7 7  -  0 2 2 = 7 5 5</span><br><span class="line"> </span><br><span class="line"><span class="comment">#umask所有位全为偶数时</span></span><br><span class="line"><span class="comment"># umask 044</span></span><br><span class="line"><span class="comment"># mkdir d044   目录权限为733</span></span><br><span class="line"><span class="comment"># touch f044   文件权限为622</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask部分位为奇数时</span></span><br><span class="line"><span class="comment"># umask 023</span></span><br><span class="line"><span class="comment"># mkdir d023   目录权限为754</span></span><br><span class="line"><span class="comment"># touch f023   文件权限为644	</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#umask值的所有位为奇数时</span></span><br><span class="line"><span class="comment"># umask 035</span></span><br><span class="line"><span class="comment"># mkdir d035   目录权限为742</span></span><br><span class="line"><span class="comment"># touch f035   文件权限为642</span></span><br></pre></td></tr></table></figure>

<p><em>示例1: 在 shell 进程中创建文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前用户的umask权限</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># umask</span></span><br><span class="line">0022</span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir0022</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d file0022  dir0022/</span></span><br><span class="line">drwxr-xr-x 2 root root 6 Jan 24 09:02 dir0022/</span><br><span class="line">-rw-r--r-- 1 root root 0 Jan 24 09:02 file0022</span><br></pre></td></tr></table></figure>

<p><em>示例2: 修改 shell umask 值(临时生效)</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># umask 000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># mkdir dir000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># touch file000</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d dir000 file000</span></span><br><span class="line">drwxrwxrwx 2 root root 6 Jan 24 09:04 dir000</span><br><span class="line">-rw-rw-rw- 1 root root 0 Jan 24 09:04 file000</span><br></pre></td></tr></table></figure>

<p><em>示例3: 通过 umask 决定新建用户 HOME 目录的权限</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@lucifer ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 077</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd dba</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/dba/</span></span><br><span class="line">drwx------. 4 dba dba 4096 3 月 11 19:50 /home/dba/</span><br><span class="line"></span><br><span class="line">[root@tianyun ~]<span class="comment"># vim /etc/login.defs</span></span><br><span class="line">UMASK 000</span><br><span class="line">[root@lucifer ~]<span class="comment"># useradd sa</span></span><br><span class="line">[root@lucifer ~]<span class="comment"># ll -d /home/sa/</span></span><br><span class="line">drwxrwxrwx. 4 sa sa 4096 3 月 11 19:53 /home/sa/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>权限 -</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux输入输出</title>
    <url>/2021/08/11/Linux%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p>1.重定向概述 2.输出重定向 3.输入重定向 4.进程管道技术</p>
<span id="more"></span>

<h1 id="1-重定向概述"><a href="#1-重定向概述" class="headerlink" title="1.重定向概述"></a>1.重定向概述</h1><p><em><strong>1.什么是重定向</strong></em></p>
<p><em>将原本要输出到屏幕的数据信息，重新定向到某个指定的文件中。比如：每天凌晨定时备份数据，希望将备份数据的结果保存到某个文件中。这样第二天通过查看文件的内容就知道昨天备份的数据是成功还是失败。</em></p>
<p><em><strong>2.为什么要使用重定向</strong></em></p>
<p><em>1.当屏幕输出的信息很重要，而且希望保存重要的信息时；<br>2.后台执行中的程序，不希望他干扰屏幕正常的输出结果时；<br>3.系统的例行命令, 例如定时任务的执行结果，希望可以存下来时；<br>4.一些执行命令，我们已经知道他可能出现错误信息, 想将他直接丢弃时;<br>5.错误日志与正确日志需要分别输出至不同的文件保存时;</em></p>
<p><em><strong>3.学习重定向的预备知识，标准输入与输出</strong></em></p>
<p><em>当运行一个程序时通常会自动打开三个标准文件，分别是标准输入、标准输出、错误输出</em></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>文件描述符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>标准输入（STDIN）</td>
<td>0</td>
<td>默认是键盘，也可以是其他文件或其他命令的输出</td>
</tr>
<tr>
<td>标准输出（STDOUT）</td>
<td>1</td>
<td>默认输出到屏幕</td>
</tr>
<tr>
<td>错误输出（STDERR）</td>
<td>2</td>
<td>默认输出到屏幕</td>
</tr>
<tr>
<td>文件名称（filename）</td>
<td>3+</td>
<td></td>
</tr>
</tbody></table>
<p><em>进程将从标准输入中得到数据，将正常输出打印至屏幕终端，将错误的输出信息也打印至屏幕终端。<br>PS: 进程是使用文件描述符<code>(file descriptors)</code>来管理打开的文件</em></p>
<h1 id="2-输出重定向"><a href="#2-输出重定向" class="headerlink" title="2.输出重定向"></a>2.输出重定向</h1><table>
<thead>
<tr>
<th>类型</th>
<th>操作符</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>标准覆盖输出重定向</td>
<td>&gt;</td>
<td>将程序输出的正确结果输出到指定的文件中,会覆盖文件原有的内容</td>
</tr>
<tr>
<td>标准追加输出重定向</td>
<td>&gt;&gt;</td>
<td>将程序输出的正确结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr>
<td>错误覆盖输出重定向</td>
<td>2&gt;</td>
<td>将程序的错误结果输出到执行的文件中，会覆盖文件原有的内容</td>
</tr>
<tr>
<td>错误追加输出重定向</td>
<td>2&gt;&gt;</td>
<td>将程序输出的错误结果以追加的方式输出到指定文件，不会覆盖原有文件</td>
</tr>
<tr>
<td>标准输入重定向</td>
<td>&lt;&lt;</td>
<td>将命令中接收输入的途径由默认的键盘更改为指定的文件或命令</td>
</tr>
</tbody></table>
<h1 id="3-输入重定向"><a href="#3-输入重定向" class="headerlink" title="3.输入重定向"></a>3.输入重定向</h1><p><em>输入重定向，即原本从键盘等上获得的输入信息，重定向由命令的输出作为输入。&lt; 等价 0&lt;</em></p>
<p><em>案例1: 从文件中读入输入的操作</em></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail alice </span></span><br><span class="line">Subject: hello</span><br><span class="line">1111 </span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">.   <span class="comment">#结束</span></span><br><span class="line">EOT</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查是否收到邮件</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># su - alice</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入重定向，来自于文件</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># mail -s &quot;test01&quot; alice &lt; /etc/hosts</span></span><br></pre></td></tr></table></figure>

<p><em>案例2: 无法形容案例，请看实际操作</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#没有改变输入的方向，默认键盘，此时等待输入</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># grep &#x27;root&#x27; </span></span><br><span class="line">xxx</span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># grep &#x27;root&#x27; &lt; /etc/passwd</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash </span><br></pre></td></tr></table></figure>

<p><em>案例3: 无法形容案例，请看实际操作</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># dd if=/dev/zero of=/file1.txt bs=1M count=20</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># dd &lt;/dev/zero &gt;/file2.txt bs=1M count=20</span></span><br></pre></td></tr></table></figure>

<p><em>案例4: mysql如何恢复备份，了解即可，不用关注。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># mysql -uroot -p123 &lt; bbs.sql</span></span><br></pre></td></tr></table></figure>

<p><em>案例5: 利用重定向建立多行数据的文件</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动执行 shell 命令</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># echo &quot;111&quot; &gt; file1.txt </span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat file1.txt</span></span><br><span class="line">111</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat &gt;file2.txt</span></span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">^D</span><br><span class="line"></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># cat &gt;&gt;file3.txt</span></span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">ccc</span><br><span class="line">^D</span><br></pre></td></tr></table></figure>

<p><em>案例6: 脚本中打印菜单的一种使用方法。</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># vim vm.sh</span></span><br><span class="line">cat &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">+------------------- --- ---- --- ---- --- --- ---- --- --+ ||</span></span><br><span class="line"><span class="string">| ====================== | </span></span><br><span class="line"><span class="string">| 虚拟机基本管理 v5.0 |</span></span><br><span class="line"><span class="string">| by xuliangwei |</span></span><br><span class="line"><span class="string">| ====================== | </span></span><br><span class="line"><span class="string">| 1. 安装 KVM |</span></span><br><span class="line"><span class="string">| 2. 安装或重置 CentOS-6.9 | </span></span><br><span class="line"><span class="string">| 3. 安装或重置 CentOS-7.4 | </span></span><br><span class="line"><span class="string">| 5. 安装或重置 Windows-7  | </span></span><br><span class="line"><span class="string">| 6. 删除所有虚拟机 |</span></span><br><span class="line"><span class="string">| q. 退出管理程序 |</span></span><br><span class="line"><span class="string">+------------------- --- ---- --- ---- --- --- ---- --- --+ </span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p><em>案例7: 两条命令同时重定向</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># ls; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># ls &amp;&gt;/dev/null; date &amp;&gt;/dev/null</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (ls; date) &amp;&gt;/dev/null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#后台执行</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;</span></span><br><span class="line">[1] 6378</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (while :; do date; sleep 2; done) &amp;&gt;date.txt &amp;</span></span><br><span class="line">[root@xuliangwei ~]<span class="comment"># jobs</span></span><br><span class="line">[1]+ 运行中 ( <span class="keyword">while</span> :; <span class="keyword">do</span> date; sleep 2;</span><br><span class="line"><span class="keyword">done</span> ) &amp;&gt;/date.txt &amp;</span><br></pre></td></tr></table></figure>

<p><em>扩展点: subshell 了解即可</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@xuliangwei ~]<span class="comment"># cd /boot; ls</span></span><br><span class="line"></span><br><span class="line">//subshell 中执行</span><br><span class="line">[root@xuliangwei ~]<span class="comment"># (cd /boot; ls)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不希望某些命令的执行对当前 shell 环境产生影响，请在subshell中执行</span></span><br></pre></td></tr></table></figure>

<h1 id="4-进程管道技术"><a href="#4-进程管道技术" class="headerlink" title="4.进程管道技术"></a>4.进程管道技术</h1><p>*<strong>1.什么是管道*</strong><br> <em>管道操作符号 “|” ，主要用来连接左右两个命令, 将左侧的命令的标准输出, 交给右侧命令的标准输入<br>PS: 无法传递标准错误输出至后者命令</em></p>
]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>输入输出 -</tag>
      </tags>
  </entry>
  <entry>
    <title>find命令详解</title>
    <url>/2021/08/06/find%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<p><em>find命令</em></p>
<span id="more"></span>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">一般格式： find  +  目录名称  +  参数</span><br></pre></td></tr></table></figure>



<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">参数的含义：</span><br><span class="line"></span><br><span class="line">-name           #文件名称</span><br><span class="line">-not            #非，取反</span><br><span class="line">-user           #文件所有人</span><br><span class="line">-group          #文件所有组</span><br><span class="line">-a              #并且关系</span><br><span class="line">-o              #或者关系</span><br><span class="line">-maxdepth       #最大深度</span><br><span class="line">-mindepth       #最小深度</span><br><span class="line"></span><br><span class="line">-size 表示文件大小</span><br><span class="line">     -size  20K      # 查找大小为20K的文件</span><br><span class="line">     -size  -20K     # -表示小于；查找比20K小的文件</span><br><span class="line">     -size  +20k     # +表示大于；查看比20K大的文件</span><br><span class="line"></span><br><span class="line">-type           #文件类型</span><br><span class="line"> 主要的文件类型：</span><br><span class="line">     f     #普通文件</span><br><span class="line">     d     #目录</span><br><span class="line">     b     #块设备</span><br><span class="line">     s     #套接字</span><br><span class="line">     c     #字符设备</span><br><span class="line">     l     #链接</span><br><span class="line">     p     #管道</span><br><span class="line">     </span><br><span class="line">-perm   表示权限</span><br><span class="line">   -perm  444       #查找文件权限</span><br><span class="line">   -perm  -444      # -表示并且；查找文件权限中u位有r权限，并且g位有r权限，并且o位有r权限的文件</span><br><span class="line">   -perm  /444      # /表示或者；查找文件权限中u位有r权限，或者g位有r权限，或者o位有r权限的文件</span><br><span class="line">   -perm  /777      # 777=rwx rwx rwx 即9个条件中满足任意一个即可</span><br><span class="line">   </span><br><span class="line">ctime 与 cmin 都表示按照时间查找被篡改的文件</span><br><span class="line">ctime   ##以天为单位</span><br><span class="line">cmin    ##以分钟为单位 </span><br><span class="line">   -cmin  10         #查找文件更新距离现在10分钟的文件</span><br><span class="line">   -cmin  +10        #查找文件更新距离现在超过10分钟的文件</span><br><span class="line">   -cmin  -10        #查找文件更新距离现在10分钟以内的文件</span><br><span class="line">   -ctime  +/-10     #查找文件更新距离现在超过10天/10天以内的文件</span><br><span class="line"></span><br><span class="line">-exec   命令  &#123;&#125;   \;      #对查找到的文件执行某命令；-exec表示开始执行动作  &#123;&#125; 表示用find命令查找出的所有文件</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h4 id="实例1：按照文件名查找"><a href="#实例1：按照文件名查找" class="headerlink" title="实例1：按照文件名查找"></a><em><strong>实例1：按照文件名查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查找/etc目录中文件名为passwd的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##查找/etc目录中文件名以.conf文件结尾的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /etc/ -name *.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="实例2：按文件所有人和文件所有组查找"><a href="#实例2：按文件所有人和文件所有组查找" class="headerlink" title="实例2：按文件所有人和文件所有组查找"></a><em><strong>实例2：按文件所有人和文件所有组查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##按文件的所有人查找</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user student </span></span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##按文件的所有组查找</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##默认表示并且</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">## -a表示并且</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -a -group westos</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">## -o表示或者</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -user root -o -group westos</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line">/mnt/file4</span><br><span class="line">/mnt/file5</span><br><span class="line"><span class="comment">## -not表示非；即反向选择</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -not -user student </span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file4</span><br><span class="line">/mnt/file5</span><br></pre></td></tr></table></figure>

<h4 id="实例3：按文件所在的深度（层次）查找"><a href="#实例3：按文件所在的深度（层次）查找" class="headerlink" title="实例3：按文件所在的深度（层次）查找"></a><em><strong>实例3：按文件所在的深度（层次）查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##-maxdepth表示最大深度，即最多层次</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -maxdepth 1 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -maxdepth 2 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##-mindepth表示最小深度，即最少层次</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 2 -name passwd</span></span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 1 -name passwd</span></span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/pam.d/passwd</span><br><span class="line"><span class="comment">##查找/etc目录下最少层次为1最多层次为2的以.conf结尾的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -mindepth 1 -maxdepth 2 -name *.conf</span></span><br></pre></td></tr></table></figure>

<h4 id="实例4：按文件的大小查找"><a href="#实例4：按文件的大小查找" class="headerlink" title="实例4：按文件的大小查找"></a><em><strong>实例4：按文件的大小查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost mnt]<span class="comment"># ll -l</span></span><br><span class="line">total 72</span><br><span class="line">-rw-r--r--. 1 root root 10240 Nov 11 04:06 file1</span><br><span class="line">-rw-r--r--. 1 root root 20480 Nov 11 04:06 file2</span><br><span class="line">-rw-r--r--. 1 root root 40960 Nov 11 04:06 file3</span><br><span class="line"><span class="comment">##查找/mnt目录下文件大小为20k的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size 20k</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查找/mnt目录下比20k小的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size -20k</span></span><br><span class="line">/mnt/</span><br><span class="line">/mnt/file1</span><br><span class="line"><span class="comment">##查找/mnt目录下比20k大的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -size +20k</span></span><br><span class="line">/mnt/file3</span><br></pre></td></tr></table></figure>

<h4 id="实例5：按文件类型查找"><a href="#实例5：按文件类型查找" class="headerlink" title="实例5：按文件类型查找"></a><em><strong>实例5：按文件类型查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##f表示普通文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type f</span></span><br><span class="line">/dev/shm/pulse-shm-620843697</span><br><span class="line">/dev/shm/pulse-shm-1247103260</span><br><span class="line">/dev/shm/pulse-shm-2690706600</span><br><span class="line">/dev/shm/pulse-shm-368331657</span><br><span class="line"><span class="comment">##b表示块设备</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type b</span></span><br><span class="line">/dev/dm-0</span><br><span class="line">/dev/sr0</span><br><span class="line">/dev/vdb1</span><br><span class="line">/dev/vdb</span><br><span class="line">/dev/vda1</span><br><span class="line">/dev/vda</span><br><span class="line"><span class="comment">##s表示套接字</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type s</span></span><br><span class="line">/dev/<span class="built_in">log</span></span><br><span class="line"><span class="comment">##p表示管道</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type p</span></span><br><span class="line">/dev/initctl</span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -type f</span></span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file3</span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##d表示目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /mnt -type d</span></span><br><span class="line">/mnt</span><br></pre></td></tr></table></figure>

<h4 id="实例6：按文件权限查找"><a href="#实例6：按文件权限查找" class="headerlink" title="实例6：按文件权限查找"></a><em><strong>实例6：按文件权限查找</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查找文件权限为404的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm 404</span></span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查看文件权限中u位有r权限，并且o位有r权限的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm -404</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line"><span class="comment">##查看文件权限中u位有r权限，或者o位有r权限的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm /404</span></span><br><span class="line">/mnt</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line">[root@localhost mnt]<span class="comment"># ll -d /mnt/</span></span><br><span class="line">drwxr-xr-x. 2 root root 42 Nov 14 09:41 /mnt/</span><br></pre></td></tr></table></figure>

<h4 id="实例7：按文件更新的时间"><a href="#实例7：按文件更新的时间" class="headerlink" title="实例7：按文件更新的时间"></a><em><strong>实例7：按文件更新的时间</strong></em></h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># cd /mnt</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># rm -rf *</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ls</span></span><br><span class="line"><span class="comment">##建立文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># touch file&#123;1..3&#125;</span></span><br><span class="line"><span class="comment">##查找文件更新距离现在为1分钟的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime 1</span></span><br><span class="line"><span class="comment">##查找文件更新距离现在为1分钟以内的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime -1</span></span><br><span class="line">/mnt/</span><br><span class="line">/mnt/file1</span><br><span class="line">/mnt/file2</span><br><span class="line">/mnt/file3</span><br><span class="line"><span class="comment">##查找文件更新距离现在超过1分钟的文件</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt/ -ctime +1</span></span><br></pre></td></tr></table></figure>

<h4 id="实例8：对查找到的文件执行某些动作"><a href="#实例8：对查找到的文件执行某些动作" class="headerlink" title="实例8：对查找到的文件执行某些动作"></a><em><strong>实例8：对查找到的文件执行某些动作</strong></em></h4><h5 id="1-给-mnt下文件权限包含004的文件的g位加w的权限"><a href="#1-给-mnt下文件权限包含004的文件的g位加w的权限" class="headerlink" title="(1).给/mnt下文件权限包含004的文件的g位加w的权限"></a><strong>(1).给/mnt下文件权限包含004的文件的g位加w的权限</strong></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost mnt]<span class="comment"># pwd</span></span><br><span class="line">/mnt</span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##更改权限</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># chmod 404 /mnt/file2</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r-----r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##给/mnt下文件权限包含004的文件的g位加w的权限</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># find /mnt -perm 404 -exec chmod g+w &#123;&#125; \;</span></span><br><span class="line">[root@localhost mnt]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br></pre></td></tr></table></figure>

<h5 id="2-将系统中属于mail组的文件备份到-mnt下"><a href="#2-将系统中属于mail组的文件备份到-mnt下" class="headerlink" title="(2).将系统中属于mail组的文件备份到/mnt下"></a><em><strong>(2).将系统中属于mail组的文件备份到/mnt下</strong></em></h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ll /mnt</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line"><span class="comment">##将系统中属于mail组的文件备份到/mnt下</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find / -group mail -exec cp &#123;&#125; /mnt \;</span></span><br><span class="line">find: ‘/proc/6812/task/6812/fd/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/task/6812/fdinfo/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/fd/6’: No such file or directory</span><br><span class="line">find: ‘/proc/6812/fdinfo/6’: No such file or directory</span><br><span class="line">cp: omitting directory ‘/var/spool/mail’</span><br><span class="line">[root@localhost ~]<span class="comment"># ll /mnt</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file1</span><br><span class="line">-r---w-r-- 1 root root 0 Nov 14 10:06 file2</span><br><span class="line">-rw-r--r-- 1 root root 0 Nov 14 10:06 file3</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 rpc</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 student</span><br><span class="line">-rw-r----- 1 root root 0 Nov 14 10:14 westos</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>命令 -</tag>
      </tags>
  </entry>
  <entry>
    <title>yum仓库</title>
    <url>/2021/08/12/yum%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script src='https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js'></script>

<span id="more"></span>

<h1 id="搭建公司内部的yum源，搭建yum仓库"><a href="#搭建公司内部的yum源，搭建yum仓库" class="headerlink" title="搭建公司内部的yum源，搭建yum仓库"></a>搭建公司内部的yum源，搭建yum仓库</h1><h3 id="1，基础环境准备"><a href="#1，基础环境准备" class="headerlink" title="1，基础环境准备"></a>1，基础环境准备</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭selinux，方式1</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s#SELINUX=enforcing#SELINUX=disabled#g&#x27;</span><br><span class="line">/etc/selinux/config</span><br><span class="line"><span class="meta">#</span><span class="bash">关闭selinux的，方式2</span></span><br><span class="line">vim /etc/selinux/config</span><br><span class="line">修改为SELINUX=disabled</span><br></pre></td></tr></table></figure>

<h3 id="2，安装ftp服务，并设置开机启动"><a href="#2，安装ftp服务，并设置开机启动" class="headerlink" title="2，安装ftp服务，并设置开机启动"></a>2，安装ftp服务，并设置开机启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装ftp服务</span></span><br><span class="line">yum install -y vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash">启动ftp服务</span></span><br><span class="line">systemctl start vsftpd</span><br><span class="line"><span class="meta">#</span><span class="bash">设置为开机启动</span></span><br><span class="line">systemctl enable vsftpd</span><br></pre></td></tr></table></figure>

<h3 id="3，开启yum缓存功能"><a href="#3，开启yum缓存功能" class="headerlink" title="3，开启yum缓存功能"></a>3，开启yum缓存功能</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启yum缓存功能</span></span><br><span class="line">vim /etc/yum.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改为</span></span><br><span class="line">vim /etc/yum.conf</span><br><span class="line">[main] </span><br><span class="line">cachedir=/var/cache/yum/$basearch/$releasever</span><br><span class="line">keepcache=1</span><br><span class="line"><span class="meta">#</span><span class="bash">清除缓存</span></span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure>

<h3 id="4，提供基础base源-epel源"><a href="#4，提供基础base源-epel源" class="headerlink" title="4，提供基础base源/epel源"></a>4，提供基础base源/epel源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建base源仓库</span></span><br><span class="line">mkdir -p /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">挂载光盘镜像</span></span><br><span class="line">mount /dev/cdrom /mnt/</span><br><span class="line"><span class="meta">#</span><span class="bash">将光盘中的rpm包复制到源仓库</span></span><br><span class="line">cp -a /mnt/Packages/*.rpm /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">创建epel源仓库</span></span><br><span class="line">mkdir -p /var/ftp/epel</span><br><span class="line"><span class="meta">#</span><span class="bash">下载elep源中的服务</span></span><br><span class="line">yum install -y nginx sl docker</span><br><span class="line"><span class="meta">#</span><span class="bash">复制epel源服务到epel源仓库</span></span><br><span class="line">find /var/cache/yum/ -type f -name &quot;*.rpm&quot; |xargs cp -t /var/ftp/epel</span><br></pre></td></tr></table></figure>

<h3 id="5，安装createrepo并创建reopdata仓库"><a href="#5，安装createrepo并创建reopdata仓库" class="headerlink" title="5，安装createrepo并创建reopdata仓库"></a>5，安装createrepo并创建reopdata仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装 createrepo</span></span><br><span class="line">yum install -y createrepo</span><br><span class="line"><span class="meta">#</span><span class="bash">生成base源仓库信息</span></span><br><span class="line">createrepo /var/ftp/CentOS7</span><br><span class="line"><span class="meta">#</span><span class="bash">生成elep源仓库信息</span></span><br><span class="line">createrepo /var/ftp/epel</span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果此仓库每新增一次软件，需要重新生成一次</span></span><br></pre></td></tr></table></figure>

<h3 id="6，客户端yum源设置"><a href="#6，客户端yum源设置" class="headerlink" title="6，客户端yum源设置"></a>6，客户端yum源设置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将原有的yum源压缩</span></span><br><span class="line">gzip /etc/yum.repos.d/*</span><br><span class="line"><span class="meta">#</span><span class="bash">·</span>	</span><br><span class="line">vim /etc/yum.repo.d/CentOS7</span><br><span class="line">i</span><br><span class="line"><span class="meta">#</span><span class="bash">新建epel源</span></span><br><span class="line">vim /etc/yum.repo.d/epel.repo</span><br><span class="line">[epel]</span><br><span class="line">name=local ftpserver</span><br><span class="line">baseurl=ftp://10.0.0.105/epel</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure>

<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">rsync  nfs-utils mariadb-<span class="keyword">server</span>  MySQL-python redis  nginx GeoIP-devel ncurses-devel keepalived </span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mkdir</span> <span class="string">/opt/yum</span></span><br><span class="line">  <span class="attr">file:</span> </span><br><span class="line">    <span class="attr">path:</span> <span class="string">/opt/yum</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">移动原有源</span></span><br><span class="line">  <span class="attr">shell:</span> <span class="string">&quot;mv -f /etc/yum.repos.d/* /opt/yum&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Centos7.repo</span></span><br><span class="line">  <span class="attr">yum_repository:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">centos7</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">Centos7.repo</span></span><br><span class="line">    <span class="attr">baseurl:</span> <span class="string">ftp://10.0.0.61/CentOS7</span> </span><br><span class="line">    <span class="attr">gpgcheck:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">repo</span></span><br><span class="line">  <span class="attr">yum_repository:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">repo</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">epel</span> <span class="string">repo</span></span><br><span class="line">    <span class="attr">baseurl:</span> <span class="string">ftp://10.0.0.61/epel</span></span><br><span class="line">    <span class="attr">gpgcheck:</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>基础 -</category>
      </categories>
      <tags>
        <tag>yum仓库 -</tag>
      </tags>
  </entry>
</search>
